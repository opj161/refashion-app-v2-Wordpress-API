This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.dockerignore
.eslintrc.js
.gitignore
build-log.txt
components.json
cors.json
docker-compose.secure.yml
docker-compose.yml
Dockerfile
docs/api_v1.md
docs/authentication.md
docs/blueprint.md
docs/IntegrationsManual.md
docs/openapi.json
entrypoint.sh
jest.config.js
jest.setup.js
next.config.ts
package.json
postcss.config.mjs
README.md
scripts/add-api-key-columns-to-users.ts
scripts/add-granular-api-key-columns.ts
scripts/cleanup-cache.js
scripts/migrate-api-features.ts
scripts/migrate-json-to-sqlite.ts
scripts/migrate-users-to-sqlite.ts
scripts/README.md
src/actions/adminActions.ts
src/actions/apiActions.ts
src/actions/authActions.ts
src/actions/historyActions.ts
src/ai/actions/cache-manager.ts
src/ai/actions/generate-video.action.ts
src/ai/actions/remove-background.action.ts
src/ai/actions/upload-and-resize-image.action.ts
src/ai/actions/upscale-image.action.ts
src/ai/flows/generate-image-edit.ts
src/app/admin/_components/AdminLoading.tsx
src/app/admin/_components/AdminNav.tsx
src/app/admin/layout.tsx
src/app/admin/page.tsx
src/app/admin/settings/_components/SettingsForm.tsx
src/app/admin/settings/page.tsx
src/app/admin/users/page.tsx
src/app/api/debug/complete-video/route.ts
src/app/api/debug/history/route.ts
src/app/api/history/[itemId]/status/route.ts
src/app/api/image-proxy/[...slug]/route.ts
src/app/api/upload-user-image/route.test.ts
src/app/api/upload-user-image/route.ts
src/app/api/v1/generate/route.ts
src/app/api/v1/status/[jobId]/route.ts
src/app/api/video/start/route.ts
src/app/api/video/webhook/route.ts
src/app/create/page.tsx
src/app/globals.css
src/app/history/page.tsx
src/app/layout.tsx
src/app/login/page.tsx
src/app/manifest.json
src/components/admin/UserManagementTable.tsx
src/components/AspectRatioSelector.tsx
src/components/creation-hub.tsx
src/components/history-gallery.tsx
src/components/HistoryCard.tsx
src/components/HistoryDetailModal.tsx
src/components/image-parameters.tsx
src/components/ImageComparator.tsx
src/components/ImageEditorCanvas.tsx
src/components/ImagePreparationContainer.tsx
src/components/ImageProcessingTools.tsx
src/components/ImageUploader.tsx
src/components/ImageVersionStack.tsx
src/components/SiteHeader.tsx
src/components/ui/accordion.tsx
src/components/ui/alert-dialog.tsx
src/components/ui/alert.tsx
src/components/ui/avatar.tsx
src/components/ui/badge.tsx
src/components/ui/button.tsx
src/components/ui/calendar.tsx
src/components/ui/card.tsx
src/components/ui/checkbox.tsx
src/components/ui/dialog.tsx
src/components/ui/dropdown-menu.tsx
src/components/ui/form.tsx
src/components/ui/input.tsx
src/components/ui/label.tsx
src/components/ui/menubar.tsx
src/components/ui/motion.ts
src/components/ui/page-header.tsx
src/components/ui/popover.tsx
src/components/ui/progress.tsx
src/components/ui/radio-group.tsx
src/components/ui/scroll-area.tsx
src/components/ui/select.tsx
src/components/ui/separator.tsx
src/components/ui/sheet.tsx
src/components/ui/skeleton.tsx
src/components/ui/slider.tsx
src/components/ui/switch.tsx
src/components/ui/table.tsx
src/components/ui/tabs.tsx
src/components/ui/textarea.tsx
src/components/ui/ThemeToggleImproved.tsx
src/components/ui/toast.tsx
src/components/ui/toaster.tsx
src/components/ui/toggle-group.tsx
src/components/ui/tooltip.tsx
src/components/video-parameters.tsx
src/components/VideoHistoryCard.tsx
src/components/VideoPlaybackModal.tsx
src/contexts/AuthContext.tsx
src/contexts/ThemeContext.tsx
src/hooks/use-mobile.tsx
src/hooks/use-toast.ts
src/hooks/usePromptManager.ts
src/lib/api-auth.ts
src/lib/motion-constants.ts
src/lib/pricing.ts
src/lib/prompt-builder.ts
src/lib/session.ts
src/lib/types.ts
src/lib/utils.test.ts
src/lib/utils.ts
src/middleware.ts
src/services/apiKey.service.ts
src/services/database.service.ts
src/services/encryption.service.ts
src/services/fal-api/image.service.ts
src/services/fal-api/video.service.ts
src/services/settings.service.ts
src/services/storage.service.ts
src/stores/__tests__/imageStore.test.ts
src/stores/imageStore.ts
tailwind.config.ts
tsconfig.jest.json
tsconfig.json
tsconfig.scripts.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".dockerignore">
# Ignored by default by most tools
.DS_Store
.env
.env.*
.idea/
.vscode/
npm-debug.log

# User-generated content and build artifacts
# These should NOT be in the image.
node_modules
.next/
out/
public/uploads/
user_data/

# Explicitly INCLUDE files and folders needed for the build.
# This prevents them from being accidentally ignored.
!/src
!/public
!/components.json
!/next.config.ts
!/package.json
!/package-lock.json
!/postcss.config.js
!/postcss.config.mjs
!/tailwind.config.ts
!/tsconfig.json
!/entrypoint.sh
!/Dockerfile
!/.dockerignore
</file>

<file path=".eslintrc.js">
module.exports = {
  extends: ['next/core-web-vitals'],
};
</file>

<file path=".gitignore">
.icons/apple-icon.png
.icons/favicon.ico
.icons/icon0.svg
.icons/icon1.png
</file>

<file path="build-log.txt">
--progress is a global compose flag, better use `docker compose --progress xx build ...
Compose can now delegate builds to bake for better performance.
 To do so, set COMPOSE_BAKE=true.
#0 building with "desktop-linux" instance using docker driver

#1 [app internal] load build definition from Dockerfile
#1 transferring dockerfile: 2.59kB done
#1 DONE 0.0s

#2 [app internal] load metadata for docker.io/library/node:20-alpine
#2 DONE 0.0s

#3 [app internal] load .dockerignore
#3 transferring context: 2B done
#3 DONE 0.0s

#4 [app internal] load build context
#4 DONE 0.0s

#5 [app base 1/1] FROM docker.io/library/node:20-alpine@sha256:d3507a213936fe4ef54760a186e113db5188472d9efdf491686bd94580a1c1e8
#5 resolve docker.io/library/node:20-alpine@sha256:d3507a213936fe4ef54760a186e113db5188472d9efdf491686bd94580a1c1e8
#5 ...

#6 [app auth] library/node:pull token for registry-1.docker.io
#6 DONE 0.0s

#5 [app base 1/1] FROM docker.io/library/node:20-alpine@sha256:d3507a213936fe4ef54760a186e113db5188472d9efdf491686bd94580a1c1e8
#5 resolve docker.io/library/node:20-alpine@sha256:d3507a213936fe4ef54760a186e113db5188472d9efdf491686bd94580a1c1e8 1.5s done
#5 DONE 1.5s

#7 [app builder 1/5] WORKDIR /app
#7 CACHED

#5 [app base 1/1] FROM docker.io/library/node:20-alpine@sha256:d3507a213936fe4ef54760a186e113db5188472d9efdf491686bd94580a1c1e8
#5 CACHED

#4 [app internal] load build context
#4 ...

#8 [app runner 2/9] RUN apk add --no-cache su-exec
#8 0.529 fetch https://dl-cdn.alpinelinux.org/alpine/v3.22/main/x86_64/APKINDEX.tar.gz
#8 0.724 fetch https://dl-cdn.alpinelinux.org/alpine/v3.22/community/x86_64/APKINDEX.tar.gz
#8 1.562 (1/1) Installing su-exec (0.2-r3)
#8 1.579 Executing busybox-1.37.0-r18.trigger
#8 1.589 OK: 10 MiB in 19 packages
#8 DONE 1.9s

#9 [app deps 1/4] RUN apk add --no-cache libc6-compat
#9 0.532 fetch https://dl-cdn.alpinelinux.org/alpine/v3.22/main/x86_64/APKINDEX.tar.gz
#9 0.727 fetch https://dl-cdn.alpinelinux.org/alpine/v3.22/community/x86_64/APKINDEX.tar.gz
#9 1.566 (1/3) Installing musl-obstack (1.2.3-r2)
#9 1.579 (2/3) Installing libucontext (1.3.2-r0)
#9 1.591 (3/3) Installing gcompat (1.1.0-r4)
#9 1.608 OK: 10 MiB in 21 packages
#9 DONE 1.9s

#4 [app internal] load build context
#4 ...

#10 [app deps 2/4] WORKDIR /app
#10 DONE 0.0s

#4 [app internal] load build context
#4 transferring context: 5.36MB 3.2s done
#4 DONE 3.3s

#11 [app deps 3/4] COPY package.json package-lock.json* ./
#11 DONE 0.3s

#12 [app deps 4/4] RUN npm install && npm prune --production && npm cache clean --force
#12 3.969 npm warn deprecated rimraf@2.7.1: Rimraf versions prior to v4 are no longer supported
#12 5.017 npm warn deprecated inflight@1.0.6: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.
#12 8.049 npm warn deprecated glob@7.2.3: Glob versions prior to v9 are no longer supported
#12 26.29 
#12 26.29 added 675 packages, and audited 676 packages in 26s
#12 26.29 
#12 26.29 98 packages are looking for funding
#12 26.29   run `npm fund` for details
#12 26.31 
#12 26.31 1 low severity vulnerability
#12 26.31 
#12 26.31 To address all issues, run:
#12 26.31   npm audit fix --force
#12 26.31 
#12 26.31 Run `npm audit` for details.
#12 26.31 npm notice
#12 26.31 npm notice New major version of npm available! 10.8.2 -> 11.4.1
#12 26.31 npm notice Changelog: https://github.com/npm/cli/releases/tag/v11.4.1
#12 26.31 npm notice To update run: npm install -g npm@11.4.1
#12 26.31 npm notice
#12 26.45 npm warn config production Use `--omit=dev` instead.
#12 28.92 
#12 28.92 up to date, audited 329 packages in 2s
#12 28.92 
#12 28.92 65 packages are looking for funding
#12 28.92   run `npm fund` for details
#12 28.95 
#12 28.95 1 low severity vulnerability
#12 28.95 
#12 28.95 To address all issues, run:
#12 28.95   npm audit fix --force
#12 28.95 
#12 28.95 Run `npm audit` for details.
#12 29.07 npm warn using --force Recommended protections disabled.
#12 DONE 30.8s

#13 [app builder 2/5] COPY --from=deps /app/node_modules ./node_modules
#13 DONE 4.4s

#14 [app builder 3/5] COPY . .
#14 DONE 12.6s

#15 [app builder 4/5] RUN mkdir -p public/uploads/user_uploaded_clothing &&     mkdir -p public/uploads/generated_images &&     mkdir -p user_data/history
#15 DONE 0.6s

#16 [app builder 5/5] RUN npm run build
#16 0.771 
#16 0.771 > nextn@0.1.0 build
#16 0.771 > next build
#16 0.771 
#16 1.481    Γû▓ Next.js 15.2.3
#16 1.481    - Environments: .env
#16 1.481 
#16 1.866    Creating an optimized production build ...
#16 19.28  Γ£ô Compiled successfully
#16 19.29    Skipping validation of types
#16 19.29    Skipping linting
#16 19.55    Collecting page data ...
#16 21.70    Generating static pages (0/9) ...
#16 22.24 [getCurrentUser] Attempting to fetch current user session.
#16 22.26    Generating static pages (2/9) 
#16 22.27 [getCurrentUser] Attempting to fetch current user session.
#16 22.27 [getCurrentUser] Attempting to fetch current user session.
#16 22.27 [getCurrentUser] Attempting to fetch current user session.
#16 22.29    Generating static pages (4/9) 
#16 22.31 [getCurrentUser] Attempting to fetch current user session.
#16 22.34    Generating static pages (6/9) 
#16 22.40 [getCurrentUser] Attempting to fetch current user session.
#16 22.40  Γ£ô Generating static pages (9/9)
#16 23.33    Finalizing page optimization ...
#16 23.33    Collecting build traces ...
#16 39.87 
#16 39.88 Route (app)                                 Size  First Load JS
#16 39.88 Γöî ╞Æ /                                    61.3 kB         175 kB
#16 39.88 Γö£ ╞Æ /_not-found                            977 B         101 kB
#16 39.88 Γö£ ╞Æ /admin                                 506 B         101 kB
#16 39.88 Γö£ ╞Æ /admin/all-history                   1.49 kB         102 kB
#16 39.88 Γö£ ╞Æ /admin/playground                      139 B         101 kB
#16 39.88 Γö£ ╞Æ /api/image-proxy/[...slug]             139 B         101 kB
#16 39.88 Γöö ╞Æ /login                               2.52 kB         112 kB
#16 39.88 + First Load JS shared by all             100 kB
#16 39.88   Γö£ chunks/4bd1b696-c55efc3b14a1bc4a.js  53.2 kB
#16 39.88   Γö£ chunks/684-7c126003f1aabdc8.js       45.3 kB
#16 39.88   Γöö other shared chunks (total)          1.91 kB
#16 39.88 
#16 39.88 
#16 39.88 ╞Æ Middleware                             39.9 kB
#16 39.88 
#16 39.88 ╞Æ  (Dynamic)  server-rendered on demand
#16 39.88 
#16 39.92 npm notice
#16 39.92 npm notice New major version of npm available! 10.8.2 -> 11.4.1
#16 39.92 npm notice Changelog: https://github.com/npm/cli/releases/tag/v11.4.1
#16 39.92 npm notice To update run: npm install -g npm@11.4.1
#16 39.92 npm notice
#16 DONE 40.1s

#17 [app runner 3/9] COPY --from=builder /app/public ./public
#17 DONE 0.2s

#18 [app runner 4/9] COPY --from=builder /app/.next/standalone ./
#18 DONE 0.6s

#19 [app runner 5/9] COPY --from=builder /app/.next/static ./.next/static
#19 DONE 0.1s

#20 [app runner 6/9] RUN mkdir -p /app/user_data/history &&     chmod -R 755 /app/user_data
#20 DONE 0.3s

#21 [app runner 7/9] RUN mkdir -p /app/public/uploads/user_uploaded_clothing &&     mkdir -p /app/public/uploads/generated_images &&     chmod -R 755 /app/public/uploads
#21 DONE 1.2s

#22 [app runner 8/9] COPY entrypoint.sh /entrypoint.sh
#22 DONE 0.0s

#23 [app runner 9/9] RUN chmod +x /entrypoint.sh
#23 DONE 0.4s

#24 [app] exporting to image
#24 exporting layers
#24 exporting layers 5.0s done
#24 exporting manifest sha256:d11d4be7ea06ed0f2aeb9e4a76548b067c3d43f1c76aecf2afac8591c4c3a4f1 0.0s done
#24 exporting config sha256:1ad4fb3c7a9969799759b0b15fa07a6c55ce0ce0ad3cb2119171300fcc7f35ba done
#24 exporting attestation manifest sha256:10a7c2fb3d8780076d33dd7effb785657cbd6cd6decdb744b29d7c940a1ca741 0.0s done
#24 exporting manifest list sha256:b1b03d6294f945afa76691e4d3ab73a8313ab5e4daad8bb6c46be1e98c7202e3 done
#24 naming to docker.io/library/refashion-app-app:latest done
#24 unpacking to docker.io/library/refashion-app-app:latest
#24 unpacking to docker.io/library/refashion-app-app:latest 1.4s done
#24 DONE 6.6s

#25 [app] resolving provenance for metadata file
#25 DONE 0.0s
 app  Built
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="cors.json">
[
    {
      "origin": ["*"],
      "method": ["GET"],
      "maxAgeSeconds": 3600
    }
  ]
</file>

<file path="docker-compose.secure.yml">
services:
  refashion-app:
    image: jay2323/refashion:latest
    container_name: refashion-app
    restart: unless-stopped
    ports:
      - "3000:3000"    
    volumes:
      - /mnt/user/appdata/refashion-app/uploads:/app/public/uploads
    environment:
      # Override only deployment-specific variables
      - NODE_ENV=production
      - HOST=192.168.1.9
      - PORT=3000
      
    networks:
      - marxnet

networks:
  marxnet:
    driver: bridge
</file>

<file path="docker-compose.yml">
services:
  app:
    image: refashion-app-app # Add this line
    build:
      context: .
      dockerfile: Dockerfile
      args:
        NEXT_PUBLIC_FAL_KEY: ${NEXT_PUBLIC_FAL_KEY}
        ENCRYPTION_SECRET: ${ENCRYPTION_SECRET}
    ports:
      - "3000:3000" # Map host port 3000 to container port 3000
    volumes:
      - ./public/uploads:/app/public/uploads # Persist uploads on the host machine
      - ./user_data:/app/user_data 
      # For development, you might want to mount your source code
      # - .:/app 
      # - /app/node_modules # Exclude node_modules from host mount
      # - /app/.next # Exclude .next from host mount
    env_file:
      - .env # Load environment variables from .env file
    environment:
      - NODE_ENV=production # Or 'production' if you want to test production build behavior
      - PORT=3000
      - NEXT_PUBLIC_APP_URL=https://app.refashion.cc
      - FORCE_HTTPS=false # Set to true if using HTTPS
      # STORAGE_PROVIDER will be picked from .env file
    # If you need to ensure Genkit dev server runs, you might need a more complex setup
    # or run it separately. This setup focuses on running the Next.js app.
</file>

<file path="Dockerfile">
# Use an official Node.js runtime as a parent image
FROM node:20-alpine AS base

# 1. ---- Dependencies Stage ----
# Only re-run when package.json or package-lock.json changes
FROM base AS deps
WORKDIR /app
RUN apk add --no-cache libc6-compat
COPY package.json package-lock.json* ./
RUN npm ci

# 2. ---- Production Dependencies Stage ----
# Create a separate stage for production-only node_modules
FROM base AS prod-deps
WORKDIR /app
COPY package.json package-lock.json* ./
RUN npm ci --only=production && npm cache clean --force

# 3. ---- Builder Stage ----
# This stage builds the Next.js application
FROM base AS builder
WORKDIR /app

# Accept build-time arguments for Next.js public environment variables
ARG NEXT_PUBLIC_FAL_KEY
ENV NEXT_PUBLIC_FAL_KEY=$NEXT_PUBLIC_FAL_KEY

# Accept build-time argument for ENCRYPTION_SECRET
ARG ENCRYPTION_SECRET
ENV ENCRYPTION_SECRET=$ENCRYPTION_SECRET

# Copy dependencies from the 'deps' stage
COPY --from=deps /app/node_modules ./node_modules
# Copy package.json for npm scripts
COPY package.json ./
# Copy configuration files
COPY next.config.ts postcss.config.* tailwind.config.ts tsconfig.json tsconfig.scripts.json ./
COPY components.json ./
# Copy the source code
COPY src ./src
COPY public ./public
COPY scripts ./scripts

# Set NEXT_TELEMETRY_DISABLED before build
ENV NEXT_TELEMETRY_DISABLED=1

RUN npm run build

# 4. ---- Runner Stage (Final Image) ----
# This stage creates the final, lean production image
FROM base AS runner
WORKDIR /app

ENV NODE_ENV=production
ENV NEXT_TELEMETRY_DISABLED=1
ENV HOSTNAME="0.0.0.0"
ENV PORT=3000

RUN apk add --no-cache su-exec

# Copy production dependencies from the 'prod-deps' stage
COPY --from=prod-deps /app/node_modules ./node_modules

# Copy the built application from the 'builder' stage
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static/

# Copy package.json to be able to run npm scripts
COPY --from=builder /app/package.json ./package.json
# Copy the compiled migration scripts and its dependencies
COPY --from=builder /app/dist/scripts ./dist/scripts
COPY --from=builder /app/dist/src ./dist/src

# Create directories for volumes. Ownership will be set by entrypoint.sh
RUN mkdir -p /app/user_data/history && \
    mkdir -p /app/public/uploads/user_uploaded_clothing && \
    mkdir -p /app/public/uploads/generated_images && \
    mkdir -p /app/public/uploads/generated_videos && \
    chmod -R 755 /app/user_data /app/public/uploads

# Copy and set up the entrypoint script
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh && \
    sed -i 's/\r$//' /entrypoint.sh

EXPOSE 3000

ENTRYPOINT ["/entrypoint.sh"]
CMD ["node", "server.js"]
</file>

<file path="docs/api_v1.md">
# RefashionAI API v1 Documentation

## Overview

The RefashionAI API v1 provides a RESTful, asynchronous interface for image generation tasks. The API follows a job-based pattern where clients submit generation requests and poll for completion status.

### Base URL
```
https://your-domain.com/api/v1
```

### API Pattern
1. **Submit Job**: POST to `/generate` → Receive `jobId` immediately
2. **Poll Status**: GET `/status/{jobId}` → Check completion status
3. **Retrieve Results**: Results are provided in the status response when complete

---

## Authentication

All API requests require authentication via API keys.

### Getting an API Key
API keys must be generated by an administrator through the RefashionAI admin interface:
1. Admin logs into RefashionAI
2. Navigates to Admin → Users
3. Edits the target user
4. Clicks "Generate New API Key"
5. Copies the generated key (shown only once)

### Using the API Key
Include the API key in the `Authorization` header of all requests:

```http
Authorization: Bearer rf_your_api_key_here
```

---

## Endpoints

### POST /api/v1/generate

Submits a new image generation job.

#### Request

**Method:** `POST`  
**Content-Type:** `application/json`  
**Headers:**
```http
Authorization: Bearer rf_your_api_key_here
Content-Type: application/json
```

**Body:**
```json
{
  "imageDataUri": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQ...",
  "parameters": {
    "gender": "female",
    "bodyType": "athletic",
    "bodySize": "medium",
    "ageRange": "25-35",
    "ethnicity": "caucasian",
    "poseStyle": "standing",
    "background": "studio",
    "fashionStyle": "casual",
    "hairStyle": "long",
    "modelExpression": "neutral",
    "lightingType": "natural",
    "lightQuality": "soft",
    "cameraAngle": "front",
    "lensEffect": "standard",
    "depthOfField": "normal",
    "timeOfDay": "day",
    "overallMood": "bright",
    "fabricRendering": "realistic"
  },
  "settingsMode": "basic"
}
```

**Parameter Descriptions:**
- `imageDataUri`: Base64-encoded image data URI of the clothing item
- `parameters`: Model generation parameters (all fields required)
- `settingsMode`: Either "basic" or "advanced" (optional, defaults to "basic")

#### Response

**Success (202 Accepted):**
```json
{
  "jobId": "uuid-string",
  "status": "processing"
}
```

**Error (400 Bad Request):**
```json
{
  "error": "Invalid request data",
  "details": [
    {
      "code": "invalid_type",
      "expected": "string",
      "received": "undefined",
      "path": ["imageDataUri"],
      "message": "Image data URI is required"
    }
  ]
}
```

**Error (401 Unauthorized):**
```json
{
  "error": "Unauthorized"
}
```

**Error (500 Internal Server Error):**
```json
{
  "error": "Internal server error"
}
```

---

### GET /api/v1/status/{jobId}

Polls the status of a generation job.

#### Request

**Method:** `GET`  
**Headers:**
```http
Authorization: Bearer rf_your_api_key_here
```

**Path Parameters:**
- `jobId`: The job ID returned from the generate endpoint

#### Response

**Processing (200 OK):**
```json
{
  "jobId": "uuid-string",
  "status": "processing"
}
```

**Completed (200 OK):**
```json
{
  "jobId": "uuid-string",
  "status": "completed",
  "generatedImageUrls": [
    "https://your-domain.com/uploads/generated_images/image1.jpg",
    "https://your-domain.com/uploads/generated_images/image2.jpg",
    "https://your-domain.com/uploads/generated_images/image3.jpg"
  ]
}
```

**Failed (200 OK):**
```json
{
  "jobId": "uuid-string",
  "status": "failed",
  "error": "Error message describing what went wrong"
}
```

**Job Not Found (404 Not Found):**
```json
{
  "error": "Job not found"
}
```

**Unauthorized (401 Unauthorized):**
```json
{
  "error": "Unauthorized"
}
```

---

## CORS Support

The API supports Cross-Origin Resource Sharing (CORS) for the following domains:
- `https://marcodirenzo.ch`
- `https://demo.marcodirenzo.ch`

If you need additional domains whitelisted, contact the system administrator.

---

## Rate Limiting

Currently, there are no specific rate limits implemented. However, the asynchronous nature of the API naturally throttles requests since each job must complete before new results are available.

---

## Error Handling

### HTTP Status Codes
- `202 Accepted`: Job submitted successfully
- `200 OK`: Status retrieved successfully
- `400 Bad Request`: Invalid request data or format
- `401 Unauthorized`: Invalid or missing API key
- `404 Not Found`: Job not found or not accessible
- `500 Internal Server Error`: Server-side error occurred

### Error Response Format
All error responses follow this format:
```json
{
  "error": "Human-readable error message",
  "details": "Optional additional error details"
}
```

---

## Example Usage

### Complete Workflow Example

1. **Submit a generation job:**
```bash
curl -X POST https://your-domain.com/api/v1/generate \
  -H "Authorization: Bearer rf_your_api_key_here" \
  -H "Content-Type: application/json" \
  -d '{
    "imageDataUri": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQ...",
    "parameters": {
      "gender": "female",
      "bodyType": "athletic",
      "bodySize": "medium",
      "ageRange": "25-35",
      "ethnicity": "caucasian",
      "poseStyle": "standing",
      "background": "studio",
      "fashionStyle": "casual",
      "hairStyle": "long",
      "modelExpression": "neutral",
      "lightingType": "natural",
      "lightQuality": "soft",
      "cameraAngle": "front",
      "lensEffect": "standard",
      "depthOfField": "normal",
      "timeOfDay": "day",
      "overallMood": "bright",
      "fabricRendering": "realistic"
    },
    "settingsMode": "basic"
  }'
```

2. **Poll for status (repeat until status is not "processing"):**
```bash
curl -X GET https://your-domain.com/api/v1/status/your-job-id-here \
  -H "Authorization: Bearer rf_your_api_key_here"
```

3. **Retrieve results from the completed status response**

### WordPress Plugin Integration

For WordPress plugin developers:

```php
// Submit generation job
$response = wp_remote_post('https://your-domain.com/api/v1/generate', [
    'headers' => [
        'Authorization' => 'Bearer ' . $api_key,
        'Content-Type' => 'application/json',
    ],
    'body' => json_encode($job_data),
    'timeout' => 30,
]);

$job = json_decode(wp_remote_retrieve_body($response), true);
$job_id = $job['jobId'];

// Poll for completion
do {
    sleep(5); // Wait 5 seconds between polls
    
    $status_response = wp_remote_get(
        'https://your-domain.com/api/v1/status/' . $job_id,
        [
            'headers' => [
                'Authorization' => 'Bearer ' . $api_key,
            ],
            'timeout' => 15,
        ]
    );
    
    $status = json_decode(wp_remote_retrieve_body($status_response), true);
    
} while ($status['status'] === 'processing');

// Handle results
if ($status['status'] === 'completed') {
    $image_urls = $status['generatedImageUrls'];
    // Process the generated images
} else if ($status['status'] === 'failed') {
    $error = $status['error'];
    // Handle the error
}
```

---

## Support

For technical support or to request additional API features, please contact the system administrator.

**API Version:** 1.0  
**Last Updated:** July 8, 2025
</file>

<file path="docs/authentication.md">
# Database-Backed Authentication System

This application uses a secure, database-backed authentication system built with:

- `iron-session` for encrypted session cookies
- `bcrypt` for industry-standard password hashing
- A local SQLite database for user storage

## Configuration

Your session secret must be set in your `.env` file:

```env
# Local Authentication
SESSION_SECRET="your-very-strong-secret-password-for-cookies-at-least-32-characters-long"
```

## User Management

Users are now stored in the application's SQLite database (`user_data/history/history.db`).

### First-Time Setup & Migration

If you were using the old `APP_USERS_CONFIG` environment variable, the application will automatically perform a **one-time migration** on its next startup.

1. It will read the users from `APP_USERS_CONFIG`.
2. It will securely hash their passwords using `bcrypt`.
3. It will store the username, hashed password, and role in the SQLite database.
4. Once the migration is complete, you can and **should** remove the `APP_USERS_CONFIG` variable from your environment for security.

### Adding/Managing Users (Post-Migration)

Currently, user management must be done by directly interacting with the SQLite database. You can use a tool like `DB Browser for SQLite` to open the `history.db` file and add or edit users in the `users` table.

**Important**: When adding a new user, you must provide a `bcrypt` hash for the password, not a plaintext password. You can use an online bcrypt generator or a simple script to create one.

## Security Notes

- The `SESSION_SECRET` should be a strong, random string (at least 32 characters)
- In production, always use HTTPS for secure cookie transmission
- **Password Security**: Passwords are now securely hashed in the database. The original plaintext passwords are no longer stored anywhere after migration.
- Sessions automatically expire after 7 days

To change the password, simply update the `LOCAL_ADMIN_PASSWORD` value in your `.env` file and restart the development server.
</file>

<file path="docs/blueprint.md">
# **App Name**: Refashion AI

## Core Features:

- Input Capture: Accept user prompts and images via a simple form.
- Image Edit: Call the Google Gemini API to edit the image based on the prompt, using the gemini-2.0-flash-preview-image-generation model.
- Image Output: Display the generated image and allow users to download it.
- History: Provide an option to save a history of generated images (locally in browser storage).

## Style Guidelines:

- Primary color: Saturated blue (#4681C3) to convey trust and technological prowess.
- Background color: Light, desaturated blue (#E0E8EF).
- Accent color: Complementary vibrant purple (#7048B5) for interactive elements and highlights, drawing attention without overwhelming the user.
- Clean, sans-serif font for clear readability.
- Simple, outlined icons to maintain a minimalist aesthetic.
- A clean, single-column layout optimized for mobile and desktop.
</file>

<file path="docs/IntegrationsManual.md">
# Integrating Visionatrix: Getting Started

This guide will help you get started with programmatically interacting with Visionatrix.

!!! note

    **SDXL Lighting** and **Remove Background (Birefnet)** flows should be installed on the Visionatrix instance.

    This guide only covers how to create tasks from a flow, fetch their progress, and receive the results.

!!! info

    We constantly strive to make our API more comfortable to use with code generated by Claude, Qwen, or ChatGPT.

    However, this guide is primarily focused on understanding the lifespan of a task. It does not describe how to automatically create a Gradio application for the specified flow or any other such topics.

---

## Table of Contents

1. [Authentication](#authentication)
2. [Task Lifecycle](#task-lifecycle)
3. [Full Working Examples in Python](#full-working-examples-in-python)
    - [Example 1: Using the "SDXL Lighting" Flow](#example-1-using-the-sdxl-lighting-flow)
    - [Example 2: Using the "Remove Background (Birefnet)" Flow](#example-2-using-the-remove-background-birefnet-flow)

## Authentication

Visionatrix *currently* supports **Basic Authentication** only. Depending on the mode in which Visionatrix is running, you may or may not need to provide authentication credentials:

- **SERVER Mode**: If Visionatrix is running in SERVER mode, you **must** specify your username and password in your API requests.
- **DEFAULT Mode**: If Visionatrix is running in DEFAULT mode, **no authentication** is required.

For the purposes of this guide, we will assume that authentication is required.

By default, we use `admin` as both the username and password in our development setups for **SERVER mode** when testing Visionatrix. Replace these with your actual credentials if they are different.

## Task Lifecycle

The typical lifecycle of a task in Visionatrix involves the following steps:

1. **Creating a Task**: You send a `PUT` request to the `/vapi/tasks/create/{name}` endpoint, where `{name}` is the ID of the flow you want to use. The request must use `multipart/form-data` and include the necessary parameters for the flow.

   - For the **SDXL Lighting** (`sdxl_lighting`) flow, required parameters are:
     - `prompt` (string): The text prompt for image generation.
     - `steps_number` (string): The number of steps to use.
   - **Optional Parameters**:
     - `negative_prompt` (string): The "negative" text prompt for image generation.
     - `seed` (integer): The seed for random number generation. If not specified, a random seed will be used.

   - For the **Remove Background (Birefnet)** (`remove_background_birefnet`) flow, required parameters are:
     - `input_image` (file): The image file from which to remove the background.

   - **Other Parameters**:
     - There are additional optional parameters such as `webhook_url`, `webhook_headers`, `translate`, `group_scope`, etc. These parameters are not covered in this beginner guide.

2. **Checking Task Progress**: After creating a task, you can check its progress using the `/vapi/tasks/progress/{task_id}` endpoint. The response includes details such as the task's `progress`, `error` (if any), and a list of `outputs`.

   - **Progress Values**:
     - `0.0`: Task is queued and has not started yet.
     - Between `0.1` and `99.9`: Task is in progress.
     - `100.0`: Task is completed.

   - **Error Handling**:
     - If the `error` field is not empty, the task has encountered an error.
     - You can retry the task or investigate the issue based on the error message.

3. **Retrieving Task Results**: Once a task is completed (`progress` reaches `100.0`), you can retrieve the results using the `/vapi/tasks/results` endpoint. The `outputs` from the task details contain a list of output nodes, each with a `comfy_node_id`. You should iterate over all the outputs to retrieve all results.

   - To retrieve each result, you send a `GET` request to `/vapi/tasks/results` with the `task_id` and `node_id` (which is the `comfy_node_id` from the outputs).
   - The result files can then be saved locally. The format of the result file depends on the flow and the output node's type.

!!! note

    We are currently in the process of automatically creating OpenAPI specifications for the flows: [Flows API](https://visionatrix.github.io/VixFlowsDocs/swagger.html?urls.primaryName=Visionatrix+Flows+API).

    You can easily take a look at the flow parameters there.

## Full Working Examples in Python

Below are full working examples in Python using the `httpx` library. These scripts demonstrate how to create a task, check its progress, and retrieve all the results for both the `sdxl_lighting` and `remove_background_birefnet` flows.

Before running the scripts, make sure you have the `httpx` library installed:

```bash
pip install httpx
```

### Example 1: Using the "SDXL Lighting" Flow

```python
import httpx
import time

# Replace with your Visionatrix server URL
base_url = "http://localhost:8288"
username = "admin"
password = "admin"


def create_sdxl_lighting_task():
    # Task parameters
    params = {
        'prompt': 'A beautiful sunset over the mountains',
        'steps_number': '8 steps',
        # 'negative_prompt' is optional
        # 'negative_prompt': 'blurry, low resolution',
        # 'seed' is optional; if not specified, a random seed will be used
        # 'seed': '12345',
    }

    # Convert parameters to the format expected by the 'files' parameter
    files = {key: (None, value) for key, value in params.items()}

    # Create the task
    response = httpx.put(
        f"{base_url}/vapi/tasks/create/sdxl_lighting",
        auth=(username, password),
        files=files
    )

    # Check if the request was successful
    if response.status_code == 200:
        data = response.json()
        task_ids = data.get('tasks_ids', [])
        if task_ids:
            task_id = task_ids[0]
            print("Task created successfully. Task ID:", task_id)
            return task_id
        else:
            print("No task ID returned.")
    else:
        print("Failed to create task:", response.text)
    return None


def check_task_progress(task_id):
    while True:
        response = httpx.get(
            f"{base_url}/vapi/tasks/progress/{task_id}",
            auth=(username, password)
        )

        if response.status_code == 200:
            task_details = response.json()
            progress = task_details.get('progress', 0)
            error = task_details.get('error', '')
            print(f"Task {task_id} progress: {progress}%")
            if error:
                print(f"Task {task_id} encountered an error: {error}")
                return None
            if progress >= 100:
                print("Task completed.")
                outputs = task_details.get('outputs', [])
                return outputs  # Return outputs to avoid additional server call
        else:
            print("Failed to get task progress:", response.text)
            return None

        # Wait before polling again
        time.sleep(5)


def retrieve_task_results(task_id, outputs):
    if outputs:
        for output in outputs:
            node_id = output.get('comfy_node_id')
            if node_id is not None:
                # Retrieve the result for each output node
                params = {
                    'task_id': task_id,
                    'node_id': node_id
                }
                result_response = httpx.get(
                    f"{base_url}/vapi/tasks/results",
                    auth=(username, password),
                    params=params
                )
                if result_response.status_code == 200:
                    # Save the result to a file
                    result_filename = f"result_{task_id}_{node_id}.png"
                    with open(result_filename, 'wb') as f:
                        f.write(result_response.content)
                    print(f"Result saved to {result_filename}")
                else:
                    print(f"Failed to retrieve result for node {node_id}:", result_response.text)
            else:
                print("Output node ID not found.")
    else:
        print("No outputs found in task details.")


def main():
    task_id = create_sdxl_lighting_task()
    if task_id:
        outputs = check_task_progress(task_id)
        if outputs is not None:
            retrieve_task_results(task_id, outputs)


if __name__ == "__main__":
    main()
```

### Example 2: Using the "Remove Background (Birefnet)" Flow

```python
import httpx
import time

# Replace with your Visionatrix server URL
base_url = "http://localhost:8288"
username = "admin"
password = "admin"
input_image_path = "image.jpg"


def create_remove_background_task():
    # Open the image file in binary mode
    with open(input_image_path, 'rb') as image_file:
        files = {
            'input_image': image_file
        }

        # Create the task
        response = httpx.put(
            f"{base_url}/vapi/tasks/create/remove_background_birefnet",
            auth=(username, password),
            files=files
        )

    # Check if the request was successful
    if response.status_code == 200:
        data = response.json()
        task_ids = data.get('tasks_ids', [])
        if task_ids:
            task_id = task_ids[0]
            print("Task created successfully. Task ID:", task_id)
            return task_id
        else:
            print("No task ID returned.")
    else:
        print("Failed to create task:", response.text)
    return None


def check_task_progress(task_id):
    while True:
        response = httpx.get(
            f"{base_url}/vapi/tasks/progress/{task_id}",
            auth=(username, password)
        )

        if response.status_code == 200:
            task_details = response.json()
            progress = task_details.get('progress', 0)
            error = task_details.get('error', '')
            print(f"Task {task_id} progress: {progress}%")
            if error:
                print(f"Task {task_id} encountered an error: {error}")
                return None
            if progress >= 100:
                print("Task completed.")
                outputs = task_details.get('outputs', [])
                return outputs  # Return outputs to avoid additional server call
        else:
            print("Failed to get task progress:", response.text)
            return None

        # Wait before polling again
        time.sleep(5)


def retrieve_task_results(task_id, outputs):
    if outputs:
        for output in outputs:
            node_id = output.get('comfy_node_id')
            if node_id is not None:
                # Retrieve the result for each output node
                params = {
                    'task_id': task_id,
                    'node_id': node_id
                }
                result_response = httpx.get(
                    f"{base_url}/vapi/tasks/results",
                    auth=(username, password),
                    params=params
                )
                if result_response.status_code == 200:
                    # Save the result to a file
                    result_filename = f"result_{task_id}_{node_id}.png"
                    with open(result_filename, 'wb') as f:
                        f.write(result_response.content)
                    print(f"Result saved to {result_filename}")
                else:
                    print(f"Failed to retrieve result for node {node_id}:", result_response.text)
            else:
                print("Output node ID not found.")
    else:
        print("No outputs found in task details.")


def main():
    task_id = create_remove_background_task()
    if task_id:
        outputs = check_task_progress(task_id)
        if outputs is not None:
            retrieve_task_results(task_id, outputs)


if __name__ == "__main__":
    main()
```

---

**Notes**:

- Replace `base_url` with your actual Visionatrix server URL if it's different.
- For the second example, replace `input_image_path` with the path to your input image file. Ensure that the file exists at the specified path.
- When creating a task, the API expects a `PUT` request with `multipart/form-data`. Therefore, even if you are not uploading any files (as in the `sdxl_lighting` flow), you should use `files=params` to ensure the request uses the correct content type.
- These scripts include basic error handling and polling logic.
- The `check_task_progress` function polls the task progress every 5 seconds. Adjust the sleep time as needed.
- The `retrieve_task_results` function uses the `outputs` obtained from the `check_task_progress` function, avoiding an additional call to the server.
- The result files are saved in the current working directory with filenames that include the task ID and node ID.
- Ensure that the required flows (`sdxl_lighting` and `remove_background_birefnet`) are installed on your Visionatrix instance before running these scripts.
- Additional optional parameters like `webhook_url`, `translate`, `group_scope`, `seed`, etc., are available but are not covered in this beginner guide.

---

## RefashionAI Integration

RefashionAI has implemented the Visionatrix background removal feature as an optional enhancement to the clothing image upload workflow. Here's how it works:

### Implementation Details

The background removal feature is implemented in the RefashionAI application with the following components:

#### Server-Side Services
- **`src/ai/services/visionatrix-api.ts`**: Core API service for Visionatrix integration
- **`src/ai/actions/remove-background.ts`**: Server action that handles background removal workflow

#### Client-Side Integration
- **Background Removal Toggle**: Available in the upload section when Visionatrix is accessible
- **Progress Tracking**: Real-time progress updates during background removal
- **Automatic Fallback**: Falls back to original image if background removal fails

### Configuration

Set these environment variables to enable background removal:

```env
VISIONATRIX_API_URL=http://localhost:8288  # Your Visionatrix server URL
VISIONATRIX_USERNAME=admin                 # Default: admin
VISIONATRIX_PASSWORD=admin                 # Default: admin
```

### User Experience

1. **Upload Flow**: User uploads a clothing image
2. **Option Available**: If Visionatrix is available, a "Remove Background" toggle appears
3. **Processing**: When enabled, background removal processes automatically during upload
4. **Progress**: Users see real-time progress updates
5. **Fallback**: If background removal fails, the original image is used seamlessly

### Technical Implementation

The integration uses the `remove_background_birefnet` flow with the following workflow:

1. **Availability Check**: On app startup, checks if Visionatrix is accessible
2. **Task Creation**: Creates background removal task with uploaded image
3. **Progress Polling**: Polls every 5 seconds with 5-minute timeout
4. **Result Processing**: Downloads and saves the processed image locally
5. **Integration**: Processed image is used in the AI generation workflow

### Error Handling

- **Service Unavailable**: Toggle is hidden, feature gracefully disabled
- **Processing Failure**: Falls back to original image with user notification
- **Network Issues**: Automatic retry with exponential backoff
- **Timeout**: Falls back after 5-minute timeout

This implementation ensures that background removal enhances the user experience when available, while maintaining full functionality even when the service is unavailable.
</file>

<file path="docs/openapi.json">
{
  "openapi": "3.1.0",
  "info": {
    "title": "visionatrix",
    "version": "2.5.0.dev0"
  },
  "paths": {
    "/comfy/": {
      "get": {
        "summary": "Custom Index",
        "description": "Original ComfyUI user interface",
        "operationId": "custom_index",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/vapi/flows/installed": {
      "get": {
        "tags": [
          "flows"
        ],
        "summary": "Get Installed",
        "description": "Return the list of installed flows. Each flow can potentially be converted into a task. The response\nincludes details such as the name, display name, description, author, homepage URL, and other relevant\ninformation about each flow.",
        "operationId": "get_installed",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/Flow"
                  },
                  "type": "array",
                  "title": "Response Get Installed"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/flows/not-installed": {
      "get": {
        "tags": [
          "flows"
        ],
        "summary": "Get Not Installed",
        "description": "Return the list of flows that can be installed. This endpoint provides detailed information about each flow,\nsimilar to the installed flows, which includes metadata and configuration parameters.",
        "operationId": "get_not_installed",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/Flow"
                  },
                  "type": "array",
                  "title": "Response Get Not Installed"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/flows/subflows": {
      "get": {
        "tags": [
          "flows"
        ],
        "summary": "Get Subflows",
        "description": "Retrieves a list of flows designed to post-process the results from other flows, filtering by the type\nof input they handle, either 'image', 'image-inpaint' or 'video'. This endpoint is particularly useful for chaining\nworkflows where the output of one flow becomes the input to another.\nIt modifies the main flow's structure by adopting sub-flow's display name and selectively merging input parameters\nfrom the sub-flows into the main flow's parameters based on matching names.",
        "operationId": "get_subflows",
        "parameters": [
          {
            "name": "input_type",
            "in": "query",
            "required": true,
            "schema": {
              "enum": [
                "image",
                "image-inpaint",
                "video"
              ],
              "type": "string",
              "title": "Input Type"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Flow"
                  },
                  "title": "Response Get Subflows"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/flows/flow-details": {
      "get": {
        "tags": [
          "flows"
        ],
        "summary": "Get Flow Details",
        "description": "Retrieves the Flow model and its associated flow_comfy dictionary.\nThis endpoint is restricted to admin users.",
        "operationId": "get_flow_details",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the flow to retrieve details for.",
              "title": "Name"
            },
            "description": "Name of the flow to retrieve details for."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/flows/flow": {
      "post": {
        "tags": [
          "flows"
        ],
        "summary": "Install",
        "description": "Initiates the installation of a flow based on its name. Requires admin privileges.\n\nIf the specified flow is already being installed, a `409 Conflict` status is returned. However,\nthe installation of other flows is allowed concurrently.",
        "operationId": "install",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the flow you wish to install",
              "title": "Name"
            },
            "description": "Name of the flow you wish to install"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful start of installation"
          },
          "404": {
            "description": "Flow not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Can't find `flow_name` flow."
                }
              }
            }
          },
          "409": {
            "description": "Installation of the same flow is already in progress",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Installation of this flow is already in progress."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "flows"
        ],
        "summary": "Install From File",
        "description": "Initiates the installation of a flow from an uploaded file. Requires admin privileges.\n\nIf the specified flow is already being installed, a `409 Conflict` status is returned. However,\nthe installation of other flows is allowed concurrently.",
        "operationId": "install_from_file",
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/Body_install_from_file"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Successful start of installation"
          },
          "409": {
            "description": "Installation of the same flow is already in progress",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Installation of this flow is already in progress."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "flows"
        ],
        "summary": "Delete",
        "description": "Endpoint to delete an installed flow by its name. Requires administrative privileges to execute.\nThis endpoint will succeed even if the flow does not exist.",
        "operationId": "delete",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the flow you wish to delete",
              "title": "Name"
            },
            "description": "Name of the flow you wish to delete"
          }
        ],
        "responses": {
          "204": {
            "description": "Flow deleted successfully"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/flows/flow-update": {
      "post": {
        "tags": [
          "flows"
        ],
        "summary": "Flow Update",
        "description": "Initiates the update process for an installed flow. Requires admin privileges.\n\nIf the specified flow is already being installed or updated, a `409 Conflict` status is returned.\nHowever, updates or installations of other flows are allowed concurrently.",
        "operationId": "flow_update",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the flow you wish to update",
              "title": "Name"
            },
            "description": "Name of the flow you wish to update"
          }
        ],
        "responses": {
          "204": {
            "description": "Successful start of update process"
          },
          "404": {
            "description": "Flow not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Can't find `flow_name` flow."
                }
              }
            }
          },
          "409": {
            "description": "Update or installation of the same flow is already in progress",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Installation of this flow is already in progress."
                }
              }
            }
          },
          "412": {
            "description": "Flow does not have a newer version",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Flow `flow_name` does not have a newer version."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/flows/install-progress": {
      "get": {
        "tags": [
          "flows"
        ],
        "summary": "Get Install Progress",
        "description": "Retrieves the current installation progress of all flows.\n\nRequires administrative privileges.",
        "operationId": "get_install_progress",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/FlowProgressInstall"
                  },
                  "title": "Response Get Install Progress"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "flows"
        ],
        "summary": "Delete Install Progress",
        "description": "Deletes the installation progress entry for a specified flow.\n\nRequires administrative privileges.",
        "operationId": "delete_install_progress",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the flow progress you wish to delete",
              "title": "Name"
            },
            "description": "Name of the flow progress you wish to delete"
          }
        ],
        "responses": {
          "204": {
            "description": "Flow progress installation entry deleted successfully"
          },
          "404": {
            "description": "Flow progress installation entry not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Can't find `flow_name`."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/flows/clone-flow": {
      "post": {
        "tags": [
          "flows"
        ],
        "summary": "Clone Flow",
        "description": "Clones an existing flow with updated metadata or LoRA connection points.\nRequires admin privileges.",
        "operationId": "clone_flow",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FlowCloneRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Flow cloned successfully."
          },
          "404": {
            "description": "Original flow not found."
          },
          "400": {
            "description": "Error occurred while cloning the flow."
          },
          "409": {
            "description": "Installation of the same flow is already in progress",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Installation of this flow is already in progress."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/flows/flow-metadata": {
      "put": {
        "tags": [
          "flows"
        ],
        "summary": "Edit Flow Metadata",
        "operationId": "edit_flow_metadata",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the flow to update metadata for.",
              "title": "Name"
            },
            "description": "Name of the flow to update metadata for."
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FlowMetadataUpdate",
                "description": "New metadata values for the flow."
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Flow metadata updated successfully."
          },
          "400": {
            "description": "Invalid metadata provided",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Flow metadata node not found."
                }
              }
            }
          },
          "500": {
            "description": "Error during editing the flow",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Editing flow failed."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/models/orphan": {
      "get": {
        "tags": [
          "models"
        ],
        "summary": "Get Orphan Models",
        "description": "Retrieves a list of orphaned AI model files not associated with any installed flow.\n\nOrphaned models are files found in ComfyUI's model directories that are not required\nby installed flows. This endpoint provides metadata for each orphaned model,\nincluding file path, size, and potential usage in flows.\n\nAccess to this endpoint is restricted to administrators.",
        "operationId": "get_orphan_models",
        "responses": {
          "200": {
            "description": "List of orphaned models retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/OrphanModel"
                  },
                  "title": "Response Get Orphan Models"
                },
                "example": [
                  {
                    "path": "models/example_model.ckpt",
                    "full_path": "/absolute/path/to/models/example_model.ckpt",
                    "size": 512.3,
                    "creation_time": 1695724800.0,
                    "possible_flows": []
                  }
                ]
              }
            }
          },
          "400": {
            "description": "Ongoing installation prevents orphan model detection.",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Cannot run orphan models detection during ongoing installations."
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "models"
        ],
        "summary": "Delete Orphan Model",
        "description": "Deletes a specified orphaned model file.\n\nThis endpoint removes an orphaned model if:\n- There are no ongoing model or flow installations.\n- The specified `full_path` and `file_creation_time` correspond to an orphaned model.\n\nAccess to this endpoint is restricted to administrators.",
        "operationId": "delete_orphan_model",
        "parameters": [
          {
            "name": "full_orphan_path",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Full Orphan Path"
            }
          },
          {
            "name": "file_creation_time",
            "in": "query",
            "required": true,
            "schema": {
              "type": "number",
              "title": "File Creation Time"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Orphaned model successfully deleted."
          },
          "400": {
            "description": "Invalid input or ongoing installations prevent deletion.",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Cannot delete orphan models during ongoing installations."
                }
              }
            }
          },
          "404": {
            "description": "File not found at the specified path.",
            "content": {
              "application/json": {
                "example": {
                  "detail": "File not found at path: /absolute/path/to/models/example_model.ckpt"
                }
              }
            }
          },
          "500": {
            "description": "Internal server error during deletion.",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Failed to delete orphan model: Unknown error occurred."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/other/interrupt-engine": {
      "post": {
        "tags": [
          "other"
        ],
        "summary": "Interrupt Engine",
        "description": "Interrupts the currently executing task. This is primarily an internal function and should be used\ncautiously. For standard task management, prefer using the `task_queue_clear` or `tasks_queue_clear`\nendpoints. Requires administrative privileges to execute.",
        "operationId": "interrupt_engine",
        "responses": {
          "204": {
            "description": "Engine interrupt initiated successfully"
          },
          "401": {
            "description": "Unauthorized - Admin privilege required",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Admin privilege required"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/other/shutdown-server": {
      "post": {
        "tags": [
          "other"
        ],
        "summary": "Shutdown Server",
        "description": "Shuts down the current instance of Vix. This endpoint queues a task to terminate the server process\nafter a short delay, ensuring any final operations can complete. Access is restricted to administrators only.",
        "operationId": "shutdown_server",
        "responses": {
          "204": {
            "description": "Server shutdown initiated successfully"
          },
          "401": {
            "description": "Unauthorized - Admin privilege required",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Admin privilege required"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/other/whoami": {
      "get": {
        "tags": [
          "other"
        ],
        "summary": "Whoami",
        "description": "Returns information about the currently authenticated user.",
        "operationId": "whoami",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserInfo"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/other/translate-prompt": {
      "post": {
        "tags": [
          "other"
        ],
        "summary": "Translate Prompt",
        "description": "Translates an image generation prompt from another language into English.\n\nThis endpoint accepts a prompt in any language and translates it into English.\nIt returns the original prompt, the translated result, and the reason the generation was completed.\n\nAccessible to all authenticated users.\n\nRaises:\n    HTTPException: If there is an error during the translation process.",
        "operationId": "translate_prompt",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TranslatePromptRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Translation successful",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TranslatePromptResponse"
                },
                "example": {
                  "prompt": "Dornr\u00f6schen",
                  "result": "Sleeping Beauty",
                  "done_reason": "stop"
                }
              }
            }
          },
          "500": {
            "description": "Translation service error",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Translation service error"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/other/update-status": {
      "get": {
        "tags": [
          "other",
          "other"
        ],
        "summary": "Update Status",
        "description": "Access is restricted to administrators only.",
        "operationId": "update_status",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/VisionatrixUpdateStatus"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/settings/get": {
      "get": {
        "tags": [
          "settings"
        ],
        "summary": "Get",
        "description": "Returns the value as a string or an empty string if the setting is not found.\n\nDefault endpoint for retrieving settings.\nUser settings have higher priority than global settings.",
        "operationId": "get",
        "parameters": [
          {
            "name": "key",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The key of the setting to retrieve",
              "title": "Key"
            },
            "description": "The key of the setting to retrieve"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved setting",
            "content": {
              "text/plain": {
                "example": "value_of_setting"
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/settings/global": {
      "get": {
        "tags": [
          "settings"
        ],
        "summary": "Get Global",
        "description": "Retrieve the global setting value or an empty string if the global setting is not found.",
        "operationId": "get_global",
        "parameters": [
          {
            "name": "key",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The key of the global setting to retrieve",
              "title": "Key"
            },
            "description": "The key of the global setting to retrieve"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved global setting",
            "content": {
              "text/plain": {
                "example": "value_of_global_setting"
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "settings"
        ],
        "summary": "Set Global",
        "description": "Creates, updates, or deletes a global setting.\n\nTo delete a setting, specify an empty string as the value.\nAccess is restricted to administrators only.",
        "operationId": "set_global",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_set_global"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Global setting updated successfully"
          },
          "401": {
            "description": "Unauthorized - Admin privilege required",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Admin privilege required"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/settings/user": {
      "get": {
        "tags": [
          "settings"
        ],
        "summary": "Get User",
        "description": "Retrieve the user setting value or an empty string if the user setting is not found.",
        "operationId": "get_user",
        "parameters": [
          {
            "name": "key",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "The key of the user setting to retrieve",
              "title": "Key"
            },
            "description": "The key of the user setting to retrieve"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved user setting",
            "content": {
              "text/plain": {
                "example": "value_of_user_setting"
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "settings"
        ],
        "summary": "Set User",
        "description": "Creates, updates, or deletes a user setting.\n\nTo delete a setting, specify an empty string as the value.",
        "operationId": "set_user",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_set_user"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "User setting updated successfully"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/settings/get_all": {
      "get": {
        "tags": [
          "settings"
        ],
        "summary": "Get All",
        "description": "Returns all settings for the user.\nUser settings have higher priority than global settings.",
        "operationId": "get_all",
        "responses": {
          "200": {
            "description": "Successfully retrieved all settings for the user",
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object",
                  "title": "Response Get All"
                },
                "example": {
                  "setting_key": "value"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/settings/global_all": {
      "get": {
        "tags": [
          "settings"
        ],
        "summary": "Get Global All",
        "description": "Retrieve all global settings or an empty dictionary if none are found.",
        "operationId": "get_global_all",
        "responses": {
          "200": {
            "description": "Successfully retrieved all global settings",
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object",
                  "title": "Response Get Global All"
                },
                "example": {
                  "global_setting_key": "value"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/settings/user_all": {
      "get": {
        "tags": [
          "settings"
        ],
        "summary": "Get User All",
        "description": "Retrieve all user settings or an empty dictionary if none are found.",
        "operationId": "get_user_all",
        "responses": {
          "200": {
            "description": "Successfully retrieved all user settings",
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object",
                  "title": "Response Get User All"
                },
                "example": {
                  "user_setting_key": "value"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/settings/ollama/models": {
      "get": {
        "tags": [
          "settings"
        ],
        "summary": "Get Ollama Models",
        "description": "Fetches a list of models from the configured Ollama server (filename, size, modified).\nRequires admin privileges.",
        "operationId": "get_ollama_models",
        "responses": {
          "200": {
            "description": "Successfully retrieved list of models installed in Ollama",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/OllamaModelItem"
                  },
                  "type": "array",
                  "title": "Response Get Ollama Models"
                }
              }
            }
          },
          "401": {
            "description": "Unauthorized - Admin privilege required",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Admin privilege required"
                }
              }
            }
          },
          "404": {
            "description": "Invalid Ollama URL configured or error fetching models",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Invalid Ollama URL configured or error fetching models."
                }
              }
            }
          }
        }
      }
    },
    "/vapi/settings/comfyui/folders": {
      "get": {
        "tags": [
          "settings"
        ],
        "summary": "Comfyui Get Folders Paths",
        "description": "Retrieves all folder paths and their metadata from the ComfyUI folder settings.\n\nRequires administrative privileges.",
        "operationId": "comfyui_get_folders_paths",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ComfyUIFolderPaths"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/create/{name}": {
      "put": {
        "tags": [
          "tasks"
        ],
        "summary": "Create Task",
        "description": "Endpoint to initiate the creation and execution of tasks from the flows.\n\n**Path Parameter:**\n\n- `name`: Name of the flow from which the task should be created\n\n**Reserved Form Fields:**\n\n- `group_scope`: Group number to which task should be assigned. Maximum value is 255\n- `priority`: Task execution priority. Higher numbers indicate higher priority. Maximum value is 15\n- `child_task`: Int boolean indicating whether to create a relation between tasks\n- `webhook_url`: Optional. URL to call when task state changes\n- `webhook_headers`: Optional. Headers for webhook URL as encoded JSON string. Used only when `webhook_url` is set\n- `count`: Number of tasks to be created\n- `translate`: Should the prompt be translated if auto-translation option is enabled\n\n**Dynamic Task Parameters:**\n\nAll other form fields will be considered as **dynamic task-specific input parameters**.\nThese parameters vary depending on the flow specified by `name` and can be either text parameters or input files.\n\n**Custom Headers (Admin Only):**\n\n- `X-WORKER-UNLOAD-MODELS`: If `1`, unloads all models from memory before task execution.\n- `X-WORKER-EXECUTION-PROFILER`: If `1`, enables detailed profiling of task execution.\n- `X-WORKER-ID`: Forces the tasks to be assigned to a specific worker.\n- `X-FEDERATED-TASK`: If `1`, requires X-WORKER-ID`, rejects the task if the worker is busy, mark task as hidden.\n\n**Response:**\n\n- Returns a `TaskRunResults` object containing the list of task IDs and the outputs for the created tasks.\n\n**Notes:**\n\n- The request must use `multipart/form-data` as the content type.\n- Dynamic parameters should correspond to the inputs expected by the specified flow.\n- If a parameter is expected to be a file, include it as a file upload in the form data.\n- If a parameter is expected to be text, include it as a regular form field.\n- The endpoint accepts both text and file inputs as dynamic parameters.",
        "operationId": "create_task",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Name of the flow from which the task should be created"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "multipart/form-data": {
              "schema": {
                "$ref": "#/components/schemas/TaskCreationWithFullParams"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskRunResults"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/progress": {
      "get": {
        "tags": [
          "tasks"
        ],
        "summary": "Get Tasks Progress",
        "description": "Retrieves the full tasks details information for a specific user.\nOptionally filter tasks by their name or a group number.",
        "operationId": "get_tasks_progress",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Optional name to filter tasks by their name",
              "title": "Name"
            },
            "description": "Optional name to filter tasks by their name"
          },
          {
            "name": "group_scope",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "Optional parameter to filter tasks by their group number",
              "default": 1,
              "title": "Group Scope"
            },
            "description": "Optional parameter to filter tasks by their group number"
          },
          {
            "name": "only_parent",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Fetch only parent tasks",
              "default": false,
              "title": "Only Parent"
            },
            "description": "Fetch only parent tasks"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/TaskDetails"
                  },
                  "title": "Response Get Tasks Progress"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "tasks"
        ],
        "summary": "Update Task Progress",
        "description": "Updates the progress of a specific task identified by `task_id`. This endpoint checks if the task exists\nand if the requester is authorized to update its progress. If the task is not found or unauthorized,\na 404 HTTP error is raised, and `worker` should stop and consider the task canceled.",
        "operationId": "update_task_progress",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_update_task_progress"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Task progress updated successfully"
          },
          "400": {
            "description": "Failed to update task progress",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Failed to update task progress."
                }
              }
            }
          },
          "404": {
            "description": "Task not found or not authorized",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task `{task_id}` was not found."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/progress-summary": {
      "get": {
        "tags": [
          "tasks"
        ],
        "summary": "Get Tasks Progress Summary",
        "description": "Retrieves summary of the tasks progress details for a specific user.\nOptionally filter tasks by their name or a group number.",
        "operationId": "get_tasks_progress_summary",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "Optional name to filter tasks by their name",
              "title": "Name"
            },
            "description": "Optional name to filter tasks by their name"
          },
          {
            "name": "group_scope",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "Optional parameter to filter tasks by their group number",
              "default": 1,
              "title": "Group Scope"
            },
            "description": "Optional parameter to filter tasks by their group number"
          },
          {
            "name": "only_parent",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Fetch only parent tasks",
              "default": false,
              "title": "Only Parent"
            },
            "description": "Fetch only parent tasks"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/TaskDetailsShort"
                  },
                  "title": "Response Get Tasks Progress Summary"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/progress/{task_id}": {
      "get": {
        "tags": [
          "tasks"
        ],
        "summary": "Get Task Progress",
        "description": "Retrieves the full task details of a specified task by task ID.\nAccess is restricted to the task owner or an administrator.",
        "operationId": "get_task_progress",
        "parameters": [
          {
            "name": "task_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Task Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TaskDetails"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/restart": {
      "post": {
        "tags": [
          "tasks"
        ],
        "summary": "Restart Task",
        "description": "Restarts a task specified by `task_id` if it has encountered an error or is not yet completed.\nOnly tasks that have errors can be restarted unless `force` is set to `True`,\nwhich allows restarting any non-completed tasks.\nThis endpoint checks the task's current status and resets its progress, allowing it to be re-executed.\nAccess to this action is restricted to the task's owner or an administrator.",
        "operationId": "restart_task",
        "parameters": [
          {
            "name": "task_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "description": "ID of the task to restart",
              "title": "Task Id"
            },
            "description": "ID of the task to restart"
          },
          {
            "name": "force",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Force restart even if the task has no error",
              "default": false,
              "title": "Force"
            },
            "description": "Force restart even if the task has no error"
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully restarted the specified task"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "examples": {
                  "Task already finished": {
                    "summary": "Task already finished",
                    "value": {
                      "detail": "Task `{task_id}` already finished."
                    }
                  },
                  "No error set": {
                    "summary": "No error set",
                    "value": {
                      "detail": "Task `{task_id}` has no error set."
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Task not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task `{task_id}` was not found."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/task": {
      "delete": {
        "tags": [
          "tasks"
        ],
        "summary": "Delete Task",
        "description": "Removes a task from the system by the task ID.\nAccess is limited to the task owner or administrators.\nAlso removes any child tasks associated with the specified task.",
        "operationId": "delete_task",
        "parameters": [
          {
            "name": "task_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "description": "ID of the task to remove",
              "title": "Task Id"
            },
            "description": "ID of the task to remove"
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully removed the specified task and its child tasks"
          },
          "404": {
            "description": "Task not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task `{task_id}` was not found."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/clear": {
      "delete": {
        "tags": [
          "tasks"
        ],
        "summary": "Clear Tasks",
        "description": "Removes all finished parent tasks associated with a specific task name,\nscoped to the requesting user and group scope.\nAll child tasks associated with the parent tasks will also be deleted.",
        "operationId": "clear_tasks",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the task whose results need to be deleted",
              "title": "Name"
            },
            "description": "Name of the task whose results need to be deleted"
          },
          {
            "name": "group_scope",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "Optional group scope to filter tasks only belonging to a specific group. Defaults to 1.",
              "default": 1,
              "title": "Group Scope"
            },
            "description": "Optional group scope to filter tasks only belonging to a specific group. Defaults to 1."
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully removed results of all finished parent tasks with the specified name"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/inputs": {
      "get": {
        "tags": [
          "tasks"
        ],
        "summary": "Get Task Inputs",
        "description": "Retrieves a specific input file for a task, identified by `task_id` and `input_index`. This endpoint\nallows access to input files regardless of whether the task is in queue or has finished. The input index\nis used to select among multiple input files if more than one was provided for the task.\nAdministrators can access inputs of any task, while regular users can only access inputs of their own tasks.",
        "operationId": "get_task_inputs",
        "parameters": [
          {
            "name": "task_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "description": "ID of the task",
              "title": "Task Id"
            },
            "description": "ID of the task"
          },
          {
            "name": "input_index",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "description": "Index of the input file",
              "title": "Input Index"
            },
            "description": "Index of the input file"
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved the input file",
            "content": {
              "application/json": {
                "schema": {}
              },
              "application/octet-stream": {}
            }
          },
          "404": {
            "description": "Task or input file not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task(task_id): input file `file_name` was not found."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/results": {
      "get": {
        "tags": [
          "tasks"
        ],
        "summary": "Get Task Results",
        "description": "Retrieves the result file associated with a specific task and node ID.\n\nThis function searches for output files in the designated output directory that match the task and node identifiers.\n\n**Parameters:**\n\n- `task_id` (int): ID of the task.\n- `node_id` (int): ID of the node.\n- `batch_index` (int, optional): Index of the node result if the node produced more than one result.\n  - If set to 0 (default), the first result file is returned.\n  - If set to a positive integer, the corresponding result file index is returned.\n  - If set to -1, all results are returned as a ZIP archive.\n\n**Returns:**\n\n- `FileResponse`: The result file or a ZIP archive containing all result files if `batch_index` is -1.\n- `HTTPException`: If the task is not completed or the result file is not found.",
        "operationId": "get_task_results",
        "parameters": [
          {
            "name": "task_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "description": "ID of the task",
              "title": "Task Id"
            },
            "description": "ID of the task"
          },
          {
            "name": "node_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "description": "ID of the node",
              "title": "Node Id"
            },
            "description": "ID of the node"
          },
          {
            "name": "batch_index",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "Optional index of the node result if the node produced more than one result. If set to -1, all results for the node are returned as a ZIP archive.",
              "default": 0,
              "title": "Batch Index"
            },
            "description": "Optional index of the node result if the node produced more than one result. If set to -1, all results for the node are returned as a ZIP archive."
          }
        ],
        "responses": {
          "200": {
            "description": "Successfully retrieved the result file",
            "content": {
              "application/json": {
                "schema": {}
              },
              "application/octet-stream": {}
            }
          },
          "400": {
            "description": "Task not completed",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task `task_id` is not completed yet."
                }
              }
            }
          },
          "404": {
            "description": "Task or result file not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Missing result for task=`task_id` and node=`node_id`."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "tasks"
        ],
        "summary": "Set Task Results",
        "description": "Saves the result files for a specific task on the server. This endpoint checks if the task exists\nand if the `worker` making the request has the authorization to upload results.\nIf the task is not found or unauthorized, a 404 HTTP error is raised.",
        "operationId": "set_task_results",
        "parameters": [
          {
            "name": "task_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "description": "The ID of the task to save results for",
              "title": "Task Id"
            },
            "description": "The ID of the task to save results for"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/x-www-form-urlencoded": {
              "schema": {
                "$ref": "#/components/schemas/Body_set_task_results"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Successfully saved task results"
          },
          "404": {
            "description": "Task not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task `{task_id}` was not found."
                }
              }
            }
          },
          "400": {
            "description": "Bad request",
            "content": {
              "application/json": {
                "example": {
                  "detail": "result_file.filename does not belong to task."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/queue": {
      "delete": {
        "tags": [
          "tasks"
        ],
        "summary": "Remove Tasks From Queue",
        "description": "Clears all unfinished tasks from the queue for a specific task name, scoped to the requesting user and group scope.\nChild tasks are ignored and not removed from the queue.",
        "operationId": "remove_tasks_from_queue",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the task to clear unfinished tasks from the queue",
              "title": "Name"
            },
            "description": "Name of the task to clear unfinished tasks from the queue"
          },
          {
            "name": "group_scope",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "Optional group scope to filter tasks only belonging to a specific group. Defaults to 1.",
              "default": 1,
              "title": "Group Scope"
            },
            "description": "Optional group scope to filter tasks only belonging to a specific group. Defaults to 1."
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully cleared unfinished tasks from the queue"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/queue/{task_id}": {
      "delete": {
        "tags": [
          "tasks"
        ],
        "summary": "Remove Task From Queue",
        "description": "Removes a specific unfinished task from the queue using the task ID.",
        "operationId": "remove_task_from_queue",
        "parameters": [
          {
            "name": "task_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Task Id"
            }
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully removed the unfinished task from the queue"
          },
          "404": {
            "description": "Task not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task `{task_id}` was not found."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/next": {
      "post": {
        "tags": [
          "tasks"
        ],
        "summary": "Get Next Task",
        "description": "Retrieves an incomplete task for a `worker` to process. Workers provide a list of tasks names they can handle\nand optionally the name of the last task they were working on to prioritize similar types of tasks. If a\nworker is associated with an admin account, it can retrieve tasks regardless of user assignment; otherwise,\nit retrieves only those assigned to the user.",
        "operationId": "get_next_task",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_get_next_task"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successfully retrieved the task for the worker",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "204": {
            "description": "No incomplete tasks available for the worker"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/lock": {
      "delete": {
        "tags": [
          "tasks"
        ],
        "summary": "Remove Task Lock",
        "description": "Unlocks a task specified by the `task_id`. This endpoint checks if the task exists\nand if the `worker` making the request has the authorization to unlock it.\nIf the task is not found or unauthorized, a 404 HTTP error is raised.",
        "operationId": "remove_task_lock",
        "parameters": [
          {
            "name": "task_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "description": "The ID of the task to remove the lock from",
              "title": "Task Id"
            },
            "description": "The ID of the task to remove the lock from"
          }
        ],
        "responses": {
          "204": {
            "description": "Successfully removed task lock"
          },
          "404": {
            "description": "Task not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task `{task_id}` was not found."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/tasks/update": {
      "put": {
        "tags": [
          "tasks"
        ],
        "summary": "Update Task Info",
        "description": "Updates the information of a task specified by `task_id`. Only tasks that have not yet started (progress == 0.0)\ncan be updated. Currently, only the `priority` field can be updated.\n\nThe `priority` parameter must not exceed 15.\n\nAccess is restricted to the task owner or an administrator.",
        "operationId": "update_task_info",
        "parameters": [
          {
            "name": "task_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "description": "ID of the task to update",
              "title": "Task Id"
            },
            "description": "ID of the task to update"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TaskUpdateRequest",
                "description": "Fields to update"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Successfully updated the task"
          },
          "400": {
            "description": "Bad Request",
            "content": {
              "application/json": {
                "examples": {
                  "Task started": {
                    "summary": "Task already started",
                    "value": {
                      "detail": "Task `{task_id}` cannot be updated because it has already started."
                    }
                  },
                  "Invalid priority": {
                    "summary": "Invalid priority",
                    "value": {
                      "detail": "Priority cannot be greater than 15."
                    }
                  },
                  "No fields": {
                    "summary": "No fields to update",
                    "value": {
                      "detail": "No valid fields to update."
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Task not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Task `{task_id}` was not found."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/workers/info": {
      "get": {
        "tags": [
          "workers"
        ],
        "summary": "Get Info",
        "description": "Fetches details about workers including their system and device information.\nThis endpoint allows filtering of workers based on their last active status and can also\nretrieve information for a specific worker if a worker ID is provided.\nUseful for monitoring and managing worker resources in distributed computing environments.",
        "operationId": "get_info",
        "parameters": [
          {
            "name": "last_seen_interval",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "The time interval in seconds within which workers must have marked themselves active. If specified, only workers who have reported activity within this interval will be returned.",
              "default": 0,
              "title": "Last Seen Interval"
            },
            "description": "The time interval in seconds within which workers must have marked themselves active. If specified, only workers who have reported activity within this interval will be returned."
          },
          {
            "name": "worker_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "description": "An optional worker ID to retrieve details for a specific worker.",
              "default": "",
              "title": "Worker Id"
            },
            "description": "An optional worker ID to retrieve details for a specific worker."
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/WorkerDetails"
                  },
                  "title": "Response Get Info"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/workers/settings": {
      "post": {
        "tags": [
          "workers"
        ],
        "summary": "Set Worker Settings",
        "description": "Sets the desired worker settings that should differ from the defaults.\nThe administrator can change settings for all workers, users only for their own workers.",
        "operationId": "set_worker_settings",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/WorkerSettingsRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "204": {
            "description": "Worker settings set successfully"
          },
          "404": {
            "description": "Worker not found",
            "content": {
              "application/json": {
                "example": {
                  "detail": "Can't find `worker_id` worker."
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/federation/instances": {
      "get": {
        "tags": [
          "federation"
        ],
        "summary": "List Federated Instances",
        "description": "Retrieve a list of all federated instances.\nRequires administrative privileges.",
        "operationId": "list_federated_instances",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "items": {
                    "$ref": "#/components/schemas/FederatedInstance"
                  },
                  "type": "array",
                  "title": "Response List Federated Instances"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/federation/instance": {
      "post": {
        "tags": [
          "federation"
        ],
        "summary": "Create Federated Instance",
        "description": "Create a new federated instance.\nRequires administrative privileges.",
        "operationId": "create_federated_instance",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FederatedInstanceCreate"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Federated instance created successfully",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "400": {
            "description": "Federated instance already exists or invalid data"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "federation"
        ],
        "summary": "Delete Federated Instance",
        "description": "Delete a federated instance by its name.\nRequires administrative privileges.",
        "operationId": "delete_federated_instance",
        "parameters": [
          {
            "name": "instance_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the federated instance to delete",
              "title": "Instance Name"
            },
            "description": "Name of the federated instance to delete"
          }
        ],
        "responses": {
          "204": {
            "description": "Federated instance deleted successfully"
          },
          "404": {
            "description": "Federated instance not found"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "federation"
        ],
        "summary": "Update Federated Instance Endpoint",
        "description": "Update an existing federated instance.\nRequires administrative privileges.",
        "operationId": "update_federated_instance_endpoint",
        "parameters": [
          {
            "name": "instance_name",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Name of the federated instance to update",
              "title": "Instance Name"
            },
            "description": "Name of the federated instance to update"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FederatedInstanceUpdate"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Federated instance updated successfully"
          },
          "404": {
            "description": "Federated instance not found or no update performed"
          },
          "400": {
            "description": "No valid fields provided for update"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/vapi/federation/instance_info": {
      "get": {
        "tags": [
          "federation"
        ],
        "summary": "Get Instance Info",
        "operationId": "get_instance_info",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FederatedInstanceInfo"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "AIResourceModel": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique name of the model."
          },
          "types": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Types",
            "description": "ComfyUI model types to which model belongs(e.g 'checkpoints', 'loras').",
            "default": []
          },
          "filename": {
            "type": "string",
            "title": "Filename",
            "description": "Overridden file name under which the model should be stored in the file system.",
            "default": ""
          },
          "url": {
            "type": "string",
            "title": "Url",
            "description": "URL from which the model can be downloaded."
          },
          "homepage": {
            "type": "string",
            "title": "Homepage",
            "description": "Webpage with detailed information about the model.",
            "default": ""
          },
          "hash": {
            "type": "string",
            "title": "Hash",
            "description": "SHA256 hash of the model file for integrity verification."
          },
          "hashes": {
            "additionalProperties": true,
            "type": "object",
            "title": "Hashes",
            "description": "For archives, may contain filename:hash pairs for integrity checks after the archive is deleted.",
            "default": {}
          },
          "regexes": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Regexes",
            "description": "List of regex patterns that dynamically resolve model details based on workflow configurations.",
            "default": []
          },
          "gated": {
            "type": "boolean",
            "title": "Gated",
            "description": "Flag showing is the model closed to public access.",
            "default": false
          },
          "file_size": {
            "type": "integer",
            "title": "File Size",
            "description": "The size of the model file in bytes."
          },
          "installed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Installed",
            "description": "Flag indicating whether the model is already installed. Currently, this field is populated only by the `/flows/installed` and `/flows/not-installed` endpoints."
          }
        },
        "type": "object",
        "required": [
          "name",
          "url",
          "hash",
          "file_size"
        ],
        "title": "AIResourceModel",
        "description": "Represents an AI model resource within a Flow.\n\nThis model provides a structured way to handle AI\nmodels that are integral to workflows, ensuring that each model can be dynamically\nresolved, downloaded, and verified before use."
      },
      "Body_get_next_task": {
        "properties": {
          "worker_details": {
            "$ref": "#/components/schemas/WorkerDetailsRequest"
          },
          "tasks_names": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tasks Names",
            "description": "List of task names the worker can handle"
          },
          "last_task_name": {
            "type": "string",
            "title": "Last Task Name",
            "description": "Optional name of the last task the worker was working on",
            "default": ""
          }
        },
        "type": "object",
        "required": [
          "worker_details",
          "tasks_names"
        ],
        "title": "Body_get_next_task"
      },
      "Body_install_from_file": {
        "properties": {
          "flow_file": {
            "type": "string",
            "format": "binary",
            "title": "Flow File",
            "description": "The ComfyUI workflow file to be uploaded and installed"
          }
        },
        "type": "object",
        "required": [
          "flow_file"
        ],
        "title": "Body_install_from_file"
      },
      "Body_set_global": {
        "properties": {
          "key": {
            "type": "string",
            "title": "Key",
            "description": "The key of the setting to update"
          },
          "value": {
            "type": "string",
            "title": "Value",
            "description": "The value of the setting to update, or an empty string to delete the setting"
          },
          "sensitive": {
            "type": "boolean",
            "title": "Sensitive",
            "description": "Flag that determines whether the value can be available to users or not"
          }
        },
        "type": "object",
        "required": [
          "key",
          "value",
          "sensitive"
        ],
        "title": "Body_set_global"
      },
      "Body_set_task_results": {
        "properties": {
          "files": {
            "items": {
              "type": "string",
              "format": "binary"
            },
            "type": "array",
            "title": "Files",
            "description": "List of result files to save"
          }
        },
        "type": "object",
        "required": [
          "files"
        ],
        "title": "Body_set_task_results"
      },
      "Body_set_user": {
        "properties": {
          "key": {
            "type": "string",
            "title": "Key",
            "description": "The key of the setting to update"
          },
          "value": {
            "type": "string",
            "title": "Value",
            "description": "The value of the setting to update, or an empty string to delete the setting"
          }
        },
        "type": "object",
        "required": [
          "key",
          "value"
        ],
        "title": "Body_set_user"
      },
      "Body_update_task_progress": {
        "properties": {
          "worker_details": {
            "$ref": "#/components/schemas/WorkerDetailsRequest"
          },
          "task_id": {
            "type": "integer",
            "title": "Task Id",
            "description": "ID of the task to update progress for"
          },
          "progress": {
            "type": "number",
            "title": "Progress",
            "description": "Progress percentage of the task"
          },
          "execution_time": {
            "type": "number",
            "title": "Execution Time",
            "description": "Execution time of the task in seconds"
          },
          "error": {
            "type": "string",
            "title": "Error",
            "description": "Error message if any",
            "default": ""
          },
          "execution_details": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ExecutionDetails"
              },
              {
                "type": "null"
              }
            ]
          }
        },
        "type": "object",
        "required": [
          "worker_details",
          "task_id",
          "progress",
          "execution_time"
        ],
        "title": "Body_update_task_progress"
      },
      "ComfyEngineDetails": {
        "properties": {
          "disable_smart_memory": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Disable Smart Memory",
            "description": "Flag indicating whether ComfyUIs 'smart memory' was disabled."
          },
          "vram_state": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Vram State",
            "description": "Current VRAM management mode used by ComfyUI."
          },
          "cache_type": {
            "type": "string",
            "title": "Cache Type",
            "description": "The type of cache that is in use (classic, lru, none).",
            "default": "classic"
          },
          "cache_size": {
            "type": "integer",
            "title": "Cache Size",
            "description": "How many node results to cache (applies only when cache_type is lru).",
            "default": 1
          },
          "vae_cpu": {
            "type": "boolean",
            "title": "Vae Cpu",
            "description": "Does decoding VAE on CPU is enabled.",
            "default": false
          },
          "reserve_vram": {
            "type": "number",
            "title": "Reserve Vram",
            "description": "Amount of VRAM in GB reserved for use by other software.",
            "default": 0.6
          }
        },
        "type": "object",
        "title": "ComfyEngineDetails",
        "description": "Performance options that ComfyUI is running with."
      },
      "ComfyUIFolderPath": {
        "properties": {
          "full_path": {
            "type": "string",
            "title": "Full Path",
            "description": "The full filesystem path of the folder."
          },
          "create_time": {
            "type": "string",
            "format": "date-time",
            "title": "Create Time",
            "description": "The folder's creation time as a datetime object."
          },
          "total_size": {
            "type": "integer",
            "title": "Total Size",
            "description": "The total size of the folder in bytes."
          }
        },
        "type": "object",
        "required": [
          "full_path",
          "create_time",
          "total_size"
        ],
        "title": "ComfyUIFolderPath",
        "description": "Represents a folder path in ComfyUI with metadata, including modification options, creation time, and size."
      },
      "ComfyUIFolderPaths": {
        "properties": {
          "folders": {
            "additionalProperties": {
              "items": {
                "$ref": "#/components/schemas/ComfyUIFolderPath"
              },
              "type": "array"
            },
            "type": "object",
            "title": "Folders",
            "description": "A mapping of folder keys to a list of folder paths with metadata."
          }
        },
        "type": "object",
        "required": [
          "folders"
        ],
        "title": "ComfyUIFolderPaths",
        "description": "Represents a mapping of folder keys to their corresponding folder paths and metadata."
      },
      "CustomLoraDefinition": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique name of the model."
          },
          "types": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Types",
            "description": "ComfyUI model types to which model belongs(e.g 'checkpoints', 'loras').",
            "default": []
          },
          "filename": {
            "type": "string",
            "title": "Filename",
            "description": "Overridden file name under which the model should be stored in the file system.",
            "default": ""
          },
          "url": {
            "type": "string",
            "title": "Url",
            "description": "URL from which the model can be downloaded."
          },
          "homepage": {
            "type": "string",
            "title": "Homepage",
            "description": "Webpage with detailed information about the model.",
            "default": ""
          },
          "hash": {
            "type": "string",
            "title": "Hash",
            "description": "SHA256 hash of the model file for integrity verification."
          },
          "hashes": {
            "additionalProperties": true,
            "type": "object",
            "title": "Hashes",
            "description": "For archives, may contain filename:hash pairs for integrity checks after the archive is deleted.",
            "default": {}
          },
          "regexes": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Regexes",
            "description": "List of regex patterns that dynamically resolve model details based on workflow configurations.",
            "default": []
          },
          "gated": {
            "type": "boolean",
            "title": "Gated",
            "description": "Flag showing is the model closed to public access.",
            "default": false
          },
          "file_size": {
            "type": "integer",
            "title": "File Size",
            "description": "The size of the model file in bytes."
          },
          "installed": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Installed",
            "description": "Flag indicating whether the model is already installed. Currently, this field is populated only by the `/flows/installed` and `/flows/not-installed` endpoints."
          },
          "strength_model": {
            "type": "number",
            "title": "Strength Model",
            "description": "Default strength of the LoRA model.",
            "default": 1.0
          },
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "Text to display for the LoRA slider.",
            "default": ""
          },
          "trigger_words": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Trigger Words",
            "description": "List of words to trigger the LoRA.",
            "default": []
          },
          "node_id": {
            "type": "string",
            "title": "Node Id",
            "description": "ComfyUI Node ID from which this definition was created."
          }
        },
        "type": "object",
        "required": [
          "name",
          "url",
          "hash",
          "file_size",
          "node_id"
        ],
        "title": "CustomLoraDefinition",
        "description": "Definition of custom LoRA added to the flow. Backend will automatically generate inputs for it."
      },
      "CustomLoraDefinitionRequest": {
        "properties": {
          "strength_model": {
            "type": "number",
            "title": "Strength Model",
            "description": "Default strength of the LoRA model.",
            "default": 1.0
          },
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "Text to display for the LoRA slider."
          },
          "model_url": {
            "type": "string",
            "title": "Model Url",
            "description": "The CivitAI URL for this model, allowing to embed this model in Flow."
          }
        },
        "type": "object",
        "required": [
          "display_name",
          "model_url"
        ],
        "title": "CustomLoraDefinitionRequest",
        "description": "Represents a custom LoRA model to be embedded in the flow."
      },
      "ExecutionDetails": {
        "properties": {
          "disable_smart_memory": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Disable Smart Memory",
            "description": "Flag indicating whether ComfyUIs 'smart memory' was disabled."
          },
          "vram_state": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Vram State",
            "description": "Current VRAM management mode used by ComfyUI."
          },
          "cache_type": {
            "type": "string",
            "title": "Cache Type",
            "description": "The type of cache that is in use (classic, lru, none).",
            "default": "classic"
          },
          "cache_size": {
            "type": "integer",
            "title": "Cache Size",
            "description": "How many node results to cache (applies only when cache_type is lru).",
            "default": 1
          },
          "vae_cpu": {
            "type": "boolean",
            "title": "Vae Cpu",
            "description": "Does decoding VAE on CPU is enabled.",
            "default": false
          },
          "reserve_vram": {
            "type": "number",
            "title": "Reserve Vram",
            "description": "Amount of VRAM in GB reserved for use by other software.",
            "default": 0.6
          },
          "nodes_profiling": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/NodeProfiling"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Nodes Profiling",
            "description": "Profiling information for each node in the workflow."
          },
          "max_memory_usage": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Memory Usage",
            "description": "Maximum GPU memory usage during task execution in MB."
          },
          "nodes_execution_time": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Nodes Execution Time",
            "description": "Execution time of all ComfyUI nodes in the workflow in seconds."
          }
        },
        "type": "object",
        "title": "ExecutionDetails",
        "description": "Contains profiling information for the entire task execution."
      },
      "ExtraFlags": {
        "properties": {
          "profiler_execution": {
            "type": "boolean",
            "title": "Profiler Execution",
            "description": "Whether profiling was enabled during task execution.",
            "default": false
          },
          "unload_models": {
            "type": "boolean",
            "title": "Unload Models",
            "description": "Whether all models were unloaded before task execution.",
            "default": false
          },
          "federated_task": {
            "type": "boolean",
            "title": "Federated Task",
            "description": "Whether the task originated from a federated instance.",
            "default": false
          },
          "save_metadata": {
            "type": "boolean",
            "title": "Save Metadata",
            "description": "Whether the ComfyUI workflow metadata was saved.",
            "default": false
          },
          "smart_memory": {
            "type": "boolean",
            "title": "Smart Memory",
            "description": "Whether ComfyUI smart memory was enabled.",
            "default": false
          },
          "cache_type": {
            "type": "string",
            "title": "Cache Type",
            "description": "The type of cache that was used (classic, lru, none).",
            "default": "classic"
          },
          "cache_size": {
            "type": "integer",
            "title": "Cache Size",
            "description": "How many node results were cached (applied only when cache_type was lru).",
            "default": 1
          },
          "vae_cpu": {
            "type": "boolean",
            "title": "Vae Cpu",
            "description": "Flag indicating was VAE decoded on the CPU or not.",
            "default": false
          },
          "reserve_vram": {
            "type": "number",
            "title": "Reserve Vram",
            "description": "Amount of VRAM in GB that was reserved for use by other software..",
            "default": 0.6
          }
        },
        "type": "object",
        "title": "ExtraFlags",
        "description": "Additional options and flags that were applied during task execution."
      },
      "FederatedInstance": {
        "properties": {
          "instance_name": {
            "type": "string",
            "title": "Instance Name",
            "description": "Unique name of the federated instance."
          },
          "url_address": {
            "type": "string",
            "title": "Url Address",
            "description": "Address of the federated instance."
          },
          "username": {
            "type": "string",
            "title": "Username",
            "description": "The username present on the remote instance."
          },
          "password": {
            "type": "string",
            "title": "Password",
            "description": "Password for the username."
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Indicates if the federated instance is currently active.",
            "default": true
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Timestamp when the federated instance record was created."
          },
          "installed_flows": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Installed Flows",
            "description": "A dictionary with installed Flows identifiers and their versions."
          }
        },
        "type": "object",
        "required": [
          "instance_name",
          "url_address",
          "username",
          "password",
          "created_at",
          "installed_flows"
        ],
        "title": "FederatedInstance"
      },
      "FederatedInstanceCreate": {
        "properties": {
          "instance_name": {
            "type": "string",
            "title": "Instance Name",
            "description": "Unique name of the federated instance."
          },
          "url_address": {
            "type": "string",
            "title": "Url Address",
            "description": "Address of the federated instance."
          },
          "username": {
            "type": "string",
            "title": "Username",
            "description": "The username present on the remote instance."
          },
          "password": {
            "type": "string",
            "title": "Password",
            "description": "Password for the username."
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Indicates if the federated instance is currently active.",
            "default": true
          }
        },
        "type": "object",
        "required": [
          "instance_name",
          "url_address",
          "username",
          "password"
        ],
        "title": "FederatedInstanceCreate"
      },
      "FederatedInstanceInfo": {
        "properties": {
          "workers": {
            "items": {
              "$ref": "#/components/schemas/WorkerDetails"
            },
            "type": "array",
            "title": "Workers",
            "description": "List of available workers on the instance.",
            "default": []
          },
          "installed_flows": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Installed Flows",
            "description": "A dictionary with installed Flows identifiers and their versions.",
            "default": {}
          }
        },
        "type": "object",
        "title": "FederatedInstanceInfo"
      },
      "FederatedInstanceUpdate": {
        "properties": {
          "url_address": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Url Address",
            "description": "New address of the federated instance."
          },
          "username": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Username",
            "description": "New username for the remote instance."
          },
          "password": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Password",
            "description": "New password for the username."
          },
          "enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Enabled",
            "description": "New active status for the federated instance."
          }
        },
        "type": "object",
        "title": "FederatedInstanceUpdate"
      },
      "Flow": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The unique identifier of the flow."
          },
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "The user-friendly name of the flow."
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "A brief explanation of the flow's purpose and functionality.",
            "default": ""
          },
          "author": {
            "type": "string",
            "title": "Author",
            "description": "The creator or maintainer of the flow."
          },
          "homepage": {
            "type": "string",
            "title": "Homepage",
            "description": "A URL to the flow's homepage or the author's website.",
            "default": ""
          },
          "license": {
            "type": "string",
            "title": "License",
            "description": "The type of license under which the flow is made available.",
            "default": ""
          },
          "documentation": {
            "type": "string",
            "title": "Documentation",
            "description": "A URL linking to detailed documentation for the flow.",
            "default": ""
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags describing this flow.",
            "default": []
          },
          "sub_flows": {
            "items": {
              "$ref": "#/components/schemas/SubFlow"
            },
            "type": "array",
            "title": "Sub Flows",
            "description": "A list of subflows derived from this flow, allowing customization or extension.",
            "default": []
          },
          "models": {
            "items": {
              "$ref": "#/components/schemas/AIResourceModel"
            },
            "type": "array",
            "title": "Models",
            "description": "A list of models used by the ComfyUI workflow.",
            "default": []
          },
          "input_params": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Input Params",
            "description": "Initial set of parameters required to launch the flow, potentially modifiable by subflows."
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Internal version of the flow in major.minor format.",
            "default": ""
          },
          "requires": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Requires",
            "description": "Required external workflow dependencies.",
            "default": []
          },
          "private": {
            "type": "boolean",
            "title": "Private",
            "description": "Whether the workflow is missing from the `FLOWS_CATALOG_URL`",
            "default": false
          },
          "hidden": {
            "type": "boolean",
            "title": "Hidden",
            "description": "Flag for hiding flow from UI when flow is intended for use only in some special cases.",
            "default": false
          },
          "new_version_available": {
            "type": "string",
            "title": "New Version Available",
            "description": "If not empty, contains the new version of the workflow.",
            "default": ""
          },
          "is_seed_supported": {
            "type": "boolean",
            "title": "Is Seed Supported",
            "description": "Flag determining if 'Random Seed' input will be displayed in the UI.",
            "default": true
          },
          "is_count_supported": {
            "type": "boolean",
            "title": "Is Count Supported",
            "description": "Flag determining if 'Number of images' input will be displayed in the UI.",
            "default": true
          },
          "is_translations_supported": {
            "type": "boolean",
            "title": "Is Translations Supported",
            "description": "Flag that determines whether Flow supports prompt translations.",
            "default": false
          },
          "is_macos_supported": {
            "type": "boolean",
            "title": "Is Macos Supported",
            "description": "Flag indicating whether the macOS PyTorch version can correctly run this flow.",
            "default": true
          },
          "is_supported_by_workers": {
            "type": "boolean",
            "title": "Is Supported By Workers",
            "description": "Flag indicating if this flow can run on workers based on their capabilities.",
            "default": true
          },
          "required_memory_gb": {
            "type": "number",
            "title": "Required Memory Gb",
            "description": "Minimum amount of memory (in gigabytes) required to execute this flow.",
            "default": 0.0
          },
          "lora_connect_points": {
            "additionalProperties": {
              "$ref": "#/components/schemas/LoraConnectionPoint"
            },
            "type": "object",
            "title": "Lora Connect Points",
            "description": "Connection points in the flow where LoRAs can be dynamically integrated, enabling the addition of custom LoRAs at specific locations. Key is a unique ID that used to reference specific connection during Flow editing.",
            "default": {}
          },
          "is_surprise_me_supported": {
            "type": "boolean",
            "title": "Is Surprise Me Supported",
            "description": "Flag indicating if Flow supports random prompt generation feature.",
            "default": false
          },
          "remote_vae": {
            "type": "boolean",
            "title": "Remote Vae",
            "description": "Flag indicating whether Flow supports remote VAE decoding.",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "name",
          "display_name",
          "author",
          "input_params"
        ],
        "title": "Flow",
        "description": "Flows serve as add-ons to ComfyUI workflows, determining the parameters to be displayed and populated.\nThey also allow for the modification of ComfyUI workflow behavior based on incoming parameters."
      },
      "FlowCloneRequest": {
        "properties": {
          "original_flow_name": {
            "type": "string",
            "title": "Original Flow Name",
            "description": "Name of the installed flow to clone from."
          },
          "new_name": {
            "type": "string",
            "title": "New Name",
            "description": "New internal name for the cloned flow (must be unique)."
          },
          "metadata": {
            "$ref": "#/components/schemas/FlowMetadataUpdate",
            "description": "New metadata to apply to the cloned flow."
          },
          "lora_connection_points": {
            "anyOf": [
              {
                "additionalProperties": {
                  "items": {
                    "$ref": "#/components/schemas/CustomLoraDefinitionRequest"
                  },
                  "type": "array"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lora Connection Points",
            "description": "Optional LoRA connection points for the new flow. These should align with the connection points defined in the original flow."
          }
        },
        "type": "object",
        "required": [
          "original_flow_name",
          "new_name",
          "metadata"
        ],
        "title": "FlowCloneRequest",
        "description": "Represents the data required to clone and modify an existing flow.\n\nThis model is used to create a new flow by copying from an existing one\nand optionally updating its metadata, LoRA connection points, or other attributes.\nIt allows for targeted customization while preserving the base functionality of the original flow."
      },
      "FlowMetadataUpdate": {
        "properties": {
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "New display name for the flow."
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Updated description of the flow."
          },
          "license": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "License",
            "description": "Updated license for the flow."
          },
          "required_memory_gb": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Required Memory Gb",
            "description": "Updated required memory (in GB) for the flow."
          },
          "version": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Version",
            "description": "Updated version of the flow."
          }
        },
        "type": "object",
        "required": [
          "display_name"
        ],
        "title": "FlowMetadataUpdate"
      },
      "FlowProgressInstall": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The name of the flow being installed."
          },
          "flow": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/Flow"
              },
              {
                "type": "null"
              }
            ],
            "description": "Parsed information about Flow in Visionatrix format."
          },
          "flow_comfy": {
            "additionalProperties": true,
            "type": "object",
            "title": "Flow Comfy",
            "description": "The ComfyUI workflow which are installed."
          },
          "progress": {
            "type": "number",
            "title": "Progress",
            "description": "The current progress of the installation, ranging from 0 to 100."
          },
          "error": {
            "type": "string",
            "title": "Error",
            "description": "Details of any error encountered during the installation process.",
            "default": ""
          },
          "started_at": {
            "type": "string",
            "format": "date-time",
            "title": "Started At",
            "description": "Timestamp when the installation process started."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Timestamp of the last update to the installation progress."
          }
        },
        "type": "object",
        "required": [
          "name",
          "flow_comfy",
          "progress",
          "started_at",
          "updated_at"
        ],
        "title": "FlowProgressInstall",
        "description": "Represents the progress status of a flow installation process."
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "LoraConnectionPoint": {
        "properties": {
          "description": {
            "type": "string",
            "title": "Description",
            "description": "A brief description of the functionality or purpose of this connection point for integrating LoRAs into the flow.",
            "default": ""
          },
          "base_model_type": {
            "type": "string",
            "title": "Base Model Type",
            "description": "Specifies the base model type in the CivitAI format that is compatible with this connection point, allowing the UI to filter applicable LoRAs."
          },
          "connected_loras": {
            "items": {
              "$ref": "#/components/schemas/CustomLoraDefinition"
            },
            "type": "array",
            "title": "Connected Loras",
            "description": "A list of LoRAs that are currently connected to this point in the flow.",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "base_model_type"
        ],
        "title": "LoraConnectionPoint",
        "description": "Represents a connection point in the flow where LoRAs can be added.\nProvides details necessary for the UI to manage dynamic LoRA integration within the flow."
      },
      "NodeProfiling": {
        "properties": {
          "execution_time": {
            "type": "number",
            "title": "Execution Time",
            "description": "Execution time of the node in seconds."
          },
          "gpu_memory_usage": {
            "type": "number",
            "title": "Gpu Memory Usage",
            "description": "GPU memory consumed by the node in MB."
          },
          "class_type": {
            "type": "string",
            "title": "Class Type",
            "description": "Class type of the node."
          },
          "title": {
            "type": "string",
            "title": "Title",
            "description": "Title of the node."
          },
          "node_id": {
            "type": "string",
            "title": "Node Id",
            "description": "Unique identifier of the node."
          }
        },
        "type": "object",
        "required": [
          "execution_time",
          "gpu_memory_usage",
          "class_type",
          "title",
          "node_id"
        ],
        "title": "NodeProfiling",
        "description": "Represents profiling information for a single node in the workflow."
      },
      "OllamaModelItem": {
        "properties": {
          "model": {
            "type": "string",
            "title": "Model",
            "description": "Name of the model."
          },
          "size": {
            "type": "integer",
            "title": "Size",
            "description": "Size of the model file in bytes."
          },
          "modified_at": {
            "type": "number",
            "title": "Modified At",
            "description": "Unix timestamp of the last modification time of the model file."
          }
        },
        "type": "object",
        "required": [
          "model",
          "size",
          "modified_at"
        ],
        "title": "OllamaModelItem",
        "description": "Represents a single model file on the Ollama server."
      },
      "OrphanModel": {
        "properties": {
          "path": {
            "type": "string",
            "title": "Path",
            "description": "The relative path of the orphaned model file within 'models_dir' directory."
          },
          "full_path": {
            "type": "string",
            "title": "Full Path",
            "description": "Full path to the orphaned model file."
          },
          "size": {
            "type": "integer",
            "title": "Size",
            "description": "Size of the orphaned model file in bytes."
          },
          "creation_time": {
            "type": "number",
            "title": "Creation Time",
            "description": "The file's creation time in seconds."
          },
          "res_model": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AIResourceModel"
              },
              {
                "type": "null"
              }
            ],
            "description": "AIResourceModel describing the file, if any matches."
          },
          "possible_flows": {
            "items": {
              "$ref": "#/components/schemas/Flow"
            },
            "type": "array",
            "title": "Possible Flows",
            "description": "List of possible flows that could potentially use this model.",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "path",
          "full_path",
          "size",
          "creation_time"
        ],
        "title": "OrphanModel",
        "description": "Represents an orphaned model file that is not associated with any currently installed flow.\n\nThis model provides detailed information about the orphaned file, including its\nsize, potential usage in flows, and any matching AIResourceModel, if available."
      },
      "SubFlow": {
        "properties": {
          "display_name": {
            "type": "string",
            "title": "Display Name",
            "description": "The new display name when this subflow's parameters are used."
          },
          "type": {
            "type": "string",
            "title": "Type",
            "description": "The type of object this subflow is applicable to, e.g., 'image', 'image-inpaint' or 'video'."
          },
          "input_params": {
            "items": {
              "additionalProperties": true,
              "type": "object"
            },
            "type": "array",
            "title": "Input Params",
            "description": "List of input parameters specific to this subflow, replacing the original flow's parameters.",
            "default": []
          }
        },
        "type": "object",
        "required": [
          "display_name",
          "type"
        ],
        "title": "SubFlow",
        "description": "A SubFlow modifies or extends a Flow by overwriting certain parameters like display_name and input_params."
      },
      "TaskCreationWithFullParams": {
        "properties": {
          "group_scope": {
            "type": "integer",
            "maximum": 255.0,
            "minimum": 1.0,
            "title": "Group Scope",
            "description": "Group number to which task should be assigned.",
            "default": 1
          },
          "priority": {
            "type": "integer",
            "maximum": 15.0,
            "minimum": 0.0,
            "title": "Priority",
            "description": "Execution priority. Higher numbers indicate higher priority.",
            "default": 0
          },
          "child_task": {
            "type": "integer",
            "title": "Child Task",
            "description": "Int boolean indicating whether to create a relation between tasks",
            "default": 0
          },
          "webhook_url": {
            "type": "string",
            "title": "Webhook Url",
            "description": "Optional. URL to call when task state changes. Leave empty if not needed or if using `/progress` or `/progress-summary` endpoints.",
            "default": ""
          },
          "webhook_headers": {
            "type": "string",
            "title": "Webhook Headers",
            "description": "Optional. Headers for webhook URL as an encoded JSON string. Used only when `webhook_url` is set.",
            "default": ""
          },
          "seed": {
            "type": "integer",
            "title": "Seed",
            "description": "The `seed` parameter for reproducing the results of workflows.",
            "default": 1
          },
          "count": {
            "type": "integer",
            "minimum": 1.0,
            "title": "Count",
            "description": "Number of tasks to be created.",
            "default": 1
          },
          "translate": {
            "type": "integer",
            "title": "Translate",
            "description": "Should the prompt be translated if auto-translation option is enabled.",
            "default": 0
          }
        },
        "type": "object",
        "title": "TaskCreationWithFullParams"
      },
      "TaskDetails": {
        "properties": {
          "task_id": {
            "type": "integer",
            "title": "Task Id",
            "description": "Unique identifier of the task."
          },
          "priority": {
            "type": "integer",
            "title": "Priority",
            "description": "Local task priority, from 0 to 15. Default is 0.",
            "default": 0
          },
          "progress": {
            "type": "number",
            "title": "Progress",
            "description": "Progress from 0 to 100, task results are only available once progress reaches 100."
          },
          "error": {
            "type": "string",
            "title": "Error",
            "description": "If this field is not empty, it indicates an error that occurred during task execution."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The unique identifier of the flow."
          },
          "input_params": {
            "additionalProperties": true,
            "type": "object",
            "title": "Input Params",
            "description": "Incoming textual parameters based on which the ComfyUI workflow was generated."
          },
          "outputs": {
            "items": {
              "$ref": "#/components/schemas/TaskDetailsOutput"
            },
            "type": "array",
            "title": "Outputs",
            "description": "ComfyUI nodes from which results can be retrieved."
          },
          "input_files": {
            "items": {
              "$ref": "#/components/schemas/TaskDetailsInput"
            },
            "type": "array",
            "title": "Input Files",
            "description": "Incoming file parameters based on which the ComfyUI workflow was generated."
          },
          "locked_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Locked At",
            "description": "Lock time if task is locked."
          },
          "worker_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Worker Id",
            "description": "Unique identifier of the worker working on the task."
          },
          "execution_time": {
            "type": "number",
            "title": "Execution Time",
            "description": "Execution time of the ComfyUI workflow in seconds."
          },
          "group_scope": {
            "type": "integer",
            "title": "Group Scope",
            "description": "Group number to which task is assigned.",
            "default": 1
          },
          "parent_task_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parent Task Id",
            "description": "Parent task ID if is a child task."
          },
          "parent_task_node_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parent Task Node Id",
            "description": "Parent task Node ID if is a child task."
          },
          "child_tasks": {
            "items": {
              "$ref": "#/components/schemas/TaskDetailsShort"
            },
            "type": "array",
            "title": "Child Tasks",
            "description": "List of child tasks of type `TaskDetailsShort` if any.",
            "default": []
          },
          "translated_input_params": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Translated Input Params",
            "description": "If auto-translation feature is enabled, contains translations for input values."
          },
          "extra_flags": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ExtraFlags"
              },
              {
                "type": "null"
              }
            ],
            "description": "Set of additional options and flags that affect how the task is executed."
          },
          "hidden": {
            "type": "boolean",
            "title": "Hidden",
            "description": "Flag showing is this the internal task that should not be displayed by default."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Task creation time."
          },
          "updated_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Updated At",
            "description": "Last task update time."
          },
          "finished_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Finished At",
            "description": "Finish time of the task."
          },
          "flow_comfy": {
            "additionalProperties": true,
            "type": "object",
            "title": "Flow Comfy",
            "description": "The final generated ComfyUI workflow."
          },
          "user_id": {
            "type": "string",
            "title": "User Id",
            "description": "User ID to whom the task belongs."
          },
          "webhook_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Webhook Url",
            "description": "URL that was set to be called when the task state changes."
          },
          "webhook_headers": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Webhook Headers",
            "description": "Headers that were set to be sent to the webhook URL."
          },
          "execution_details": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ExecutionDetails"
              },
              {
                "type": "null"
              }
            ],
            "description": "Profiling information about task execution, present only if profiling was enabled for this task."
          },
          "custom_worker": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Custom Worker",
            "description": "ID of the worker to which the task was explicitly assigned, if specified."
          }
        },
        "type": "object",
        "required": [
          "task_id",
          "progress",
          "error",
          "name",
          "input_params",
          "outputs",
          "input_files",
          "execution_time",
          "hidden",
          "created_at",
          "flow_comfy",
          "user_id"
        ],
        "title": "TaskDetails",
        "description": "Detailed information about the Task."
      },
      "TaskDetailsInput": {
        "properties": {
          "file_name": {
            "type": "string",
            "title": "File Name",
            "description": "Format of name is 'task_id' + '_' + 'index'"
          },
          "file_size": {
            "type": "integer",
            "title": "File Size",
            "description": "Size of file in bytes."
          }
        },
        "type": "object",
        "required": [
          "file_name",
          "file_size"
        ],
        "title": "TaskDetailsInput",
        "description": "Information about input file to a ComfyUI workflow."
      },
      "TaskDetailsOutput": {
        "properties": {
          "comfy_node_id": {
            "type": "integer",
            "title": "Comfy Node Id",
            "description": "ID of the ComfyUI node containing the result."
          },
          "type": {
            "type": "string",
            "title": "Type",
            "description": "Type of the result from the ComfyUI node - can be either 'image', 'image-mask', 'image-animated', 'video' or 'audio'."
          },
          "file_size": {
            "type": "integer",
            "title": "File Size",
            "description": "Size of file(s) in bytes.",
            "default": -1
          },
          "batch_size": {
            "type": "integer",
            "title": "Batch Size",
            "description": "Count of outputs(files) produced by node.",
            "default": -1
          }
        },
        "type": "object",
        "required": [
          "comfy_node_id",
          "type"
        ],
        "title": "TaskDetailsOutput",
        "description": "Contains information for retrieving the results of a ComfyUI workflow."
      },
      "TaskDetailsShort": {
        "properties": {
          "task_id": {
            "type": "integer",
            "title": "Task Id",
            "description": "Unique identifier of the task."
          },
          "priority": {
            "type": "integer",
            "title": "Priority",
            "description": "Local task priority, from 0 to 15. Default is 0.",
            "default": 0
          },
          "progress": {
            "type": "number",
            "title": "Progress",
            "description": "Progress from 0 to 100, task results are only available once progress reaches 100."
          },
          "error": {
            "type": "string",
            "title": "Error",
            "description": "If this field is not empty, it indicates an error that occurred during task execution."
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The unique identifier of the flow."
          },
          "input_params": {
            "additionalProperties": true,
            "type": "object",
            "title": "Input Params",
            "description": "Incoming textual parameters based on which the ComfyUI workflow was generated."
          },
          "outputs": {
            "items": {
              "$ref": "#/components/schemas/TaskDetailsOutput"
            },
            "type": "array",
            "title": "Outputs",
            "description": "ComfyUI nodes from which results can be retrieved."
          },
          "input_files": {
            "items": {
              "$ref": "#/components/schemas/TaskDetailsInput"
            },
            "type": "array",
            "title": "Input Files",
            "description": "Incoming file parameters based on which the ComfyUI workflow was generated."
          },
          "locked_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Locked At",
            "description": "Lock time if task is locked."
          },
          "worker_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Worker Id",
            "description": "Unique identifier of the worker working on the task."
          },
          "execution_time": {
            "type": "number",
            "title": "Execution Time",
            "description": "Execution time of the ComfyUI workflow in seconds."
          },
          "group_scope": {
            "type": "integer",
            "title": "Group Scope",
            "description": "Group number to which task is assigned.",
            "default": 1
          },
          "parent_task_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parent Task Id",
            "description": "Parent task ID if is a child task."
          },
          "parent_task_node_id": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Parent Task Node Id",
            "description": "Parent task Node ID if is a child task."
          },
          "child_tasks": {
            "items": {
              "$ref": "#/components/schemas/TaskDetailsShort"
            },
            "type": "array",
            "title": "Child Tasks",
            "description": "List of child tasks of type `TaskDetailsShort` if any.",
            "default": []
          },
          "translated_input_params": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Translated Input Params",
            "description": "If auto-translation feature is enabled, contains translations for input values."
          },
          "extra_flags": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ExtraFlags"
              },
              {
                "type": "null"
              }
            ],
            "description": "Set of additional options and flags that affect how the task is executed."
          },
          "hidden": {
            "type": "boolean",
            "title": "Hidden",
            "description": "Flag showing is this the internal task that should not be displayed by default."
          }
        },
        "type": "object",
        "required": [
          "task_id",
          "progress",
          "error",
          "name",
          "input_params",
          "outputs",
          "input_files",
          "execution_time",
          "hidden"
        ],
        "title": "TaskDetailsShort",
        "description": "Brief information about the Task."
      },
      "TaskRunResults": {
        "properties": {
          "tasks_ids": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "title": "Tasks Ids",
            "description": "List of IDs representing the tasks that were created."
          },
          "outputs": {
            "items": {
              "$ref": "#/components/schemas/TaskDetailsOutput"
            },
            "type": "array",
            "title": "Outputs",
            "description": "List of outputs for the created tasks."
          }
        },
        "type": "object",
        "required": [
          "tasks_ids",
          "outputs"
        ],
        "title": "TaskRunResults"
      },
      "TaskUpdateRequest": {
        "properties": {
          "priority": {
            "anyOf": [
              {
                "type": "integer",
                "maximum": 15.0,
                "minimum": 0.0
              },
              {
                "type": "null"
              }
            ],
            "title": "Priority",
            "description": "New priority level for task. Higher numbers indicate higher priority. Maximum value is 15."
          }
        },
        "type": "object",
        "required": [
          "priority"
        ],
        "title": "TaskUpdateRequest",
        "description": "Represents the fields that can be updated for a task that has not yet started execution.\n\nThis model allows clients to specify new values for task properties that are editable\nbefore the task begins processing."
      },
      "TranslatePromptRequest": {
        "properties": {
          "prompt": {
            "type": "string",
            "title": "Prompt",
            "description": "The image generation prompt to translate."
          },
          "system_prompt": {
            "type": "string",
            "title": "System Prompt",
            "description": "System instructions that are passed to the LLM."
          }
        },
        "type": "object",
        "required": [
          "prompt"
        ],
        "title": "TranslatePromptRequest",
        "description": "Represents the request data for translating an image generation prompt."
      },
      "TranslatePromptResponse": {
        "properties": {
          "prompt": {
            "type": "string",
            "title": "Prompt",
            "description": "The original prompt provided in the request."
          },
          "result": {
            "type": "string",
            "title": "Result",
            "description": "The translated prompt in English."
          },
          "done_reason": {
            "type": "string",
            "title": "Done Reason",
            "description": "The reason the translation generation was completed."
          }
        },
        "type": "object",
        "required": [
          "prompt",
          "result",
          "done_reason"
        ],
        "title": "TranslatePromptResponse",
        "description": "Represents the response data after translating an image generation prompt.\n\nContains the original prompt provided by the user, the translated prompt in English,\nand the reason the translation process completed."
      },
      "UserInfo": {
        "properties": {
          "user_id": {
            "type": "string",
            "title": "User Id",
            "description": "Unique user ID."
          },
          "full_name": {
            "type": "string",
            "title": "Full Name",
            "description": "Full name of the user.",
            "default": ""
          },
          "email": {
            "type": "string",
            "title": "Email",
            "description": "Email name of the user.",
            "default": ""
          },
          "is_admin": {
            "type": "boolean",
            "title": "Is Admin",
            "description": "Flag showing is user is admin.",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "user_id"
        ],
        "title": "UserInfo",
        "description": "Minimum information provided by Authentication backends about user."
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      },
      "VisionatrixUpdateStatus": {
        "properties": {
          "current_version": {
            "type": "string",
            "title": "Current Version",
            "description": "The current version of Visionatrix."
          },
          "next_version": {
            "type": "string",
            "title": "Next Version",
            "description": "The version for update if available.",
            "default": ""
          }
        },
        "type": "object",
        "required": [
          "current_version"
        ],
        "title": "VisionatrixUpdateStatus",
        "description": "Represents the update status of Visionatrix.\n\n- current_version: The version currently running.\n- target_version: The version available for update (if any)."
      },
      "WorkerDetails": {
        "properties": {
          "user_id": {
            "type": "string",
            "title": "User Id",
            "description": "The foreign key from the 'users' table, non-nullable."
          },
          "worker_id": {
            "type": "string",
            "title": "Worker Id",
            "description": "Uniq identifier for the worker, constructed from user_id, hostname, device name and device index.If 'federated_instance_name' is specified it will be added to this field automatically."
          },
          "worker_version": {
            "type": "string",
            "title": "Worker Version",
            "description": "Version of the worker"
          },
          "last_seen": {
            "type": "string",
            "format": "date-time",
            "title": "Last Seen",
            "description": "The timestamp of the worker's last activity, stored in UTC."
          },
          "tasks_to_give": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tasks To Give",
            "description": "Specifies tasks that the worker can execute. An empty list indicates that all tasks are allowed."
          },
          "os": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Os",
            "description": "Operating system type of the worker's machine, such as 'posix' or 'nt'."
          },
          "version": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Version",
            "description": "The version of Python running on the worker's machine."
          },
          "embedded_python": {
            "type": "boolean",
            "title": "Embedded Python",
            "description": "Indicates whether the Python environment is embedded (portable).",
            "default": false
          },
          "device_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Device Name",
            "description": "Name of the computing device."
          },
          "device_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Device Type",
            "description": "Type of the computing device, such as 'cuda' or 'cpu'."
          },
          "vram_total": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Vram Total",
            "description": "Total VRAM available on the device in bytes."
          },
          "vram_free": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Vram Free",
            "description": "Free VRAM available on the device in bytes."
          },
          "torch_vram_total": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Torch Vram Total",
            "description": "Total VRAM managed by PyTorch in bytes."
          },
          "torch_vram_free": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Torch Vram Free",
            "description": "Free VRAM managed by PyTorch that is currently unused."
          },
          "ram_total": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ram Total",
            "description": "Total RAM available on the worker in bytes."
          },
          "ram_free": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ram Free",
            "description": "Free RAM available on the worker in bytes."
          },
          "pytorch_version": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pytorch Version",
            "description": "Version of PyTorch."
          },
          "engine_details": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/ComfyEngineDetails"
              },
              {
                "type": "null"
              }
            ]
          },
          "federated_instance_name": {
            "type": "string",
            "title": "Federated Instance Name",
            "description": "Name of the federated instance to which the worker belongs.",
            "default": ""
          },
          "empty_task_requests_count": {
            "type": "integer",
            "title": "Empty Task Requests Count",
            "description": "Counts the number of times the worker requested a task but received none. A value of 0 indicates that the worker is busy, while a value of 1 or more indicates that the worker is free.",
            "default": 0
          },
          "last_asked_tasks": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Last Asked Tasks",
            "description": "List of flows IDs that the worker last requested to be processed.",
            "default": []
          },
          "smart_memory": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Smart Memory",
            "description": "Should ComfyUI smart memory be enabled."
          },
          "cache_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cache Type",
            "description": "The type of cache to use (classic, lru, none)."
          },
          "cache_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cache Size",
            "description": "How many node results to cache (when cache_type is lru)."
          },
          "vae_cpu": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Vae Cpu",
            "description": "Should VAE be decoded on the CPU or not."
          },
          "reserve_vram": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reserve Vram",
            "description": "Amount of VRAM in GB to reserve for use."
          }
        },
        "type": "object",
        "required": [
          "user_id",
          "worker_id",
          "worker_version",
          "last_seen",
          "tasks_to_give",
          "engine_details"
        ],
        "title": "WorkerDetails"
      },
      "WorkerDetailsDeviceRequest": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Full computing device name"
          },
          "type": {
            "type": "string",
            "title": "Type",
            "description": "Type of the device such as 'cuda' or 'cpu'",
            "default": ""
          },
          "index": {
            "type": "integer",
            "title": "Index",
            "description": "Computing device index",
            "default": 0
          },
          "vram_total": {
            "type": "integer",
            "title": "Vram Total",
            "description": "Total VRAM available on the device in bytes",
            "default": 0
          },
          "vram_free": {
            "type": "integer",
            "title": "Vram Free",
            "description": "Free VRAM available on the device in bytes",
            "default": 0
          },
          "torch_vram_total": {
            "type": "integer",
            "title": "Torch Vram Total",
            "description": "Total VRAM managed by PyTorch in bytes",
            "default": 0
          },
          "torch_vram_free": {
            "type": "integer",
            "title": "Torch Vram Free",
            "description": "Free VRAM managed by PyTorch in bytes",
            "default": 0
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "WorkerDetailsDeviceRequest",
        "description": "Provides detailed information about the computing device and memory status."
      },
      "WorkerDetailsRequest": {
        "properties": {
          "worker_version": {
            "type": "string",
            "title": "Worker Version",
            "description": "Version of the worker"
          },
          "pytorch_version": {
            "type": "string",
            "title": "Pytorch Version",
            "description": "Torch version used by the worker",
            "default": ""
          },
          "system": {
            "$ref": "#/components/schemas/WorkerDetailsSystemRequest"
          },
          "devices": {
            "items": {
              "$ref": "#/components/schemas/WorkerDetailsDeviceRequest"
            },
            "type": "array",
            "title": "Devices"
          },
          "ram_total": {
            "type": "integer",
            "title": "Ram Total",
            "description": "Total RAM on the worker in bytes",
            "default": 0
          },
          "ram_free": {
            "type": "integer",
            "title": "Ram Free",
            "description": "Free RAM on the worker in bytes",
            "default": 0
          },
          "last_seen": {
            "type": "string",
            "format": "date-time",
            "title": "Last Seen",
            "description": "Last seen time",
            "default": "2025-05-27T16:49:32.105128Z"
          },
          "engine_details": {
            "$ref": "#/components/schemas/ComfyEngineDetails"
          }
        },
        "type": "object",
        "required": [
          "worker_version",
          "system",
          "devices",
          "engine_details"
        ],
        "title": "WorkerDetailsRequest",
        "description": "Consolidates information relevant to a worker handling AI tasks."
      },
      "WorkerDetailsSystemRequest": {
        "properties": {
          "hostname": {
            "type": "string",
            "title": "Hostname",
            "description": "Hostname of the worker machine"
          },
          "os": {
            "type": "string",
            "title": "Os",
            "description": "Operating system type, e.g., 'posix', 'nt'"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Python version information"
          },
          "embedded_python": {
            "type": "boolean",
            "title": "Embedded Python",
            "description": "Flag indicating if Python is embedded (portable) or not"
          }
        },
        "type": "object",
        "required": [
          "hostname",
          "os",
          "version",
          "embedded_python"
        ],
        "title": "WorkerDetailsSystemRequest",
        "description": "Provides OS and Python environment details of the worker."
      },
      "WorkerSettingsRequest": {
        "properties": {
          "worker_id": {
            "type": "string",
            "title": "Worker Id",
            "description": "ID of the worker"
          },
          "tasks_to_give": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tasks To Give",
            "description": "List of tasks the worker should ask for."
          },
          "smart_memory": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Smart Memory",
            "description": "Should ComfyUI smart memory be enabled."
          },
          "cache_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cache Type",
            "description": "The type of cache to use (classic, lru, none)."
          },
          "cache_size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Cache Size",
            "description": "How many node results to cache (when cache_type is lru)."
          },
          "vae_cpu": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Vae Cpu",
            "description": "Should VAE be decoded on the CPU or not."
          },
          "reserve_vram": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reserve Vram",
            "description": "Amount of VRAM in GB to reserve for use."
          }
        },
        "type": "object",
        "required": [
          "worker_id"
        ],
        "title": "WorkerSettingsRequest",
        "description": "Custom settings available to be set dynamically for a worker."
      }
    }
  },
  "servers": [
    {
      "url": "http://localhost:8288",
      "description": "Default server running Visionatrix"
    }
  ]
}
</file>

<file path="entrypoint.sh">
#!/bin/sh
# Exit on error
set -e

# Run the user migration
echo "--- Running user migration ---"
node /app/dist/scripts/migrate-users-to-sqlite.js || echo "User migration completed or skipped"
echo "--- User migration check complete ---"

# Run the database migration
echo "--- Running database migration ---"
node /app/dist/scripts/migrate-json-to-sqlite.js || echo "Migration completed or skipped"
echo "--- Migration check complete ---"

# Run the new API key column migration
echo "--- Running API key column migration ---"
node /app/dist/scripts/add-api-key-columns-to-users.js || echo "API key column migration completed or skipped"
echo "--- API key column migration check complete ---"

# Run the new granular API key migration
echo "--- Running granular API key migration ---"
node /app/dist/scripts/add-granular-api-key-columns.js || echo "Granular API key migration completed or skipped"
echo "--- Granular API key migration check complete ---"

# Run the new API features migration
echo "--- Running API Features migration ---"
node /app/dist/scripts/migrate-api-features.js || echo "API features migration completed or skipped"
echo "--- API features migration check complete ---"

# Use PUID/PGID from environment, or default to 1000 (common for 'node' user in base images)
# Unraid should be passing PUID=99 and PGID=100
PUID_TO_USE=${PUID:-1000}
PGID_TO_USE=${PGID:-1000}

echo "--- Entrypoint ---"
echo "Effective PUID: $PUID_TO_USE"
echo "Effective PGID: $PGID_TO_USE"

# 1. Determine group name and ensure group exists with PGID_TO_USE
#    Check if a group already exists with the target PGID
EXISTING_GROUP_NAME=$(getent group "$PGID_TO_USE" | cut -d: -f1)

if [ -z "$EXISTING_GROUP_NAME" ]; then
    # PGID is free, create a new group named 'appgroup'
    TARGET_GROUP_NAME=appgroup
    echo "Creating new group '$TARGET_GROUP_NAME' with GID $PGID_TO_USE."
    addgroup -S -g "$PGID_TO_USE" "$TARGET_GROUP_NAME"
else
    # PGID is already in use by an existing group, use that existing group's name
    TARGET_GROUP_NAME="$EXISTING_GROUP_NAME"
    echo "Using existing group '$TARGET_GROUP_NAME' for GID $PGID_TO_USE."
fi

# 2. Determine user name and ensure user exists with PUID_TO_USE and is in TARGET_GROUP_NAME
#    Check if a user already exists with the target PUID
EXISTING_USER_NAME=$(getent passwd "$PUID_TO_USE" | cut -d: -f1)

if [ -z "$EXISTING_USER_NAME" ]; then
    # PUID is free, create a new user named 'appuser'
    TARGET_USER_NAME=appuser
    echo "Creating new user '$TARGET_USER_NAME' with UID $PUID_TO_USE and group '$TARGET_GROUP_NAME'."
    # -S: system user, -H: no home dir, -D: no password, -G: primary group
    adduser -S -H -D -u "$PUID_TO_USE" -G "$TARGET_GROUP_NAME" "$TARGET_USER_NAME"
else
    # PUID is already in use by an existing user, use that existing user's name
    TARGET_USER_NAME="$EXISTING_USER_NAME"
    echo "Using existing user '$TARGET_USER_NAME' for UID $PUID_TO_USE."

    # Ensure this existing user is effectively part of TARGET_GROUP_NAME
    # (it might be its primary group or need to be added as a supplementary group)
    CURRENT_PRIMARY_GID_OF_EXISTING_USER=$(getent passwd "$TARGET_USER_NAME" | cut -d: -f4)
    if [ "$CURRENT_PRIMARY_GID_OF_EXISTING_USER" != "$PGID_TO_USE" ]; then
        echo "User '$TARGET_USER_NAME' exists with primary GID $CURRENT_PRIMARY_GID_OF_EXISTING_USER."
        echo "Attempting to set primary group of '$TARGET_USER_NAME' to '$TARGET_GROUP_NAME' (GID $PGID_TO_USE)."
        # usermod can be risky if the user is a critical system user, but for app PUIDs it's usually fine.
        # The `|| true` prevents script exit if usermod fails (e.g. on root user)
        usermod -g "$PGID_TO_USE" "$TARGET_USER_NAME" || echo "Warning: usermod -g failed. This might be okay if already a member."

        # As a fallback or ensure, add to group if not already a member (primary or secondary)
        if ! id -Gn "$TARGET_USER_NAME" | grep -qw "$TARGET_GROUP_NAME"; then
            echo "Adding user '$TARGET_USER_NAME' to group '$TARGET_GROUP_NAME' as supplementary."
            addgroup "$TARGET_USER_NAME" "$TARGET_GROUP_NAME"
        fi
    else
        echo "User '$TARGET_USER_NAME' already has '$TARGET_GROUP_NAME' (GID $PGID_TO_USE) as primary group."
    fi
fi

echo "Final effective user: '$TARGET_USER_NAME' (UID $PUID_TO_USE)"
echo "Final effective group: '$TARGET_GROUP_NAME' (GID $PGID_TO_USE)"

# 3. Change ownership of application files *within the image*
#    Files copied during 'docker build' are owned by root.
#    The application (running as TARGET_USER_NAME) needs to access them.
#    DO NOT chown the volume mount point itself (/app/public/uploads) from here;
#    its permissions are managed on the host.
echo "Setting ownership for internal application files..."
if [ -d "/app/.next" ]; then
    chown -R "$TARGET_USER_NAME:$TARGET_GROUP_NAME" /app/.next
    echo "Owned /app/.next"
fi

# Set ownership for user_data directory for server-side history storage
if [ -d "/app/user_data" ]; then
    chown -R "$TARGET_USER_NAME:$TARGET_GROUP_NAME" /app/user_data
    echo "Owned /app/user_data (for server-side history storage)"
fi

# Add other directories here if your app uses them inside /app (not on a volume)
# e.g., if node_modules are bundled and need write access for some reason (uncommon for prod):
# if [ -d "/app/node_modules" ]; then
#   chown -R "$TARGET_USER_NAME:$TARGET_GROUP_NAME" /app/node_modules
#   echo "Owned /app/node_modules"
# fi
# If server.js or other specific files in /app need different ownership (usually read is enough for root-copied files)
# chown "$TARGET_USER_NAME:$TARGET_GROUP_NAME" /app/server.js # If needed

# 4. Execute the main container command (CMD) as the TARGET_USER_NAME
echo "Executing command: $@"
exec su-exec "$TARGET_USER_NAME:$TARGET_GROUP_NAME" "$@"
</file>

<file path="jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jest-environment-jsdom',
  setupFilesAfterEnv: ['@testing-library/jest-dom', '<rootDir>/jest.setup.js'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  transform: {
    '^.+\\.tsx?$': ['ts-jest', {
      tsconfig: 'tsconfig.jest.json',
    }],
    '^.+\\.jsx?$': ['babel-jest', {
      presets: ['next/babel']
    }],
  },
  transformIgnorePatterns: [
    "/node_modules/(?!lucide-react|recharts|d3-.*|internmap|delaunator|robust-predicates|@babel/runtime)/"
  ]
};
</file>

<file path="jest.setup.js">
require('whatwg-fetch');
</file>

<file path="next.config.ts">
// next.config.ts
import type {NextConfig} from 'next';

const nextConfig: NextConfig = {
  output: 'standalone',
  experimental: {
    serverActions: {
      bodySizeLimit: '50mb', // Increase limit for image uploads
    },  },images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'placehold.co',
      },
      {
        protocol: 'https',
        hostname: 'refashion.cc',
        pathname: '/**',
      },
      {
        protocol: 'https',
        hostname: 'v3.fal.media',
        pathname: '/**',
      },
      {
        protocol: 'http',
        hostname: '192.168.1.9',
        port: '3000',
        pathname: '/**',
      },
      {
        protocol: 'http',
        hostname: 'localhost',
        port: '3000',
        pathname: '/**',
      },
      {
        protocol: 'http',
        hostname: '0.0.0.0',
        port: '3000', 
        pathname: '/**',
      },
    ],
  },
  async redirects() {
    return [
      {
        source: '/',
        destination: '/create',
        permanent: true,
      },
    ];
  },
};

export default nextConfig;
</file>

<file path="package.json">
{
  "name": "nextn",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack -p 9002",
    "build": "next build && tsc --project tsconfig.scripts.json",
    "start": "next start",
    "lint": "next lint",
    "typecheck": "tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "migrate:json-to-sqlite": "node dist/scripts/migrate-json-to-sqlite.js",
    "migrate:users-to-sqlite": "node dist/scripts/migrate-users-to-sqlite.js",
    "migrate:granular-api-keys": "node dist/scripts/add-granular-api-key-columns.js",
    "script": "tsx"
  },
  "dependencies": {
    "@fal-ai/client": "^1.5.0",
    "@hookform/resolvers": "^4.1.3",
    "@radix-ui/react-accordion": "^1.2.11",
    "@radix-ui/react-alert-dialog": "^1.1.6",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-checkbox": "^1.1.4",
    "@radix-ui/react-dialog": "^1.1.14",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-menubar": "^1.1.6",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-progress": "^1.1.2",
    "@radix-ui/react-radio-group": "^1.2.3",
    "@radix-ui/react-scroll-area": "^1.2.9",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slider": "^1.2.3",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-toast": "^1.2.6",
    "@radix-ui/react-toggle-group": "^1.1.10",
    "@radix-ui/react-tooltip": "^1.1.8",
    "@types/better-sqlite3": "^7.6.13",
    "@types/mime-types": "^3.0.0",
    "axios": "^1.9.0",
    "bcrypt": "^5.1.1",
    "better-sqlite3": "^12.2.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^3.6.0",
    "dotenv": "^16.5.0",
    "form-data": "^4.0.2",
    "https-proxy-agent": "^7.0.6",
    "iron-session": "^8.0.4",
    "lucide-react": "^0.475.0",
    "mime-types": "^3.0.1",
    "motion": "^12.23.3",
    "next": "^15.3.3",
    "node-fetch": "^3.3.2",
    "react": "^18.3.1",
    "react-compare-image": "^3.5.6",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.54.2",
    "react-image-crop": "^11.0.10",
    "sharp": "^0.34.2",
    "tailwind-merge": "^3.0.1",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^10.0.0",
    "zod": "^3.24.2",
    "zustand": "^5.0.6"
  },
  "devDependencies": {
    "@babel/core": "^7.27.4",
    "@babel/preset-env": "^7.27.2",
    "@babel/preset-react": "^7.27.1",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.0.0",
    "@types/bcrypt": "^5.0.2",
    "@types/form-data": "^2.2.1",
    "@types/jest": "^29.5.14",
    "@types/node": "^20",
    "@types/node-fetch": "^2.6.12",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/uuid": "^10.0.0",
    "autoprefixer": "^10.4.21",
    "babel-jest": "^30.0.2",
    "eslint": "^9.28.0",
    "eslint-config-next": "^15.3.3",
    "genkit-cli": "^1.8.0",
    "jest": "^30.0.3",
    "jest-environment-jsdom": "^30.0.2",
    "postcss": "^8.5.4",
    "tailwindcss": "^3.4.17",
    "ts-jest": "^29.4.0",
    "typescript": "^5",
    "whatwg-fetch": "^3.6.20"
  },
  "overrides": {
    "glob": "^10.0.0",
    "rimraf": "^5.0.0",
    "inflight": false,
    "abab": false,
    "domexception": false,
    "node-domexception": false
  }
}
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="README.md">
# RefashionAI

RefashionAI is a Next.js application that uses AI to generate fashion model images wearing uploaded clothing items. It features background removal capabilities for better AI generation results.

## Features

- AI-powered fashion model image generation
- Background removal for clothing images using Visionatrix API
- User authentication and history tracking
- Multiple AI model support (Gemini API)
- Responsive web interface

## Environment Variables

### Required
```env
# Gemini API Keys (at least one required)
GEMINI_API_KEY_1=your_gemini_api_key_1
GEMINI_API_KEY_2=your_gemini_api_key_2
GEMINI_API_KEY_3=your_gemini_api_key_3

# Firebase Configuration
NEXT_PUBLIC_FIREBASE_API_KEY=your_firebase_api_key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your_project.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your_project_id
# ... other Firebase config
```

### Optional
```env
# Background Removal (Visionatrix API)
VISIONATRIX_API_URL=http://localhost:8288  # Default: localhost:8288
VISIONATRIX_USERNAME=admin                 # Default: admin
VISIONATRIX_PASSWORD=admin                 # Default: admin

# Docker Environment (for file permissions)
PUID=1000                                  # User ID
PGID=1000                                  # Group ID
```

## Background Removal Setup

The background removal feature uses the Visionatrix API. To enable it:

1. Set up a Visionatrix server instance
2. Configure the environment variables above
3. The feature will automatically become available when the API is accessible

The background removal toggle will appear in the upload section when the service is available.

## Getting Started

```bash
# Install dependencies
npm install

# Run development server
npm run dev
```

Open [http://localhost:9002](http://localhost:9002) to view the application.

## Project Structure

- `src/components/` - React components
- `src/ai/` - AI service integrations
- `src/actions/` - Server actions
- `public/uploads/` - File storage directory
- `user_data/` - User history data

## Docker Support

The application includes Docker support with proper file permissions for unRAID and similar environments.
</file>

<file path="scripts/add-api-key-columns-to-users.ts">
import { getDb } from '../src/services/database.service';

function addApiKeyColumns() {
  const db = getDb();
  console.log('Adding new API key columns to users table...');
  try {
    db.exec(`
      ALTER TABLE users
      ADD COLUMN api_key_mode TEXT CHECK(api_key_mode IN ('global', 'user')) NOT NULL DEFAULT 'global';
    `);
    console.log('Added api_key_mode column.');
  } catch (error) {
    if (error instanceof Error && error.message.includes('duplicate column name')) {
      console.log('api_key_mode column already exists.');
    } else {
      console.error('Error adding api_key_mode:', error);
      throw error;
    }
  }

  try {
    db.exec(`
      ALTER TABLE users
      ADD COLUMN gemini_api_key TEXT;
    `);
    console.log('Added gemini_api_key column.');
  } catch (error) {
    if (error instanceof Error && error.message.includes('duplicate column name')) {
      console.log('gemini_api_key column already exists.');
    } else {
      console.error('Error adding gemini_api_key:', error);
      throw error;
    }
  }

  try {
    db.exec(`
      ALTER TABLE users
      ADD COLUMN fal_api_key TEXT;
    `);
    console.log('Added fal_api_key column.');
  } catch (error) {
    if (error instanceof Error && error.message.includes('duplicate column name')) {
      console.log('fal_api_key column already exists.');
    } else {
      console.error('Error adding fal_api_key:', error);
      throw error;
    }
  }

  console.log('Finished adding new API key columns.');
}

addApiKeyColumns();
</file>

<file path="scripts/add-granular-api-key-columns.ts">
// scripts/add-granular-api-key-columns.ts
import { getDb } from '../src/services/database.service';

function runMigration() {
  const db = getDb();
  console.log('Running granular API key migration...');

  // --- START OF FIX ---
  // Idempotency Check: Verify if the migration has already run.
  try {
    const columns = db.pragma('table_info(users)') as Array<{ name: string }>;

    const hasNewColumn = columns.some((col: { name: string }) => col.name === 'gemini_api_key_1_mode');
    if (hasNewColumn) {
      console.log('Granular API key columns already exist. Migration not needed.');
      return; // Exit the script gracefully
    }
  } catch (e) {
    // This might happen if the users table doesn't exist yet, which is fine.
    console.log('Users table not found, proceeding with creation.');
  }
  // --- END OF FIX ---

  try {
    // We will build a new table and copy data, as altering tables in SQLite is limited.
    db.exec('BEGIN TRANSACTION;');

    // 1. Rename the old users table
    db.exec('ALTER TABLE users RENAME TO users_old;');
    console.log('Renamed original users table to users_old.');

    // 2. Create the new users table with the correct schema
    db.exec(`
      CREATE TABLE users (
        username TEXT PRIMARY KEY,
        password_hash TEXT NOT NULL,
        role TEXT NOT NULL CHECK (role IN ('admin', 'user')),
        gemini_api_key_1 TEXT,
        gemini_api_key_1_mode TEXT NOT NULL DEFAULT 'global' CHECK (gemini_api_key_1_mode IN ('global', 'user_specific')),
        gemini_api_key_2 TEXT,
        gemini_api_key_2_mode TEXT NOT NULL DEFAULT 'global' CHECK (gemini_api_key_2_mode IN ('global', 'user_specific')),
        gemini_api_key_3 TEXT,
        gemini_api_key_3_mode TEXT NOT NULL DEFAULT 'global' CHECK (gemini_api_key_3_mode IN ('global', 'user_specific')),
        fal_api_key TEXT,
        fal_api_key_mode TEXT NOT NULL DEFAULT 'global' CHECK (fal_api_key_mode IN ('global', 'user_specific'))
      );
    `);
    console.log('Created new users table with granular API key columns.');

    // 3. Copy data from the old table to the new one
    db.exec(`
      INSERT INTO users (
        username, password_hash, role, 
        gemini_api_key_1, fal_api_key,
        gemini_api_key_1_mode, fal_api_key_mode
      )
      SELECT 
        username, password_hash, role, 
        gemini_api_key, fal_api_key,
        CASE WHEN api_key_mode = 'user' THEN 'user_specific' ELSE 'global' END,
        CASE WHEN api_key_mode = 'user' THEN 'user_specific' ELSE 'global' END
      FROM users_old;
    `);
    console.log('Copied data from old table to new table, preserving API key mode.');

    // 4. Drop the old table
    db.exec('DROP TABLE users_old;');
    console.log('Dropped old users table.');

    // 5. Add new global settings
    db.exec(`
      INSERT OR IGNORE INTO settings (key, value) VALUES 
        ('global_gemini_api_key_1', ''),
        ('global_gemini_api_key_2', ''),
        ('global_gemini_api_key_3', '');
    `);
    // Remove old single global key if it exists
    db.exec(`DELETE FROM settings WHERE key = 'global_gemini_api_key';`);
    console.log('Added new global API key settings.');

    db.exec('COMMIT;');
    console.log('Migration completed successfully.');

  } catch (error) {
    db.exec('ROLLBACK;');
    console.error('Migration failed:', error);
    throw error;
  }
}

// This construct ensures the script can be run directly
if (require.main === module) {
    runMigration();
}

export { runMigration };
</file>

<file path="scripts/cleanup-cache.js">
#!/usr/bin/env node

/**
 * Cache cleanup script for RefashionAI
 * 
 * This script cleans up old cached image processing results to prevent
 * the cache from growing indefinitely. It can be run manually or as a cron job.
 * 
 * Usage: node scripts/cleanup-cache.js [--max-age-days=30]
 */

const path = require('path');
const fs = require('fs').promises;

const DEFAULT_MAX_AGE_DAYS = 30;

async function cleanupCache(maxAgeDays = DEFAULT_MAX_AGE_DAYS) {
  const cacheFilePath = path.join(process.cwd(), '.cache', 'image-processing-cache.json');
  const maxAgeMs = maxAgeDays * 24 * 60 * 60 * 1000;

  try {
    console.log(`Starting cache cleanup (max age: ${maxAgeDays} days)...`);
    
    // Read the cache file
    let cache = {};
    try {
      const data = await fs.readFile(cacheFilePath, 'utf-8');
      cache = JSON.parse(data);
    } catch (error) {
      if (error.code === 'ENOENT') {
        console.log('Cache file does not exist. Nothing to clean up.');
        return;
      }
      throw error;
    }

    const now = Date.now();
    let removedCount = 0;
    let totalCount = Object.keys(cache).length;

    // Clean up old entries
    for (const [hash, entry] of Object.entries(cache)) {
      if (entry.timestamp && (now - entry.timestamp) > maxAgeMs) {
        // Try to delete associated files
        for (const [type, filePath] of Object.entries(entry)) {
          if (type !== 'timestamp' && typeof filePath === 'string') {
            try {
              const fullPath = path.join(process.cwd(), 'public', filePath);
              await fs.unlink(fullPath);
              console.log(`Deleted cached file: ${filePath}`);
            } catch (fileError) {
              console.warn(`Could not delete file ${filePath}:`, fileError.message);
            }
          }
        }
        
        delete cache[hash];
        removedCount++;
      }
    }

    // Write the updated cache back
    if (removedCount > 0) {
      await fs.mkdir(path.dirname(cacheFilePath), { recursive: true });
      await fs.writeFile(cacheFilePath, JSON.stringify(cache, null, 2));
      console.log(`Cache cleanup completed. Removed ${removedCount} of ${totalCount} entries.`);
    } else {
      console.log(`Cache cleanup completed. No entries were old enough to remove (${totalCount} entries remain).`);
    }

  } catch (error) {
    console.error('Error during cache cleanup:', error);
    process.exit(1);
  }
}

// Parse command line arguments
const args = process.argv.slice(2);
let maxAgeDays = DEFAULT_MAX_AGE_DAYS;

for (const arg of args) {
  if (arg.startsWith('--max-age-days=')) {
    maxAgeDays = parseInt(arg.split('=')[1], 10);
    if (isNaN(maxAgeDays) || maxAgeDays <= 0) {
      console.error('Invalid max-age-days value. Must be a positive number.');
      process.exit(1);
    }
  } else if (arg === '--help' || arg === '-h') {
    console.log('Usage: node scripts/cleanup-cache.js [--max-age-days=30]');
    console.log('');
    console.log('Options:');
    console.log('  --max-age-days=N    Remove cache entries older than N days (default: 30)');
    console.log('  --help, -h          Show this help message');
    process.exit(0);
  } else {
    console.error(`Unknown argument: ${arg}`);
    console.error('Use --help for usage information.');
    process.exit(1);
  }
}

// Run the cleanup
cleanupCache(maxAgeDays);
</file>

<file path="scripts/migrate-api-features.ts">
// scripts/migrate-api-features.ts
import { getDb } from '../src/services/database.service';

function runApiMigration() {
  const db = getDb();
  console.log('Running API features migration...');

  // Add status and error columns to the history table
  try {
    db.exec(`
      ALTER TABLE history ADD COLUMN status TEXT NOT NULL DEFAULT 'completed';
    `);
    console.log('Added "status" column to history table.');
  } catch (e) {
    if ((e as Error).message.includes('duplicate column name')) {
      console.log('Column "status" already exists. Skipping.');
    } else { throw e; }
  }

  try {
    db.exec(`
      ALTER TABLE history ADD COLUMN error TEXT;
    `);
    console.log('Added "error" column to history table.');
  } catch (e) {
    if ((e as Error).message.includes('duplicate column name')) {
      console.log('Column "error" already exists. Skipping.');
    } else { throw e; }
  }
  
  // Add app_api_key column to the users table
  try {
    db.exec(`
      ALTER TABLE users ADD COLUMN app_api_key TEXT;
    `);
    console.log('Added "app_api_key" column to users table.');
  } catch (e) {
    if ((e as Error).message.includes('duplicate column name')) {
      console.log('Column "app_api_key" already exists. Skipping.');
    } else { throw e; }
  }

  // Add unique constraint to app_api_key if it doesn't exist
  try {
    db.exec(`
      CREATE UNIQUE INDEX IF NOT EXISTS idx_users_app_api_key ON users(app_api_key) WHERE app_api_key IS NOT NULL;
    `);
    console.log('Added unique constraint to "app_api_key" column.');
  } catch (e) {
    console.log('Unique constraint may already exist. Skipping.');
  }

  console.log('API features migration finished.');
}

if (require.main === module) {
  runApiMigration();
}
</file>

<file path="scripts/migrate-json-to-sqlite.ts">
#!/usr/bin/env node

/**
 * Migration script to move from JSON file-based history storage to SQLite
 * 
 * Usage: npm run migrate:json-to-sqlite
 * 
 * This script:
 * 1. Backs up existing JSON files
 * 2. Migrates all user history data to SQLite
 * 3. Verifies the migration was successful
 * 4. Moves JSON files to backup folder
 */

import fs from 'fs';
import path from 'path';
import type { HistoryItem } from '../src/lib/types';
import * as dbService from '../src/services/database.service';

const JSON_HISTORY_DIR = path.join(process.cwd(), 'user_data', 'history');
const BACKUP_DIR = path.join(process.cwd(), 'user_data', 'history_json_backup');

async function migrate() {
  console.log('🚀 Starting migration from JSON to SQLite...\n');
  
  try {
    // 1. Ensure directories exist
    if (!fs.existsSync(JSON_HISTORY_DIR)) {
      console.log('❌ No JSON history directory found. Nothing to migrate.');
      return;
    }
    
    if (!fs.existsSync(BACKUP_DIR)) {
      fs.mkdirSync(BACKUP_DIR, { recursive: true });
      console.log('📁 Created backup directory');
    }
    
    // 2. Get all JSON files
    const files = fs.readdirSync(JSON_HISTORY_DIR).filter(file => file.endsWith('.json'));
    
    if (files.length === 0) {
      console.log('❌ No JSON history files found. Nothing to migrate.');
      return;
    }
    
    console.log(`📊 Found ${files.length} user history files to migrate\n`);
    
    // 3. Initialize database connection
    const db = dbService.getDb();
    console.log('✅ Database connection established\n');
    
    let totalItemsMigrated = 0;
    let totalUsers = 0;
    
    // 4. Migrate each user's history
    for (const file of files) {
      const username = path.basename(file, '.json');
      const filePath = path.join(JSON_HISTORY_DIR, file);
      
      try {
        console.log(`👤 Processing user: ${username}`);
        
        // Read and parse JSON file
        const content = fs.readFileSync(filePath, 'utf-8');
        let historyItems: HistoryItem[];
        
        try {
          historyItems = JSON.parse(content);
        } catch (parseError) {
          console.log(`  ⚠️  Failed to parse JSON for ${username}: ${parseError}`);
          continue;
        }
        
        if (!Array.isArray(historyItems)) {
          console.log(`  ⚠️  Invalid history format for ${username} (not an array)`);
          continue;
        }
        
        console.log(`  📝 Found ${historyItems.length} history items`);
        
        // Insert each history item
        let userItemsInserted = 0;
        for (const item of historyItems) {
          try {
            // Validate required fields
            if (!item.id || !item.username || !item.timestamp) {
              console.log(`  ⚠️  Skipping invalid history item (missing required fields)`);
              continue;
            }
            
            // Ensure username matches filename
            if (item.username !== username) {
              item.username = username; // Fix username mismatch
            }
            
            dbService.insertHistoryItem(item);
            userItemsInserted++;
          } catch (insertError) {
            console.log(`  ⚠️  Failed to insert history item ${item.id}: ${insertError}`);
          }
        }
        
        console.log(`  ✅ Migrated ${userItemsInserted}/${historyItems.length} items for ${username}`);
        totalItemsMigrated += userItemsInserted;
        totalUsers++;
        
        // Verify migration for this user
        const migratedItems = dbService.findHistoryByUsername(username);
        if (migratedItems.length !== userItemsInserted) {
          console.log(`  ⚠️  Verification failed: Expected ${userItemsInserted}, found ${migratedItems.length}`);
        } else {
          console.log(`  ✅ Verification passed for ${username}`);
        }
        
      } catch (error) {
        console.log(`  ❌ Error processing ${username}: ${error}`);
      }
      
      console.log(''); // Empty line for readability
    }
    
    console.log(`\n🎉 Migration Summary:`);
    console.log(`   Users migrated: ${totalUsers}`);
    console.log(`   Total items migrated: ${totalItemsMigrated}`);
    
    // 5. Move JSON files to backup after successful migration
    if (totalItemsMigrated > 0) {
      console.log('\n📦 Moving JSON files to backup...');
      
      for (const file of files) {
        const sourcePath = path.join(JSON_HISTORY_DIR, file);
        const backupPath = path.join(BACKUP_DIR, file);
        
        try {
          fs.renameSync(sourcePath, backupPath);
          console.log(`   ✅ Backed up: ${file}`);
        } catch (error) {
          console.log(`   ⚠️  Failed to backup ${file}: ${error}`);
        }
      }
      
      console.log('\n✅ Migration completed successfully!');
      console.log(`📁 Original JSON files backed up to: ${BACKUP_DIR}`);
      console.log(`🗄️  SQLite database created at: user_data/history/history.db`);
    } else {
      console.log('\n❌ No items were migrated. JSON files remain in place.');
    }
    
  } catch (error) {
    console.error('\n💥 Migration failed:', error);
    process.exit(1);
  }
}

// Additional verification function
async function verifyMigration() {
  console.log('\n🔍 Running post-migration verification...');
  
  try {
    const paginatedHistory = dbService.getAllUsersHistoryPaginated(1, 1000);
    const usernames = [...new Set(paginatedHistory.items.map(item => item.username))];
    
    console.log(`\n📊 Verification Results:`);
    console.log(`   Total items: ${paginatedHistory.totalCount}`);
    console.log(`   Total users: ${usernames.length}`);
    for (const username of usernames) {
      const userItems = paginatedHistory.items.filter(item => item.username === username);
      console.log(`   - ${username}: ${userItems.length} items`);
    }
    
    console.log(`\n✅ Total verification: ${usernames.length} users, ${paginatedHistory.totalCount} items in database`);
    
  } catch (error) {
    console.error('❌ Verification failed:', error);
  }
}

// Main execution
if (require.main === module) {
  migrate()
    .then(() => verifyMigration())
    .then(() => {
      console.log('\n🏁 Migration and verification complete!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('\n💥 Fatal error:', error);
      process.exit(1);
    });
}

export { migrate, verifyMigration };
</file>

<file path="scripts/migrate-users-to-sqlite.ts">
// scripts/migrate-users-to-sqlite.ts
import fs from 'fs';
import path from 'path';
import bcrypt from 'bcrypt';
import * as dbService from '../src/services/database.service';

// Load environment variables from .env file
import dotenv from 'dotenv';
dotenv.config();

const SALT_ROUNDS = 12;

// Define legacy types here as they are only used for this migration script.
interface UserConfig {
  password: string;
  role: 'admin' | 'user';
}
interface UsersConfig {
  [username: string]: UserConfig;
}

async function migrateUsers() {
  console.log('🚀 Starting user migration from APP_USERS_CONFIG to SQLite...');

  const rawConfig = process.env.APP_USERS_CONFIG;
  if (!rawConfig) {
    console.log('✅ No APP_USERS_CONFIG found. Skipping user migration.');
    return;
  }

  try {
    const usersConfig: UsersConfig = JSON.parse(rawConfig);
    const db = dbService.getDb();
    const insertStmt = db.prepare('INSERT OR IGNORE INTO users (username, password_hash, role) VALUES (?, ?, ?)');
    
    let migratedCount = 0;
    for (const [username, config] of Object.entries(usersConfig)) {
      // Check if user already exists
      const existingUser = dbService.findUserByUsername(username);
      if (existingUser) {
        console.log(`  - User '${username}' already exists in DB. Skipping.`);
        continue;
      }

      console.log(`  - Migrating user: ${username}`);
      const hashedPassword = await bcrypt.hash(config.password, SALT_ROUNDS);
      insertStmt.run(username, hashedPassword, config.role);
      migratedCount++;
    }

    if (migratedCount > 0) {
        console.log(`\n🎉 Successfully migrated ${migratedCount} users to the database.`);
        console.log('IMPORTANT: You can now remove the APP_USERS_CONFIG environment variable.');
    } else {
        console.log('\n✅ No new users to migrate.');
    }

  } catch (error) {
    console.error('💥 User migration failed:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  migrateUsers()
    .then(() => {
      console.log('🏁 User migration check complete!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('\n💥 Fatal error during user migration:', error);
      process.exit(1);
    });
}
</file>

<file path="scripts/README.md">
# Scripts Directory

This directory contains utility scripts for the Refashion App project.

## Utility Scripts

- **cleanup-cache.js** - Cleans up old cached image processing results to prevent unlimited cache growth
  ```bash
  # Clean up cache entries older than 30 days (default)
  node scripts/cleanup-cache.js
  
  # Clean up cache entries older than 7 days
  node scripts/cleanup-cache.js --max-age-days=7
  
  # Show help
  node scripts/cleanup-cache.js --help
  ```
</file>

<file path="src/actions/adminActions.ts">
// src/actions/adminActions.ts
'use server';

import { revalidatePath } from 'next/cache';
import * as dbService from '@/services/database.service';
import { getCurrentUser } from './authActions';
import bcrypt from 'bcrypt';
import fs from 'fs/promises';
import path from 'path';
import * as settingsService from '@/services/settings.service';
import { encrypt } from '@/services/encryption.service';
import crypto from 'crypto';

const SALT_ROUNDS = 12;

async function verifyAdmin() {
  const user = await getCurrentUser();
  if (!user || user.role !== 'admin') {
    throw new Error('Unauthorized: Admin access required.');
  }
  return user;
}

export async function getAllUsers() {
  await verifyAdmin();
  const db = dbService.getDb();
  const stmt = db.prepare('SELECT username, role, gemini_api_key_1_mode, gemini_api_key_2_mode, gemini_api_key_3_mode, fal_api_key_mode FROM users ORDER BY username');
  return stmt.all() as any[]; // Simplified for brevity, define a proper type
}

export async function createUser(formData: FormData) {
  const admin = await verifyAdmin();
  const username = formData.get('username') as string;
  const password = formData.get('password') as string;
  const role = formData.get('role') as 'admin' | 'user';

  if (!username || !password || !role) {
    return { success: false, error: 'All fields are required.' };
  }

  if (admin.username === username) {
    return { success: false, error: "You cannot create a user with your own username." };
  }
  
  try {
    const db = dbService.getDb();
    const existingUser = dbService.findUserByUsername(username);
    if (existingUser) {
      return { success: false, error: 'Username already exists.' };
    }

    const passwordHash = await bcrypt.hash(password, SALT_ROUNDS);
    const stmt = db.prepare('INSERT INTO users (username, password_hash, role) VALUES (?, ?, ?)');
    stmt.run(username, passwordHash, role);

    revalidatePath('/admin/users');
    return { success: true };
  } catch (error) {
    console.error('Error creating user:', error);
    return { success: false, error: 'Database error occurred.' };
  }
}

export async function deleteUser(username: string) {
  const admin = await verifyAdmin();
  
  if (admin.username === username) {
    return { success: false, error: "You cannot delete your own account." };
  }

  try {
    const db = dbService.getDb();
    const stmt = db.prepare('DELETE FROM users WHERE username = ?');
    const result = stmt.run(username);

    if (result.changes === 0) {
        return { success: false, error: "User not found." };
    }

    revalidatePath('/admin/users');
    return { success: true };
  } catch (error) {
    console.error('Error deleting user:', error);
    return { success: false, error: 'Database error occurred.' };
  }
}

export async function getAllSettings() {
  await verifyAdmin();
  return settingsService.getAllSettings();
}

export async function updateSetting(key: settingsService.SettingKey, value: boolean) {
  await verifyAdmin();
  try {
    settingsService.setSetting(key, value.toString());
    revalidatePath('/admin/settings');
    revalidatePath('/', 'layout');
    return { success: true };
  } catch (error) {
    console.error(`Error updating setting ${key}:`, error);
    return { success: false, error: 'Failed to update setting.' };
  }
}

export async function triggerCacheCleanup() {
  await verifyAdmin();
  try {
    const cacheFilePath = path.join(process.cwd(), '.cache', 'image-processing-cache.json');
    const maxAgeMs = 30 * 24 * 60 * 60 * 1000; // 30 days

    let cache: Record<string, any> = {};
    try {
      const data = await fs.readFile(cacheFilePath, 'utf-8');
      cache = JSON.parse(data);
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        return { success: true, message: 'Cache file does not exist. Nothing to clean up.' };
      }
      throw error;
    }

    const now = Date.now();
    let removedCount = 0;
    const initialCount = Object.keys(cache).length;

    for (const [hash, entry] of Object.entries(cache)) {
      if (entry.timestamp && (now - entry.timestamp) > maxAgeMs) {
        delete cache[hash];
        removedCount++;
      }
    }

    if (removedCount > 0) {
      await fs.writeFile(cacheFilePath, JSON.stringify(cache, null, 2));
      return { success: true, message: `Cache cleanup complete. Removed ${removedCount} of ${initialCount} entries.` };
    } else {
      return { success: true, message: `Cache is clean. No entries were old enough to remove (${initialCount} entries remain).` };
    }
  } catch (error) {
    console.error('Error during cache cleanup from admin panel:', error);
    return { success: false, error: 'Cache cleanup failed.' };
  }
}

export async function updateUserConfiguration(formData: FormData) {
  await verifyAdmin();
  const username = formData.get('username') as string;
  if (!username) {
    return { success: false, error: 'Username is required.' };
  }

  // Dynamically build the update statement only from present fields
  const setClauses: string[] = [];
  const params: any[] = [];

  const role = formData.get('role');
  if (role) { setClauses.push('role = ?'); params.push(role); }

  const gemini1Mode = formData.get('gemini_api_key_1_mode');
  if (gemini1Mode) { setClauses.push('gemini_api_key_1_mode = ?'); params.push(gemini1Mode); }
  const gemini2Mode = formData.get('gemini_api_key_2_mode');
  if (gemini2Mode) { setClauses.push('gemini_api_key_2_mode = ?'); params.push(gemini2Mode); }
  const gemini3Mode = formData.get('gemini_api_key_3_mode');
  if (gemini3Mode) { setClauses.push('gemini_api_key_3_mode = ?'); params.push(gemini3Mode); }
  const falMode = formData.get('fal_api_key_mode');
  if (falMode) { setClauses.push('fal_api_key_mode = ?'); params.push(falMode); }

  // Handle optional API keys. Update if the field was submitted (even if empty, to allow clearing)
  if (formData.has('gemini_api_key_1')) { setClauses.push('gemini_api_key_1 = ?'); params.push(encrypt(formData.get('gemini_api_key_1') as string)); }
  if (formData.has('gemini_api_key_2')) { setClauses.push('gemini_api_key_2 = ?'); params.push(encrypt(formData.get('gemini_api_key_2') as string)); }
  if (formData.has('gemini_api_key_3')) { setClauses.push('gemini_api_key_3 = ?'); params.push(encrypt(formData.get('gemini_api_key_3') as string)); }
  if (formData.has('fal_api_key')) { setClauses.push('fal_api_key = ?'); params.push(encrypt(formData.get('fal_api_key') as string)); }

  if (setClauses.length === 0) {
    return { success: true, message: 'No changes submitted.' };
  }

  try {
    const db = dbService.getDb();
    params.push(username); // For the WHERE clause
    const sql = `UPDATE users SET ${setClauses.join(', ')} WHERE username = ?`;
    const stmt = db.prepare(sql);
    stmt.run(...params);
    revalidatePath('/admin/users');
    return { success: true };
  } catch (error) {
    console.error(`Error updating configuration for user ${username}:`, error);
    return { success: false, error: 'Database error occurred during update.' };
  }
}

export async function updateEncryptedSetting(key: settingsService.SettingKey, value: string) {
  await verifyAdmin();
  try {
    const encryptedValue = value ? encrypt(value) : '';
    settingsService.setSetting(key, encryptedValue);
    revalidatePath('/admin/settings');
    return { success: true };
  } catch (error) {
    console.error(`Error updating encrypted setting ${key}:`, error);
    return { success: false, error: 'Failed to update setting.' };
  }
}

export async function getGlobalApiKeysForDisplay() {
  const settings = settingsService.getAllSettings();
  const { decrypt } = await import('@/services/encryption.service');
  const mask = (key: string) => key ? `••••••••••••${key.slice(-4)}` : 'Not Set';
  return {
    gemini1: mask(decrypt(settings.global_gemini_api_key_1)),
    gemini2: mask(decrypt(settings.global_gemini_api_key_2)),
    gemini3: mask(decrypt(settings.global_gemini_api_key_3)),
    fal: mask(decrypt(settings.global_fal_api_key)),
  };
}

export async function generateApiKeyForUser(username: string): Promise<{ success: boolean; apiKey?: string; error?: string }> {
  await verifyAdmin();

  try {
    const db = dbService.getDb();
    const apiKey = `rf_${crypto.randomBytes(24).toString('hex')}`;
    
    const stmt = db.prepare('UPDATE users SET app_api_key = ? WHERE username = ?');
    const result = stmt.run(apiKey, username);

    if (result.changes === 0) {
      return { success: false, error: 'User not found.' };
    }
    
    revalidatePath('/admin/users');
    return { success: true, apiKey };

  } catch (error) {
    console.error(`Error generating API key for ${username}:`, error);
    return { success: false, error: 'Database error occurred.' };
  }
}
</file>

<file path="src/actions/apiActions.ts">
// src/actions/apiActions.ts
'use server';

import { generateImageEdit } from "@/ai/flows/generate-image-edit";
import { addHistoryItem, updateHistoryItem } from "./historyActions";
import type { ModelAttributes } from "@/lib/types";

interface ApiJobPayload {
  username: string;
  imageDataUri: string;
  parameters: ModelAttributes;
  settingsMode: 'basic' | 'advanced';
}

/**
 * Creates a new job record in the database with a 'processing' status.
 * @returns The new job ID (which is a history_id).
 */
export async function createApiJob(payload: ApiJobPayload): Promise<string> {
  const { username, parameters, imageDataUri, settingsMode } = payload;
  const newHistoryId = await addHistoryItem(
    parameters,
    "Job created via API. Prompt to be generated.", // Placeholder prompt
    imageDataUri, // Using this as the original clothing URL
    [], // No edited images yet
    settingsMode,
    'processing', // Initial status
    undefined,    // No error
    username      // Pass the authenticated username from API key
  );
  return newHistoryId;
}

/**
 * This function is designed to be called without 'await'.
 * It runs the full generation and updates the DB record upon completion or failure.
 */
export async function processApiGenerationJob(jobId: string, payload: Omit<ApiJobPayload, 'username'>, username: string): Promise<void> {
  try {
    const result = await generateImageEdit({ 
      parameters: payload.parameters,
      settingsMode: payload.settingsMode,
      imageDataUriOrUrl: payload.imageDataUri 
    }, username);

    // Update history item with results AND the constructed prompt
    await updateHistoryItem(jobId, {
      editedImageUrls: result.editedImageUrls,
      constructedPrompt: result.constructedPrompt,
      status: 'completed',
    }, username);
    console.log(`API Job ${jobId} completed successfully.`);

  } catch (e) {
    console.error(`API Job ${jobId} failed:`, e);
    // Update history item with error status
    await updateHistoryItem(jobId, { status: 'failed', error: (e as Error).message }, username);
  }
}
</file>

<file path="src/actions/authActions.ts">
// authActions.ts
'use server';

import { getIronSession } from 'iron-session';
import { cookies } from 'next/headers';
import { redirect } from 'next/navigation';
import { revalidatePath } from 'next/cache';
import { sessionOptions } from '@/lib/session';
import type { SessionUser, SessionData } from '@/lib/types';
import * as dbService from '@/services/database.service';
import bcrypt from 'bcrypt';
// ... other imports

export async function loginUser(formData: FormData): Promise<{ error: string } | undefined> {
  const session = await getIronSession<SessionData>(await cookies(), sessionOptions);
  const username = formData.get('username') as string;
  const submittedPassword = formData.get('password') as string;

  try {
    const user = dbService.findUserByUsername(username);

    if (user && (await bcrypt.compare(submittedPassword, user.passwordHash))) {
      // Save session and prepare for redirect
      session.user = {
        username: username,
        role: user.role,
        isLoggedIn: true,
      };
      await session.save();
      revalidatePath('/', 'layout');
      
      // Only redirect after successful login and session save
      redirect('/');
    } else {
      return { error: 'Invalid username or password.' };
    }
  } catch (error) {
    // Re-throw redirect errors so they can work properly (this is expected behavior)
    if (error instanceof Error && (
      error.message === 'NEXT_REDIRECT' || 
      (error as any).digest?.startsWith('NEXT_REDIRECT')
    )) {
      throw error; // This is normal and expected
    }
    
    // Handle actual errors
    console.error("Login action error:", error instanceof Error ? error.message : String(error));
    return { error: 'An unexpected server error occurred.' };
  }
}

export async function logoutUser() {
  const session = await getIronSession<SessionData>(await cookies(), sessionOptions);
  session.destroy();
  revalidatePath('/', 'layout'); // CHANGED: Also revalidate layout on logout
  redirect('/login');
}

export async function getCurrentUser(): Promise<SessionUser | null> {
  try {
    // Added logging to see what getCurrentUser sees
    console.log("[getCurrentUser] Attempting to fetch current user session.");
    
    // Ensure we have access to cookies (this forces dynamic rendering)
    const cookieStore = await cookies();
    const session = await getIronSession<SessionData>(cookieStore, sessionOptions);
    
    if (session.user?.isLoggedIn) {
      console.log("[getCurrentUser] User found in session:", session.user.username);
      return session.user;
    }
    console.log("[getCurrentUser] No logged-in user found in session.");
    return null;
  } catch (error) {
    // Handle cases where cookies might not be available (e.g., during build)
    console.warn("[getCurrentUser] Failed to access session:", error instanceof Error ? error.message : String(error));
    return null;
  }
}
</file>

<file path="src/actions/historyActions.ts">
'use server';

import { getCurrentUser } from './authActions';
import type { HistoryItem, ModelAttributes } from '@/lib/types';
import * as dbService from '@/services/database.service';

export async function updateHistoryItem(
  historyItemId: string,
  updates: Partial<HistoryItem>,
  username?: string // NEW optional username parameter for API context
): Promise<{ success: boolean; error?: string }> {
  const user = username ? { username } : await getCurrentUser();
  if (!user || !user.username) {
    return { success: false, error: 'User not authenticated or username not provided' };
  }

  try {
    // Verify the item exists and belongs to the user
    const existingItem = dbService.findHistoryItemById(historyItemId);
    if (!existingItem) {
      return { success: false, error: 'History item not found' };
    }
    
    if (existingItem.username !== user.username) {
      return { success: false, error: 'Unauthorized access to history item' };
    }

    // Perform the atomic update
    dbService.updateHistoryItem(historyItemId, updates);
    return { success: true };
  } catch (error) {
    return { success: false, error: (error as Error).message };
  }
}

export async function getUserHistory(): Promise<HistoryItem[]> {
  const user = await getCurrentUser();
  if (!user) {
    throw new Error('User not authenticated');
  }
  
  return dbService.findHistoryByUsername(user.username);
}

export async function getUserHistoryPaginated(
  page: number = 1, 
  limit: number = 10,
  filter?: 'video' | 'image'
): Promise<{
  items: HistoryItem[];
  totalCount: number;
  hasMore: boolean;
  currentPage: number;
}> {
  const user = await getCurrentUser();
  if (!user) {
    throw new Error('User not authenticated');
  }
  
  return dbService.getPaginatedHistoryForUser({
    username: user.username,
    page,
    limit,
    filter
  });
}

export async function addHistoryItem(
  attributes: ModelAttributes,
  constructedPrompt: string,
  originalClothingUrl: string,
  editedImageUrls: (string | null)[],
  settingsMode: 'basic' | 'advanced',
  status: 'processing' | 'completed' | 'failed' = 'completed',
  error?: string,
  username?: string // NEW optional username parameter for API context
): Promise<string> {
  const user = username ? { username } : await getCurrentUser();
  if (!user || !user.username) {
    throw new Error('User not authenticated or username not provided.');
  }
  
  const newItem: HistoryItem = {
    id: crypto.randomUUID(),
    timestamp: Date.now(),
    attributes,
    constructedPrompt,
    originalClothingUrl,
    editedImageUrls,
    username: user.username,
    settingsMode,
    status,
    error
  };
  
  dbService.insertHistoryItem(newItem);
  return newItem.id;
}

export async function addVideoToHistoryItem(
  historyItemId: string,
  videoUrls: (string | null)[],
  videoGenerationParams: HistoryItem['videoGenerationParams']
): Promise<void> {
  if (!videoGenerationParams) {
    throw new Error("videoGenerationParams are required");
  }
  
  const user = await getCurrentUser();
  if (!user) {
    throw new Error('User not authenticated');
  }
  
  // Verify the item exists and belongs to the user
  const existingItem = dbService.findHistoryItemById(historyItemId);
  if (!existingItem) {
    throw new Error('History item not found');
  }
  
  if (existingItem.username !== user.username) {
    throw new Error('Unauthorized access to history item');
  }

  // Update the history item with video information
  dbService.updateHistoryItem(historyItemId, {
    generatedVideoUrls: videoUrls,
    videoGenerationParams
  });
}

export async function addStandaloneVideoHistoryItem(
  videoUrls: (string | null)[],
  videoGenerationParams: HistoryItem['videoGenerationParams']
): Promise<string> {
  if (!videoGenerationParams) {
    throw new Error("videoGenerationParams are required for standalone video history.");
  }
  
  const user = await getCurrentUser();
  if (!user) {
    throw new Error('User not authenticated');
  }

  // For standalone video, store the source image in originalImageUrls, not editedImageUrls
  const newItem: HistoryItem = {
    id: crypto.randomUUID(),
    timestamp: Date.now(),
    attributes: {} as ModelAttributes, // Empty attributes for video-only items
    constructedPrompt: videoGenerationParams.prompt,
    originalClothingUrl: videoGenerationParams.sourceImageUrl,
    editedImageUrls: [null, null, null, null], // No generated images for standalone video
    originalImageUrls: [videoGenerationParams.sourceImageUrl, null, null, null],
    username: user.username,
    settingsMode: 'basic',
    generatedVideoUrls: videoUrls,
    videoGenerationParams
  };

  dbService.insertHistoryItem(newItem);
  return newItem.id;
}

export async function getAllUsersHistoryPaginatedForAdmin(
  page: number = 1, 
  limit: number = 10
): Promise<{
  items: HistoryItem[];
  totalCount: number;
  hasMore: boolean;
  currentPage: number;
}> {
  const user = await getCurrentUser();
  if (!user || user.role !== 'admin') {
    throw new Error('Admin access required');
  }
  
  return dbService.getAllUsersHistoryPaginated(page, limit);
}

export async function deleteHistoryItem(historyItemId: string): Promise<{ success: boolean; error?: string }> {
  const user = await getCurrentUser();
  if (!user) {
    return { success: false, error: 'User not authenticated' };
  }

  try {
    // Verify the item exists and belongs to the user
    const existingItem = dbService.findHistoryItemById(historyItemId);
    if (!existingItem) {
      return { success: false, error: 'History item not found' };
    }
    
    if (existingItem.username !== user.username) {
      return { success: false, error: 'Unauthorized access to history item' };
    }

    // Delete the item (CASCADE will handle related images)
    const db = dbService.getDb();
    const deleteStmt = db.prepare('DELETE FROM history WHERE id = ?');
    deleteStmt.run(historyItemId);

    return { success: true };
  } catch (error) {
    console.error(`Error deleting history item ${historyItemId} for user ${user.username}:`, error);
    return { success: false, error: 'Failed to delete history item.' };
  }
}

export async function getHistoryItem(historyItemId: string): Promise<HistoryItem | null> {
  const user = await getCurrentUser();
  if (!user) {
    throw new Error('User not authenticated');
  }

  const item = dbService.findHistoryItemById(historyItemId);
  
  // Verify the item belongs to the user (or user is admin)
  if (item && item.username !== user.username && user.role !== 'admin') {
    throw new Error('Unauthorized access to history item');
  }

  return item;
}

// Compatibility functions for backward compatibility
export async function updateVideoHistoryItem(params: {
  username: string;
  historyItemId: string;
  videoUrls?: (string | null)[];
  localVideoUrl?: string | null;
  seedUsed?: number | null;
  status?: 'processing' | 'completed' | 'failed';
  error?: string;
  videoModel?: 'lite' | 'pro';
}): Promise<void> {
  const { username, historyItemId, videoUrls, localVideoUrl, seedUsed, status, error, videoModel } = params;
  // Authorization check
  const existingItem = dbService.findHistoryItemById(historyItemId);
  if (!existingItem || existingItem.username !== username) {
    console.warn(`History item ${historyItemId} not found or user ${username} is not authorized.`);
    return;
  }
  // Construct the partial update object
  const updatePayload: Partial<HistoryItem> = {};
  // Only include videoGenerationParams if patch fields are present
  const videoGenPatch: Record<string, unknown> = {};
  if (videoModel !== undefined) videoGenPatch.videoModel = videoModel;
  if (seedUsed !== undefined) videoGenPatch.seed = seedUsed;
  if (localVideoUrl !== undefined) videoGenPatch.localVideoUrl = localVideoUrl;
  if (status !== undefined) videoGenPatch.status = status;
  if (error !== undefined) videoGenPatch.error = error;
  if (Object.keys(videoGenPatch).length > 0) {
    updatePayload.videoGenerationParams = videoGenPatch as any;
  }
  if (videoUrls) updatePayload.generatedVideoUrls = videoUrls;
  dbService.updateHistoryItem(historyItemId, updatePayload);
}

export async function getHistoryPaginated(
  page: number = 1,
  limit: number = 10,
  filter: 'all' | 'image' | 'video' = 'all'
): Promise<{
  items: HistoryItem[];
  totalCount: number;
  hasMore: boolean;
  currentPage: number;
}> {
  const user = await getCurrentUser();
  if (!user) {
    throw new Error('User not authenticated');
  }
  
  const filterParam = filter === 'all' ? undefined : filter;
  return dbService.getPaginatedHistoryForUser({
    username: user.username,
    page,
    limit,
    filter: filterParam
  });
}

export async function getVideoHistoryPaginated(
  page: number = 1,
  limit: number = 10
): Promise<{
  items: HistoryItem[];
  totalCount: number;
  hasMore: boolean;
  currentPage: number;
}> {
  return getHistoryPaginated(page, limit, 'video');
}

export async function getHistoryItemById(historyItemId: string): Promise<{ success: boolean; item?: HistoryItem; error?: string }> {
  const user = await getCurrentUser();
  if (!user) {
    return { success: false, error: 'User not authenticated' };
  }
  const item = dbService.findHistoryItemById(historyItemId);
  if (!item) {
    return { success: false, error: 'History item not found' };
  }
  if (item.username !== user.username) {
    return { success: false, error: 'Unauthorized access to history item' };
  }
  return { success: true, item };
}
</file>

<file path="src/ai/actions/cache-manager.ts">
'use server';

import fs from 'fs/promises';
import path from 'path';

const cacheFilePath = path.join(process.cwd(), '.cache', 'image-processing-cache.json');

type CacheEntry = {
  path: string;
  hash: string;
};
type CacheData = {
  [key: string]: {
    bgRemoved?: CacheEntry;
    upscaled?: CacheEntry;
    faceDetailed?: CacheEntry;
    timestamp?: number;
  };
};

async function readCache(): Promise<CacheData> {
  try {
    await fs.mkdir(path.dirname(cacheFilePath), { recursive: true });
    const data = await fs.readFile(cacheFilePath, 'utf-8');
    return JSON.parse(data);
  } catch (error) {
    if (error instanceof Error && 'code' in error && error.code === 'ENOENT') {
      return {}; // Cache file doesn't exist, return empty object
    }
    console.error('Error reading cache:', error);
    return {};
  }
}

async function writeCache(data: CacheData): Promise<void> {
  try {
    await fs.mkdir(path.dirname(cacheFilePath), { recursive: true });
    await fs.writeFile(cacheFilePath, JSON.stringify(data, null, 2));
  } catch (error) {
    console.error('Error writing cache:', error);
  }
}

export async function getCachedImage(hash: string, type: 'bgRemoved' | 'upscaled' | 'faceDetailed'): Promise<CacheEntry | null> {
  const cache = await readCache();
  const cachedEntry = cache[hash]?.[type];
  if (cachedEntry) {
    try {
      const fullPath = path.join(process.cwd(), 'public', cachedEntry.path);
      await fs.access(fullPath);
      return cachedEntry;
    } catch {
      delete cache[hash]?.[type];
      if (cache[hash] && Object.keys(cache[hash]).length === 0) {
        delete cache[hash];
      }
      await writeCache(cache);
      return null;
    }
  }
  return null;
}

export async function setCachedImage(hash: string, type: 'bgRemoved' | 'upscaled' | 'faceDetailed', imagePath: string, outputHash: string): Promise<void> {
  const cache = await readCache();
  if (!cache[hash]) {
    cache[hash] = {};
  }
  cache[hash][type] = { path: imagePath, hash: outputHash };
  cache[hash].timestamp = Date.now();
  await writeCache(cache);
}

export async function cleanupOldCacheEntries(maxAgeMs: number = 30 * 24 * 60 * 60 * 1000): Promise<void> {
  const cache = await readCache();
  const now = Date.now();
  let hasChanges = false;

  for (const [hash, entry] of Object.entries(cache)) {
    if (entry.timestamp && (now - entry.timestamp) > maxAgeMs) {
      delete cache[hash];
      hasChanges = true;
    }
  }

  if (hasChanges) {
    await writeCache(cache);
  }
}
</file>

<file path="src/ai/actions/generate-video.action.ts">
'use server';

import { fal, createFalClient } from '@fal-ai/client';
import { getCurrentUser } from '@/actions/authActions';
import { addStandaloneVideoHistoryItem, updateVideoHistoryItem } from '@/actions/historyActions';
import * as videoService from '@/services/fal-api/video.service'; // Use the service layer
import { getApiKeyForUser } from '@/services/apiKey.service';

// Ensure FAL_KEY is available, otherwise Fal.ai calls will fail
if (!process.env.FAL_KEY) {
  console.warn(
    'FAL_KEY environment variable is not set. Fal.ai API calls for video generation will likely fail.'
  );
}

export interface GenerateVideoInput {
  prompt: string;
  image_url: string; // This can be a public URL or a base64 data URI
  resolution?: '480p' | '720p' | '1080p';
  duration?: '5' | '10'; // Duration as strings for Fal.ai API
  videoModel?: 'lite' | 'pro';
  camera_fixed?: boolean;
  seed?: number; // Use -1 for random
  // Add structured video parameters (for history/logging purposes, not sent to Fal.ai)
  selectedPredefinedPrompt?: string;
  modelMovement?: string;
  fabricMotion?: string;
  cameraAction?: string;
  aestheticVibe?: string;
}

export interface GenerateVideoOutput {
  videoUrl: string | null;
  localVideoUrl: string | null;
  seedUsed: number | null;
  error?: string | null;
}

/**
 * Checks if the Fal.ai video generation service is configured and available.
 */
export async function isFalVideoGenerationAvailable(): Promise<boolean> {
  return await videoService.isVideoServiceAvailable();
}

/**
 * Utility to upload a file (from Blob or File object) to Fal Storage.
 */
export async function uploadToFalStorage(file: File | Blob, username: string): Promise<string> {
  try {
    const falKey = await getApiKeyForUser(username, 'fal');
    // Use a per-user Fal client instance with the correct credentials
    const scopedFal = createFalClient({ credentials: falKey });
    const url = await scopedFal.storage.upload(file);
    console.log(`File uploaded to Fal Storage: ${url}`);
    return url;
  } catch (error: any) {
    console.error('Error uploading file to Fal Storage:', error);
    throw new Error(`Failed to upload to Fal Storage: ${error.message}`);
  }
}

// Function to start video generation with webhook support
export async function startVideoGenerationAndCreateHistory(input: GenerateVideoInput) {
  const user = await getCurrentUser();
  if (!user) {
    return { error: 'User not authenticated' };
  }

  // 1. Create a placeholder history item first to get an ID
  const historyVideoParams = {
    prompt: input.prompt,
    resolution: input.resolution || '480p',
    videoModel: input.videoModel || 'lite',
    duration: input.duration || '5',
    seed: input.seed || -1,
    sourceImageUrl: input.image_url,
    selectedPredefinedPrompt: input.selectedPredefinedPrompt || 'custom',
    modelMovement: input.modelMovement || '',
    fabricMotion: input.fabricMotion || '',
    cameraAction: input.cameraAction || '',
    aestheticVibe: input.aestheticVibe || '',
    cameraFixed: input.camera_fixed || false,
    status: 'processing' as const, // Initial status
  };

  // Create placeholder history item and get the ID
  const historyItemId = await addStandaloneVideoHistoryItem(
    [null], // No video URL yet
    historyVideoParams
  );

  // 2. Prepare the webhook URL for fal_webhook query parameter
  const webhookUrl = `${process.env.NEXT_PUBLIC_APP_URL}/api/video/webhook?historyItemId=${historyItemId}&username=${encodeURIComponent(user.username)}`;

  // 3. Submit the job using the new service function
  try {
    const videoServiceInput = {
      prompt: input.prompt,
      image_url: input.image_url,
      videoModel: input.videoModel,
      resolution: input.resolution,
      duration: input.duration,
      camera_fixed: input.camera_fixed,
      seed: input.seed,
    };

    const taskId = await videoService.startVideoGenerationWithWebhook(videoServiceInput, webhookUrl, user.username);

    // Update the history item with the taskId for tracking
    await updateVideoHistoryItem({ 
      username: user.username, 
      historyItemId, 
      videoUrls: [null],
      localVideoUrl: null,
      seedUsed: null,
      status: 'processing',
      videoModel: input.videoModel || 'lite',
    });

    return { taskId, historyItemId };
  } catch (error: any) {
    console.error('Fal.ai submission error:', error);
    
    // If submission fails, mark the history item as failed
    await updateVideoHistoryItem({ 
      username: user.username, 
      historyItemId, 
      videoUrls: [null],
      localVideoUrl: null,
      seedUsed: null,
      status: 'failed', 
      error: 'Failed to submit job to fal.ai',
      videoModel: input.videoModel || 'lite',
    });
    return { error: 'Failed to submit video generation job.' };
  }
}
</file>

<file path="src/ai/actions/remove-background.action.ts">
'use server';

/**
 * @fileOverview Server action for background removal using Fal.ai API
 * 
 * This action orchestrates the background removal process by calling the Fal.ai
 * service and saving the result locally using the storage service.
 */

import * as falImageService from '@/services/fal-api/image.service';
import { saveFileFromUrl } from '@/services/storage.service';
import { getCachedImage, setCachedImage } from './cache-manager';
import { getCurrentUser } from '@/actions/authActions';

/**
 * Remove background from a user-uploaded image
 * @param imageUrlOrDataUri The original image as a data URI or public URL
 * @param imageHash Optional hash of the original image for caching
 * @param originalFileName Optional original filename for reference
 * @returns Promise an object containing the local relative path of the background-removed image
 */
export async function removeBackgroundAction(
  imageUrlOrDataUri: string,
  imageHash?: string
): Promise<{ savedPath: string; outputHash: string }> {
  if (!imageUrlOrDataUri) {
    throw new Error('Image data URI or URL is required for background removal');
  }
  const user = await getCurrentUser();
  if (!user) {
    throw new Error('Authentication required for background removal.');
  }

  // Check cache first if hash is provided
  if (imageHash) {
    const cachedEntry = await getCachedImage(imageHash, 'bgRemoved');
    if (cachedEntry) {
      console.log(`[Cache] HIT: Found background-removed image for hash ${imageHash} at path ${cachedEntry.path}`);
      return { savedPath: cachedEntry.path, outputHash: cachedEntry.hash };
    }
    console.log(`[Cache] MISS: No cached background-removed image for hash ${imageHash}`);
  }
  
  try {
    console.log('Starting background removal process with Fal.ai...');

    // Remove background using Fal.ai service
    const outputImageUrl = await falImageService.removeBackground(imageUrlOrDataUri, user.username);
    
    console.log(`Fal.ai processed image URL: ${outputImageUrl}`);

    // Save the processed image locally using the storage service
    const { relativeUrl, hash: outputHash } = await saveFileFromUrl(
      outputImageUrl, 
      'RefashionAI_bg_removed', 
      'processed_images', 
      'png'
    );
    
    // Cache the result if hash is provided
    if (imageHash) {
      await setCachedImage(imageHash, 'bgRemoved', relativeUrl, outputHash);
      console.log(`[Cache] SET: Stored background-removed image for hash ${imageHash}`);
    }
    
    console.log('Background removal completed successfully using Fal.ai.');
    return { savedPath: relativeUrl, outputHash };
    
  } catch (error) {
    console.error('Error in background removal action (Fal.ai):', error);
    throw new Error(`Background removal with Fal.ai failed: ${(error as Error).message}`);
  }
}

/**
 * Checks if the background removal service is configured and available.
 * @returns {Promise<boolean>} True if the service is available, otherwise false.
 */
export async function isBackgroundRemovalAvailable(): Promise<boolean> {
  return await falImageService.isServiceAvailable();
}
</file>

<file path="src/ai/actions/upload-and-resize-image.action.ts">
'use server';

import sharp from 'sharp';
import crypto from 'crypto';

const MAX_DIMENSION = 2048;

interface UploadAndResizeResult {
  dataUri: string;
  hash: string;
  originalWidth: number;
  originalHeight: number;
  resized: boolean;
}

/**
 * Receives an image file, checks if it's larger than MAX_DIMENSION,
 * resizes it if necessary, and returns the processed image as a data URI.
 * @param formData The form data containing the image file under the key 'file'.
 * @returns An object with the new data URI, hash, and resize information.
 */
export async function uploadAndResizeImageAction(formData: FormData): Promise<UploadAndResizeResult> {
  const file = formData.get('file') as File | null;

  if (!file) {
    throw new Error('No file provided.');
  }

  const buffer = Buffer.from(await file.arrayBuffer());

  const image = sharp(buffer);
  const metadata = await image.metadata();

  if (!metadata.width || !metadata.height || !metadata.format) {
    throw new Error('Could not read image metadata.');
  }

  let finalBuffer: Buffer = buffer;
  let resized = false;

  if (metadata.width > MAX_DIMENSION || metadata.height > MAX_DIMENSION) {
    console.log(`Image (${metadata.width}x${metadata.height}) is larger than ${MAX_DIMENSION}px. Resizing...`);
    finalBuffer = Buffer.from(await image
      .resize({
        width: MAX_DIMENSION,
        height: MAX_DIMENSION,
        fit: 'inside',
        withoutEnlargement: true,
      })
      .toBuffer());
    resized = true;
    const newMetadata = await sharp(finalBuffer).metadata();
    console.log(`Resized to ${newMetadata.width}x${newMetadata.height}`);
  }

  const dataUri = `data:image/${metadata.format};base64,${finalBuffer.toString('base64')}`;

  const hash = crypto.createHash('sha256').update(finalBuffer).digest('hex');

  return {
    dataUri,
    hash,
    originalWidth: metadata.width,
    originalHeight: metadata.height,
    resized,
  };
}
</file>

<file path="src/ai/actions/upscale-image.action.ts">
'use server';

/**
 * @fileOverview Server action for image upscaling and face enhancement using Fal.ai API
 * 
 * This action orchestrates the image upscaling process by calling the Fal.ai
 * service and saving the result locally using the storage service.
 */

import * as falImageService from '@/services/fal-api/image.service';
import { saveFileFromUrl } from '@/services/storage.service';
import { getCachedImage, setCachedImage } from './cache-manager';
import { getCurrentUser } from '@/actions/authActions';

/**
 * Upscale and enhance a user-uploaded image
 * @param imageUrlOrDataUri The original image as a data URI or public URL
 * @param imageHash Optional hash of the original image for caching
 * @param originalFileName Optional original filename for reference
 * @returns Promise an object containing the local relative path of the upscaled image
 */
export async function upscaleImageAction(
  imageUrlOrDataUri: string,
  imageHash?: string
): Promise<{ savedPath: string; outputHash: string }> {
  if (!imageUrlOrDataUri) {
    throw new Error('Image data URI or URL is required for upscaling');
  }
  const user = await getCurrentUser();
  if (!user) {
    throw new Error('Authentication required for upscaling.');
  }

  // Check cache first if hash is provided
  if (imageHash) {
    const cachedEntry = await getCachedImage(imageHash, 'upscaled');
    if (cachedEntry) {
      console.log(`[Cache] HIT: Found upscaled image for hash ${imageHash} at path ${cachedEntry.path}`);
      return { savedPath: cachedEntry.path, outputHash: cachedEntry.hash };
    }
    console.log(`[Cache] MISS: No cached upscaled image for hash ${imageHash}`);
  }
  
  try {
    console.log('Starting image upscaling process with Fal.ai...');

    // Process image using Fal.ai service
    const outputImageUrl = await falImageService.upscaleAndEnhance(imageUrlOrDataUri, user.username);
    
    console.log(`Fal.ai processed image URL: ${outputImageUrl}`);

    // Save the processed image locally using the storage service
    const { relativeUrl, hash: outputHash } = await saveFileFromUrl(
      outputImageUrl, 
      'RefashionAI_upscaled', 
      'processed_images', 
      'png'
    );
    
    // Cache the result if hash is provided
    if (imageHash) {
      await setCachedImage(imageHash, 'upscaled', relativeUrl, outputHash);
      console.log(`[Cache] SET: Stored upscaled image for hash ${imageHash}`);
    }
    
    console.log('Image upscaling completed successfully using Fal.ai.');
    return { savedPath: relativeUrl, outputHash };
    
  } catch (error) {
    console.error('Error in upscale image action (Fal.ai):', error);
    throw new Error(`Image upscaling with Fal.ai failed: ${(error as Error).message}`);
  }
}

/**
 * Face detailer action - now calls the dedicated face-detailer API
 * @param imageUrlOrDataUri The original image as a data URI or public URL
 * @param imageHash Optional hash of the original image for caching
 * @param originalFileName Optional original filename for reference
 * @returns Promise an object containing the local relative path of the processed image
 */
export async function faceDetailerAction(
  imageUrlOrDataUri: string,
  imageHash?: string
): Promise<{ savedPath: string; outputHash: string }> {
  if (!imageUrlOrDataUri) {
    throw new Error('Image data URI or URL is required for face detailing');
  }
  const user = await getCurrentUser();
  if (!user) {
    throw new Error('Authentication required for face detailing.');
  }

  // Check cache first if hash is provided
  if (imageHash) {
    const cachedEntry = await getCachedImage(imageHash, 'faceDetailed');
    if (cachedEntry) {
      console.log(`[Cache] HIT: Found face-enhanced image for hash ${imageHash} at path ${cachedEntry.path}`);
      return { savedPath: cachedEntry.path, outputHash: cachedEntry.hash };
    }
    console.log(`[Cache] MISS: No cached face-enhanced image for hash ${imageHash}`);
  }

  try {
    console.log('Starting face enhancement process with Fal.ai...');

    // Call the new, specific service function
    const outputImageUrl = await falImageService.detailFaces(imageUrlOrDataUri, user.username);

    console.log(`Fal.ai face-detailer processed image URL: ${outputImageUrl}`);

    // Save the processed image locally
    const { relativeUrl, hash: outputHash } = await saveFileFromUrl(
      outputImageUrl, 
      'RefashionAI_face_enhanced', // Use a different prefix
      'processed_images', 
      'png'
    );

    // Cache the result if hash is provided
    if (imageHash) {
      await setCachedImage(imageHash, 'faceDetailed', relativeUrl, outputHash);
      console.log(`[Cache] SET: Stored face-enhanced image for hash ${imageHash}`);
    }

    console.log('Face enhancement completed successfully using Fal.ai.');
    return { savedPath: relativeUrl, outputHash };

  } catch (error) {
    console.error('Error in face detailer action (Fal.ai):', error);
    throw new Error(`Face enhancement with Fal.ai failed: ${(error as Error).message}`);
  }
}

/**
 * Checks if the image upscaling service is configured and available.
 * @returns {Promise<boolean>} True if the service is available, otherwise false.
 */
export async function isUpscaleServiceAvailable(): Promise<boolean> {
  return await falImageService.isServiceAvailable();
}

/**
 * Checks if the face detailing service is configured and available.
 * @returns {Promise<boolean>} True if the service is available, otherwise false.
 */
export async function isFaceDetailerAvailable(): Promise<boolean> {
  // Both services rely on the same FAL_KEY, so the availability check is the same.
  return isUpscaleServiceAvailable();
}
</file>

<file path="src/ai/flows/generate-image-edit.ts">
// This is a server-side file.
'use server';

/**
 * @fileOverview AI agent for editing an image based on a text prompt,
 * or generating an image purely from text if no source image is provided.
 * Generates three versions using different API keys.
 * Images are saved locally and their local paths are returned.
 * The source image can be provided as a data URI or a public HTTPS URL.
 */

import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import { Buffer } from 'buffer';
import fetch from 'node-fetch'; // For fetching image from URL
import fs from 'fs';
import path from 'path';
import { saveDataUriLocally } from '@/services/storage.service';
import { getApiKeyForUser } from '@/services/apiKey.service';
import { buildAIPrompt } from '@/lib/prompt-builder';

// NEW: Import Axios and HttpsProxyAgent for explicit proxy control
import axios, { AxiosError } from 'axios';
import { HttpsProxyAgent } from 'https-proxy-agent';

// Direct API configuration matching Python implementation
const BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent";

// --- START Defined Types ---
interface GeminiPart {
  inlineData?: {
    mimeType: string;
    data: string;
  };
  text?: string;
}

interface GeminiContent {
  role: string;
  parts: GeminiPart[];
}

interface GeminiGenerationConfig {
  temperature: number;
  topP: number;
  topK: number;
  maxOutputTokens: number;
  responseModalities: string[];
}

interface GeminiSafetySetting {
  category: string;
  threshold: string;
}

interface GeminiApiRequestBody {
  contents: GeminiContent[];
  generationConfig: GeminiGenerationConfig;
  safetySettings: GeminiSafetySetting[];
}

interface GeminiApiSuccessResponseCandidate {
  finishReason?: string;
  content?: {
    parts?: Array<GeminiPart>;
  };
  // Other candidate properties if relevant
}
interface GeminiApiSuccessResponse {
  candidates?: Array<GeminiApiSuccessResponseCandidate>;
  // Other top-level response properties if relevant
}

interface GeminiErrorDetail {
  message: string;
  // other fields like code, status if they exist
}

interface GeminiErrorData { // Renamed from GeminiErrorResponse to avoid conflict with actual HTTP response
  error?: GeminiErrorDetail | string;
}
// --- END Defined Types ---


/**
 * Make a direct API call to Gemini API with explicit proxy support using axios
 * This provides better proxy control than node-fetch's automatic detection
 */
async function makeGeminiApiCall(apiKey: string, requestBody: GeminiApiRequestBody): Promise<GeminiApiSuccessResponse> {
  const url = `${BASE_URL}?key=${apiKey}`;
  
  let httpsAgent;
  const proxyUrl = process.env.HTTPS_PROXY || process.env.https_proxy;
  if (proxyUrl) {
    console.log(`Using proxy: ${proxyUrl.replace(/\/\/.*@/, '//***:***@')}`);
    httpsAgent = new HttpsProxyAgent(proxyUrl);
  } else {
    console.log('No HTTPS_PROXY environment variable set. Making direct call.');
  }

  console.log(`Making Axios API call to: ${url.replace(/key=.*/, 'key=***')}`);
  
  try {
    const response = await axios.post<GeminiApiSuccessResponse>(url, requestBody, { // Added type to axios.post
      headers: { 'Content-Type': 'application/json' },
      httpsAgent: httpsAgent,
    });

    console.log(`Gemini API response status: ${response.status}`);
    return response.data;

  } catch (error) {
    console.error('Error calling Gemini API:', axios.isAxiosError(error) ? error.toJSON() : error);
    
    if (axios.isAxiosError<GeminiErrorData>(error) && error.response) {
      console.error("Axios error response data:", error.response.data);
      const errData = error.response.data.error;
      const message = (typeof errData === 'string' ? errData : errData?.message) || JSON.stringify(error.response.data);
      throw new Error(`Gemini API Error (${error.response.status}): ${message}`);
    }
    
    const generalError = error as Error;
    throw new Error(`Failed to call Gemini API: ${generalError.message}`);
  }
}

const GenerateImageEditInputSchema = z.object({
  prompt: z.string().optional().describe('The prompt to use for generating or editing the image.'),
  parameters: z.any().optional().describe('The parameters object to build the prompt from.'),
  settingsMode: z.enum(['basic', 'advanced']).optional().describe('The settings mode for prompt construction.'),
  imageDataUriOrUrl: z
    .string()
    .optional()
    .describe(
      "Optional: The image to edit, as a data URI (e.g., 'data:image/png;base64,...') or a publicly accessible HTTPS URL."
    ),
});
export type GenerateImageEditInput = z.infer<typeof GenerateImageEditInputSchema>;

const SingleImageOutputSchema = z.object({
  editedImageUrl: z
    .string()
    .describe('The URL or local path of the generated or edited image.'),
});
export type SingleImageOutput = z.infer<typeof SingleImageOutputSchema>;

async function performSingleImageGeneration(
  input: GenerateImageEditInput,
  flowIdentifier: string,
  username: string,
  keyIndex: 1 | 2 | 3
): Promise<SingleImageOutput> {
  const apiKey = await getApiKeyForUser(username, 'gemini', keyIndex);

  let sourceImageDataForModelProcessing: { mimeType: string; data: string; } | null = null;
  if (input.imageDataUriOrUrl) {
    let dataUriToProcess = input.imageDataUriOrUrl;
    if (input.imageDataUriOrUrl.startsWith('http://') || input.imageDataUriOrUrl.startsWith('https://')) {
      try {
        console.log(`Fetching image from URL for ${flowIdentifier}: ${input.imageDataUriOrUrl}`);
        const response = await fetch(input.imageDataUriOrUrl);
        if (!response.ok) {
          throw new Error(`Failed to fetch image from URL (${input.imageDataUriOrUrl}): ${response.status} ${response.statusText}`);
        }
        const imageBuffer = await response.buffer();
        const mimeType = response.headers.get('content-type') || 'image/png';
        if (!mimeType.startsWith('image/')) {
          throw new Error(`Fetched content from URL (${input.imageDataUriOrUrl}) is not an image: ${mimeType}`);
        }
        dataUriToProcess = `data:${mimeType};base64,${imageBuffer.toString('base64')}`;
        console.log(`Successfully converted URL to data URI for ${flowIdentifier}. MimeType: ${mimeType}`);
      } catch (fetchError: unknown) { // Changed to unknown
        console.error(`Error fetching or converting image URL for ${flowIdentifier}:`, fetchError);
        throw new Error(`Failed to process source image from URL for ${flowIdentifier}: ${(fetchError as Error).message}`);
      }
    } else if (input.imageDataUriOrUrl.startsWith('/')) {
      try {
        const absolutePath = path.join(process.cwd(), 'public', input.imageDataUriOrUrl);
        if (fs.existsSync(absolutePath)) {
          const imageBuffer = fs.readFileSync(absolutePath);
          let mimeType = 'image/png';
          if (input.imageDataUriOrUrl.endsWith('.jpg') || input.imageDataUriOrUrl.endsWith('.jpeg')) mimeType = 'image/jpeg';
          else if (input.imageDataUriOrUrl.endsWith('.webp')) mimeType = 'image/webp';
          else if (input.imageDataUriOrUrl.endsWith('.gif')) mimeType = 'image/gif';
          dataUriToProcess = `data:${mimeType};base64,${imageBuffer.toString('base64')}`;
          console.log(`Successfully converted local path ${input.imageDataUriOrUrl} to data URI for ${flowIdentifier}.`);
        } else {
          throw new Error(`Local image file not found at ${absolutePath}`);
        }
      } catch (localFileError: unknown) { // Changed to unknown
        console.error(`Error reading local image file for ${flowIdentifier}:`, localFileError);
        throw new Error(`Failed to process local source image for ${flowIdentifier}: ${(localFileError as Error).message}`);
      }
    }
    const match = dataUriToProcess.match(/^data:(image\/\w+);base64,(.+)$/);
    if (match) {
      sourceImageDataForModelProcessing = { mimeType: match[1], data: match[2] };
    } else if (input.imageDataUriOrUrl) {
        console.warn(`Could not parse processed image data URI for ${flowIdentifier}. Original input: ${input.imageDataUriOrUrl}`);
    }
  }
  const parts: GeminiPart[] = []; // Typed parts
  
  if (sourceImageDataForModelProcessing) {
    parts.push({
      inlineData: {
        mimeType: sourceImageDataForModelProcessing.mimeType,
        data: sourceImageDataForModelProcessing.data,
      },
    });
  }
  parts.push({ text: input.prompt });
  const requestBody: GeminiApiRequestBody = { // Typed requestBody
    contents: [
      {
        role: "user",
        parts: parts
      }
    ],
    generationConfig: {
      temperature: 1,
      topP: 0.95,
      topK: 40,
      maxOutputTokens: 8192,
      responseModalities: ["image", "text"]
    },
    safetySettings: [
      {
        "category": "HARM_CATEGORY_CIVIC_INTEGRITY",
        "threshold": "BLOCK_NONE"
      }
    ]
  };
  console.log(`Calling Gemini API directly for ${flowIdentifier} with model gemini-2.0-flash-exp`);
  console.log(`With API Key: ${apiKey ? 'SET' : 'NOT SET'}`);
  if (sourceImageDataForModelProcessing) {
    console.log(`WITH IMAGE: ${sourceImageDataForModelProcessing.mimeType}`);
  } else {
    console.log(`Performing text-to-image generation for ${flowIdentifier} as no source image was provided or processed.`);
  }
  
  const maxAttempts = 3;
  let attempt = 0;
  
  while (attempt < maxAttempts) {
    attempt++;
    try {
      console.log(`🔍 ATTEMPT ${attempt}/${maxAttempts} to generate image for ${flowIdentifier}`);
      const result = await makeGeminiApiCall(apiKey, requestBody);
      
      let generatedImageDataUri: string | null = null;
      
      if (result && result.candidates && result.candidates.length > 0) {
        const candidate = result.candidates[0];
        
        if (candidate.finishReason === 'SAFETY') {
          console.warn(`Image generation blocked by safety settings for ${flowIdentifier}. Candidate:`, JSON.stringify(candidate, null, 2));
          throw new Error(`Image generation blocked by safety settings for ${flowIdentifier}.`);
        }
        
        if (candidate.content && candidate.content.parts) {
          for (const part of candidate.content.parts) {
            if (part.inlineData) {
              const mimeType = part.inlineData.mimeType;
              const base64Data = part.inlineData.data;
              generatedImageDataUri = `data:${mimeType};base64,${base64Data}`;
              console.log(`🔍 Image received from ${flowIdentifier} via REST. MimeType: ${mimeType}`);
              break;
            } else if (part.text) {
              console.log(`🔍 Text response from ${flowIdentifier}: ${part.text}`);
            }
          }
        }
      }

      if (!generatedImageDataUri) {
        console.error(`🔍 AI for ${flowIdentifier} (REST) did not return an image. Full API Response:`, JSON.stringify(result, null, 2));
        if (attempt < maxAttempts) {
          console.log(`🔍 No image data in response, attempt ${attempt}/${maxAttempts}`);
          continue;
        } else {
          throw new Error(`AI for ${flowIdentifier} (REST) did not return image data.`);
        }
      }      console.log(`🔍 Successfully generated image on attempt ${attempt}/${maxAttempts} for ${flowIdentifier}`);
      
      try {
        const { relativeUrl: imageUrl } = await saveDataUriLocally(
          generatedImageDataUri,
          `RefashionAI_generated_${flowIdentifier}`,
          'generated_images'
        );
        return { editedImageUrl: imageUrl };
      } catch (uploadError: unknown) { // Changed to unknown
        const knownUploadError = uploadError as Error;
        console.error(`Error storing image from ${flowIdentifier} (axios):`, knownUploadError);
        throw new Error(`Failed to store image from ${flowIdentifier} (axios): ${knownUploadError.message}`);
      }
      
    } catch (error: unknown) { // Changed to unknown
      const knownError = error as Error;
      console.error(`🔍 Error in attempt ${attempt} for ${flowIdentifier}:`, knownError.message);
      
      if (attempt < maxAttempts) {
        console.log(`Retrying in 1 second... (${attempt}/${maxAttempts})`);
        await new Promise(resolve => setTimeout(resolve, 1000));
        continue;
      } else {
        throw error; // Rethrow the original error (now typed as unknown)
      }
    }
  }
  
  throw new Error(`Failed to generate image after ${maxAttempts} attempts for ${flowIdentifier}`);
}

async function generateImageFlow1(input: GenerateImageEditInput, username: string): Promise<SingleImageOutput> {
  return performSingleImageGeneration(input, 'flow1', username, 1);
}

async function generateImageFlow2(input: GenerateImageEditInput, username: string): Promise<SingleImageOutput> {
  return performSingleImageGeneration(input, 'flow2', username, 2);
}

async function generateImageFlow3(input: GenerateImageEditInput, username: string): Promise<SingleImageOutput> {
  return performSingleImageGeneration(input, 'flow3', username, 3);
}

const GenerateMultipleImagesOutputSchema = z.object({
  editedImageUrls: z.array(z.string().nullable()).length(3)
    .describe('An array of three generated or edited image URLs/paths (or null for failures).'),
  constructedPrompt: z.string().describe('The final prompt that was sent to the AI.'),
  errors: z.array(z.string().nullable()).optional()
    .describe('An array of error messages if any generation or storage failed.'),
});
export type GenerateMultipleImagesOutput = z.infer<typeof GenerateMultipleImagesOutputSchema>;


export async function generateImageEdit(input: GenerateImageEditInput, username: string): Promise<GenerateMultipleImagesOutput> {
  if (!username) {
    throw new Error('Username is required to generate images.');
  }

  // Construct the prompt from parameters if provided
  let constructedPrompt: string;
  if (input.parameters) {
    constructedPrompt = buildAIPrompt({
      type: 'image',
      params: {
        ...input.parameters,
        settingsMode: input.settingsMode || 'basic'
      }
    });
  } else if (input.prompt) {
    constructedPrompt = input.prompt;
  } else {
    throw new Error('Either parameters or prompt must be provided');
  }

  // Create input with the constructed prompt for the generation flows
  const inputForGeneration: GenerateImageEditInput = {
    ...input,
    prompt: constructedPrompt,
  };

  const results = await Promise.allSettled([
    generateImageFlow1(inputForGeneration, username),
    generateImageFlow2(inputForGeneration, username),
    generateImageFlow3(inputForGeneration, username),
  ]);

  const editedImageUrlsResult: (string | null)[] = [null, null, null];
  const errorsResult: (string | null)[] = [null, null, null];

  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      editedImageUrlsResult[index] = result.value.editedImageUrl;
    } else {
      console.error(`Error from flow ${index + 1}:`, result.reason);
      // Ensure result.reason is an Error before accessing .message
      const reasonError = result.reason as Error;
      errorsResult[index] = `Image ${index + 1} processing failed: ${reasonError?.message || 'Unknown error'}`;
    }
  });

  return {
    editedImageUrls: editedImageUrlsResult,
    constructedPrompt: constructedPrompt,
    errors: errorsResult.some(e => e !== null) ? errorsResult : undefined
  };
}

export async function regenerateSingleImage(input: GenerateImageEditInput, flowIndex: number, username: string): Promise<SingleImageOutput> {
  if (!username) {
    throw new Error('Username is required to re-roll an image.');
  }
  console.log(`Attempting to re-roll image for flow index: ${flowIndex}`);
  switch (flowIndex) {
    case 0:
      return performSingleImageGeneration(input, 'flow1-reroll', username, 1);
    case 1:
      return performSingleImageGeneration(input, 'flow2-reroll', username, 2);
    case 2:
      return performSingleImageGeneration(input, 'flow3-reroll', username, 3);
    default:
      throw new Error(`Invalid flow index: ${flowIndex}. Must be 0, 1, or 2.`);
  }
}
</file>

<file path="src/app/admin/_components/AdminLoading.tsx">
import { Loader2 } from 'lucide-react';

export function AdminLoading() {
  return (
    <div className="flex w-full flex-col flex-1 items-center justify-center py-20">
      <div className="flex items-center gap-3 text-muted-foreground">
        <Loader2 className="h-6 w-6 animate-spin" />
        <span className="text-lg font-medium">Loading Page...</span>
      </div>
    </div>
  );
}
</file>

<file path="src/app/admin/_components/AdminNav.tsx">
// src/app/admin/_components/AdminNav.tsx
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { LayoutDashboard, Users, Settings } from 'lucide-react';
import { Button } from '@/components/ui/button';

const NAV_ITEMS = [
	{ href: '/admin', label: 'Dashboard', icon: LayoutDashboard },
	{ href: '/admin/users', label: 'Users', icon: Users },
	{ href: '/admin/settings', label: 'Settings', icon: Settings },
];

const isActive = (href: string, pathname: string) => {
	return href === '/admin' ? pathname === href : pathname.startsWith(href);
};

export function AdminNav() {
	const pathname = usePathname();

	return (
        <nav className="flex flex-col gap-2">
            {NAV_ITEMS.map((item) => (
				<Button
					key={item.label}
					asChild
					variant={isActive(item.href, pathname) ? 'active' : 'ghost'}
					className="justify-start"
				>
					<Link href={item.href} legacyBehavior>
						<item.icon className="mr-2 h-4 w-4" />
						{item.label}
					</Link>
				</Button>
			))}
        </nav>
    );
}
</file>

<file path="src/app/admin/layout.tsx">
// src/app/admin/layout.tsx
import { ReactNode, Suspense } from 'react';
import Link from 'next/link';
import { notFound } from 'next/navigation';
import { getCurrentUser } from '@/actions/authActions';
import { Home, LogOut, ShieldCheck, PanelLeft } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Separator } from '@/components/ui/separator';
import { AdminNav } from './_components/AdminNav';
import { logoutUser } from '@/actions/authActions';
import { ThemeToggleImproved as ThemeToggleCompact } from '@/components/ui/ThemeToggleImproved';
import { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet';
import { AdminLoading } from './_components/AdminLoading';

export default function AdminLayout({ children }: { children: ReactNode }) {
  // The auth check is now handled by middleware.ts, so we don't need to
  // make this component async to await getCurrentUser(). This fixes the
  // conflict between Suspense and the PageTransitionWrapper.
  return (
    <>
      <header className="border-b border-border sticky top-0 bg-background/95 backdrop-blur-sm z-50">
        <div className="container mx-auto flex justify-between items-center max-w-7xl h-16 px-4">
            <div className="flex items-center gap-2 sm:gap-4">
                <div className="md:hidden">
                  <Sheet>
                    <SheetTrigger asChild>
                      <Button variant="ghost" size="icon">
                        <PanelLeft className="h-5 w-5" />
                        <span className="sr-only">Toggle Menu</span>
                      </Button>
                    </SheetTrigger>
                    <SheetContent side="left" className="pr-0 pt-12"><AdminNav /></SheetContent>
                  </Sheet>
                </div>
                <ShieldCheck className="h-6 w-6 text-primary" />
                <span className="text-base sm:text-lg font-semibold tracking-tight">Admin Console</span>
            </div>
            <div className="flex items-center gap-2">
                <Button asChild variant="outline" size="sm">
                  <Link href="/create" legacyBehavior><Home className="mr-2 h-4 w-4" />Back to App</Link>
                </Button>
                <ThemeToggleCompact />
                <form action={logoutUser}>
                    <Button variant="ghost" size="sm"><LogOut className="mr-2 h-4 w-4" />Logout</Button>
                </form>
            </div>
        </div>
      </header>
      <div className="container mx-auto max-w-7xl flex-1 items-start md:grid md:grid-cols-[220px_minmax(0,1fr)] md:gap-6 lg:grid-cols-[240px_minmax(0,1fr)] lg:gap-10 py-10">
        <aside className="fixed top-16 z-30 -ml-2 hidden h-[calc(100vh-64px)] w-full shrink-0 md:sticky md:block">
          <div className="h-full py-6 pr-6 lg:py-8">
              <AdminNav />
          </div>
        </aside>
        <main className="w-full flex-1 flex flex-col">
          <Suspense fallback={<AdminLoading />}>{children}</Suspense>
        </main>
      </div>
    </>
  );
}
</file>

<file path="src/app/admin/page.tsx">
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import { getAllUsersHistoryPaginatedForAdmin } from '@/actions/historyActions';
import type { HistoryItem } from '@/lib/types';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Loader2, AlertTriangle } from 'lucide-react';
import HistoryCard from '@/components/HistoryCard'; // Re-use the existing card for consistency
import { PageHeader } from '@/components/ui/page-header';
import { LayoutDashboard } from 'lucide-react';

export default function AdminDashboardPage() {
  const [items, setItems] = useState<HistoryItem[]>([]);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [loading, setLoading] = useState(true);
  const [loadingMore, setLoadingMore] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const loadMoreRef = useRef<HTMLDivElement>(null);

  const fetchHistory = useCallback(
    async (pageNum: number, append: boolean) => {
      if (!append) {
        setLoading(true);
      } else {
        setLoadingMore(true);
      }
      try {
        const result = await getAllUsersHistoryPaginatedForAdmin(pageNum, 9);
        setItems(prev => (append ? [...prev, ...result.items] : result.items));
        setHasMore(result.hasMore);
        setPage(pageNum);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load history');
      } finally {
        setLoading(false);
        setLoadingMore(false);
      }
    },
    []
  );

  useEffect(() => {
    fetchHistory(1, false);
  }, [fetchHistory]);

  useEffect(() => {
    const observer = new IntersectionObserver(
      entries => {
        if (
          entries[0].isIntersecting &&
          hasMore &&
          !loading &&
          !loadingMore
        ) {
          fetchHistory(page + 1, true);
        }
      },
      { rootMargin: '200px' }
    );

    const currentRef = loadMoreRef.current;
    if (currentRef) {
      observer.observe(currentRef);
    }

    return () => {
      if (currentRef) {
        observer.unobserve(currentRef);
      }
    };
  }, [hasMore, loading, loadingMore, page, fetchHistory]);

  if (loading) {
    return (
      <div className="flex justify-center py-20">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
      </div>
    );
  }

  if (error) {
    return (
      <Alert variant="destructive" className="mt-4">
        <AlertTriangle className="h-4 w-4" />
        <AlertTitle>Error Loading Dashboard</AlertTitle>
        <AlertDescription>{error}</AlertDescription>
      </Alert>
    );
  }

  return (
    <div className="space-y-8">
      <PageHeader
        icon={LayoutDashboard}
        title="Admin Dashboard"
        description="View a live feed of all user creations across the platform."
        className="text-left py-0"
      />

      {items.length === 0 ? (
        <div className="text-center text-muted-foreground py-8 border rounded-lg">
          No user history found yet.
        </div>
      ) : (
        <>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-6">
            {items.map(item => (
              <HistoryCard
                key={item.id}
                item={item}
                onViewDetails={() => {
                  /* Modal logic would be handled here or passed in */
                }}
                onReloadConfig={() => {
                  /* Reload logic handled here */
                }}
                onDeleteItem={() => {
                  /* Delete logic handled here */
                }}
                username={item.username}
              />
            ))}
          </div>
          <div ref={loadMoreRef} className="h-10" />

          {loadingMore && (
            <div className="flex justify-center mt-4">
              <Loader2 className="h-8 w-8 animate-spin text-primary" />
            </div>
          )}
        </>
      )}
    </div>
  );
}
</file>

<file path="src/app/admin/settings/_components/SettingsForm.tsx">
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { useToast } from '@/hooks/use-toast';
import { SettingKey } from '@/services/settings.service';
import { updateSetting, triggerCacheCleanup, updateEncryptedSetting } from '@/actions/adminActions';
import { Loader2, Video, Wand2, Sparkles, UserCheck, Trash2, KeyRound } from 'lucide-react';
import { Input } from '@/components/ui/input';

type SettingsState = Record<SettingKey, boolean>;

// Metadata for boolean feature flags ONLY
const FEATURE_FLAG_METADATA: Record<
  'feature_video_generation' | 'feature_background_removal' | 'feature_image_upscaling' | 'feature_face_detailer',
  { label: string; description: string; icon: React.ElementType }
> = {
  feature_video_generation: { label: 'Enable Video Generation', description: 'Allow users to access the video generation tab and features.', icon: Video },
  feature_background_removal: { label: 'Enable Background Removal', description: 'Allow users to use the background removal tool on uploaded images.', icon: Wand2 },
  feature_image_upscaling: { label: 'Enable Image Upscaling', description: 'Allow users to use the upscaling tool.', icon: Sparkles },
  feature_face_detailer: { label: 'Enable Face Detailer', description: 'Allow users to use the face enhancement tool.', icon: UserCheck },
};

// Add a prop for masked key status
interface SettingsFormProps {
  initialSettings: Record<SettingKey, string>;
  maskedApiKeys?: { gemini1: string; gemini2: string; gemini3: string; fal: string };
}

export function SettingsForm({ initialSettings, maskedApiKeys }: SettingsFormProps) {
  const { toast } = useToast();
  const [settings, setSettings] = useState<SettingsState>(
    Object.entries(initialSettings).reduce((acc, [key, value]) => {
      acc[key as SettingKey] = value === 'true';
      return acc;
    }, {} as SettingsState)
  );
  const [isUpdating, setIsUpdating] = useState<Record<SettingKey, boolean>>({
    feature_video_generation: false,
    feature_background_removal: false,
    feature_image_upscaling: false,
    feature_face_detailer: false,
    global_gemini_api_key_1: false,
    global_gemini_api_key_2: false,
    global_gemini_api_key_3: false,
    global_fal_api_key: false,
  });
  const [isCleaningCache, setIsCleaningCache] = useState(false);
  const [isUpdatingApiKeys, setIsUpdatingApiKeys] = useState(false);
  const initialApiKeys = { 
    gemini1: initialSettings.global_gemini_api_key_1 || '', 
    gemini2: initialSettings.global_gemini_api_key_2 || '', 
    gemini3: initialSettings.global_gemini_api_key_3 || '', 
    fal: initialSettings.global_fal_api_key || '' 
  };
  const [apiKeys, setApiKeys] = useState(initialApiKeys);

  const handleSettingChange = async (key: SettingKey, value: boolean) => {
    setIsUpdating(prev => ({ ...prev, [key]: true }));
    setSettings(prev => ({...prev, [key]: value})); // Optimistic update

    const result = await updateSetting(key, value);
    if (!result.success) {
      toast({ title: 'Update Failed', description: result.error, variant: 'destructive' });
      setSettings(prev => ({...prev, [key]: !value})); // Revert on failure
    } else {
        toast({ title: 'Setting Updated', description: `${FEATURE_FLAG_METADATA[key as keyof typeof FEATURE_FLAG_METADATA]?.label} has been ${value ? 'enabled' : 'disabled'}.` });
    }
    setIsUpdating(prev => ({ ...prev, [key]: false }));
  };
  
  const handleCacheCleanup = async () => {
    setIsCleaningCache(true);
    const result = await triggerCacheCleanup();
    if(result.success) {
        toast({ title: 'Cache Cleanup', description: result.message });
    } else {
        toast({ title: 'Error', description: result.error, variant: 'destructive' });
    }
    setIsCleaningCache(false);
  }

  const handleApiKeysUpdate = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setIsUpdatingApiKeys(true);
    try {
      await updateEncryptedSetting('global_gemini_api_key_1', apiKeys.gemini1);
      await updateEncryptedSetting('global_gemini_api_key_2', apiKeys.gemini2);
      await updateEncryptedSetting('global_gemini_api_key_3', apiKeys.gemini3);
      await updateEncryptedSetting('global_fal_api_key', apiKeys.fal);
      toast({ title: 'API Keys Updated', description: 'Global API keys have been saved.' });
    } catch (error) {
      toast({ title: 'Error', description: 'Failed to update API keys.', variant: 'destructive' });
    } finally {
      setIsUpdatingApiKeys(false);
    }
  };

  return (
    <div className="grid gap-6">
        <Card variant="glass">
            <CardHeader>
                <CardTitle>Feature Flags</CardTitle>
                <CardDescription>Enable or disable major application features in real-time.</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
                {Object.entries(FEATURE_FLAG_METADATA).map(([key, meta]) => {
                    const Icon = meta.icon;
                    return (
                        <div key={key} className="flex items-center justify-between p-3 border rounded-lg">
                            <div className="flex items-center gap-3">
                                <Icon className="h-5 w-5 text-muted-foreground" />
                                <div>
                                    <Label htmlFor={key} className="font-medium">{meta.label}</Label>
                                    <p className="text-xs text-muted-foreground">{meta.description}</p>
                                </div>
                            </div>
                            <div className="flex items-center gap-2">
                                {isUpdating[key as SettingKey] && <Loader2 className="h-4 w-4 animate-spin" />}
                                <Switch
                                    id={key}
                                    checked={!!settings[key as SettingKey]}
                                    onCheckedChange={(checked) => handleSettingChange(key as SettingKey, checked)}
                                    disabled={!!isUpdating[key as SettingKey]}
                                />
                            </div>
                        </div>
                    )
                })}
            </CardContent>
        </Card>
        
        <Card variant="glass">
            <CardHeader>
                <CardTitle>System Maintenance</CardTitle>
                <CardDescription>Run maintenance tasks to keep the application running smoothly.</CardDescription>
            </CardHeader>
            <CardContent>
                 <div className="flex items-center justify-between p-3 border rounded-lg">
                    <div>
                        <Label className="font-medium">Clean Image Cache</Label>
                        <p className="text-xs text-muted-foreground">Removes old processed images (e.g., background-removed, upscaled) from the server to save space.</p>
                    </div>
                    <Button onClick={handleCacheCleanup} disabled={isCleaningCache}>
                        {isCleaningCache ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
                        Run Cleanup
                    </Button>
                </div>
            </CardContent>
        </Card>

        <Card variant="glass">
          <CardHeader>
            <CardTitle>Global API Keys</CardTitle>
            <CardDescription>Set the system-wide default API keys for AI services. User-specific keys will override these.</CardDescription>
          </CardHeader>
          <CardContent>
            <form onSubmit={handleApiKeysUpdate} className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="global_gemini_api_key_1">Global Gemini API Key 1</Label>
                <Input id="global_gemini_api_key_1" type="password" value={apiKeys.gemini1} onChange={(e: React.ChangeEvent<HTMLInputElement>) => setApiKeys(prev => ({...prev, gemini1: e.target.value}))} placeholder={maskedApiKeys?.gemini1 || undefined} />
                {maskedApiKeys?.gemini1 && <div className="text-xs text-muted-foreground">Current: {maskedApiKeys.gemini1}</div>}
              </div>
              <div className="space-y-2">
                <Label htmlFor="global_gemini_api_key_2">Global Gemini API Key 2</Label>
                <Input id="global_gemini_api_key_2" type="password" value={apiKeys.gemini2} onChange={(e: React.ChangeEvent<HTMLInputElement>) => setApiKeys(prev => ({...prev, gemini2: e.target.value}))} placeholder={maskedApiKeys?.gemini2 || undefined} />
                {maskedApiKeys?.gemini2 && <div className="text-xs text-muted-foreground">Current: {maskedApiKeys.gemini2}</div>}
              </div>
              <div className="space-y-2">
                <Label htmlFor="global_gemini_api_key_3">Global Gemini API Key 3</Label>
                <Input id="global_gemini_api_key_3" type="password" value={apiKeys.gemini3} onChange={(e: React.ChangeEvent<HTMLInputElement>) => setApiKeys(prev => ({...prev, gemini3: e.target.value}))} placeholder={maskedApiKeys?.gemini3 || undefined} />
                {maskedApiKeys?.gemini3 && <div className="text-xs text-muted-foreground">Current: {maskedApiKeys.gemini3}</div>}
              </div>
              <div className="space-y-2">
                <Label htmlFor="global_fal_api_key">Global Fal.ai API Key</Label>
                <Input id="global_fal_api_key" type="password" value={apiKeys.fal} onChange={(e: React.ChangeEvent<HTMLInputElement>) => setApiKeys(prev => ({...prev, fal: e.target.value}))} placeholder={maskedApiKeys?.fal || undefined} />
                {maskedApiKeys?.fal && <div className="text-xs text-muted-foreground">Current: {maskedApiKeys.fal}</div>}
              </div>
              <div className="flex justify-end">
                <Button type="submit" disabled={isUpdatingApiKeys}>
                  {isUpdatingApiKeys ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <KeyRound className="mr-2 h-4 w-4" />}
                  Save API Keys
                </Button>
              </div>
            </form>
          </CardContent>
        </Card>
    </div>
  );
}
</file>

<file path="src/app/admin/settings/page.tsx">
// src/app/admin/settings/page.tsx
import { getAllSettings, getGlobalApiKeysForDisplay } from '@/actions/adminActions';
import { PageHeader } from '@/components/ui/page-header';
import { Settings } from 'lucide-react';
import { SettingsForm } from './_components/SettingsForm';

export default async function AdminSettingsPage() {
  const initialSettings = await getAllSettings();
  const maskedApiKeys = await getGlobalApiKeysForDisplay();

  return (
    <div className="space-y-8">
      <PageHeader
        icon={Settings}
        title="Application Settings"
        description="Manage feature flags and perform system maintenance."
        className="text-left py-0"
      />
      <SettingsForm initialSettings={initialSettings} maskedApiKeys={maskedApiKeys} />
    </div>
  );
}
</file>

<file path="src/app/admin/users/page.tsx">
// src/app/admin/users/page.tsx
import { getAllUsers } from '@/actions/adminActions';
import { UserManagementTable } from '@/components/admin/UserManagementTable';
import { PageHeader } from '@/components/ui/page-header';
import { Users } from 'lucide-react';

export default async function AdminUsersPage() {
  const initialUsers = await getAllUsers();

  return (
    <div className="space-y-8">
      <PageHeader
        icon={Users}
        title="User Management"
        description="Create, view, and manage user accounts and roles."
        className="text-left py-0"
      />
      <UserManagementTable initialUsers={initialUsers} />
    </div>
  );
}
</file>

<file path="src/app/api/debug/complete-video/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { updateVideoHistoryItem } from '@/actions/historyActions';
import { getCurrentUser } from '@/actions/authActions';

export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'User not authenticated' }, { status: 401 });
    }

    const { historyItemId, localVideoUrl, remoteVideoUrl, seed } = await request.json();

    if (!historyItemId) {
      return NextResponse.json({ error: 'historyItemId is required' }, { status: 400 });
    }

    // Simulate webhook completion
    await updateVideoHistoryItem({
      username: user.username,
      historyItemId,
      videoUrls: [remoteVideoUrl || 'https://example.com/test-video.mp4'],
      localVideoUrl: localVideoUrl || '/uploads/generated_videos/test-video.mp4',
      seedUsed: seed || 12345,
      status: 'completed'
    });

    return NextResponse.json({ 
      success: true, 
      message: 'Video marked as completed',
      historyItemId,
      localVideoUrl,
      remoteVideoUrl
    });

  } catch (error) {
    console.error('Error in test completion:', error);
    return NextResponse.json({ 
      error: 'Failed to mark video as completed',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}
</file>

<file path="src/app/api/debug/history/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { getCurrentUser } from '@/actions/authActions';
import { getUserHistory, getVideoHistoryPaginated } from '@/actions/historyActions';

export async function GET(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'User not authenticated' }, { status: 401 });
    }

    // Get all user history (both image and video)
    const imageHistory = await getUserHistory();
    
    // Get video history separately with status information
    const videoHistoryResult = await getVideoHistoryPaginated(1, 100);
    
    // Add detailed debugging information
    const debugInfo = {
      user: user.username,
      imageHistoryCount: imageHistory.length,
      videoHistoryCount: videoHistoryResult.items.length,
      videoHistoryItems: videoHistoryResult.items.map(item => ({
        id: item.id,
        timestamp: item.timestamp,
        hasVideoGenerationParams: !!item.videoGenerationParams,
        videoGenerationStatus: (item.videoGenerationParams as any)?.status,
        hasLocalVideoUrl: !!item.videoGenerationParams?.localVideoUrl,
        hasGeneratedVideoUrls: !!item.generatedVideoUrls,
        generatedVideoUrlsCount: item.generatedVideoUrls?.length || 0,
        nonNullVideoUrls: item.generatedVideoUrls?.filter(url => url !== null).length || 0,
        localVideoUrl: item.videoGenerationParams?.localVideoUrl,
        generatedVideoUrls: item.generatedVideoUrls,
        videoGenerationParams: item.videoGenerationParams
      })),
      itemsWithVideoParams: imageHistory.filter(item => !!item.videoGenerationParams).map(item => ({
        id: item.id,
        timestamp: item.timestamp,
        status: (item.videoGenerationParams as any)?.status,
        hasLocalVideoUrl: !!item.videoGenerationParams?.localVideoUrl,
        localVideoUrl: item.videoGenerationParams?.localVideoUrl
      }))
    };
    
    return NextResponse.json({
      imageHistory,
      videoHistory: videoHistoryResult.items,
      debug: debugInfo,
      success: true
    });

  } catch (error) {
    console.error('Error fetching debug history:', error);
    return NextResponse.json({ 
      error: 'Failed to fetch debug history',
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}
</file>

<file path="src/app/api/history/[itemId]/status/route.ts">
// src/app/api/history/[itemId]/status/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getHistoryItemStatus } from '@/services/database.service';
import { getCurrentUser } from '@/actions/authActions';

export async function GET(request: NextRequest, { params }: { params: Promise<{ itemId: string }> }) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ error: 'User not authenticated' }, { status: 401 });
    }

    const { itemId } = await params;
    if (!itemId) {
      return NextResponse.json({ error: 'History item ID is required' }, { status: 400 });
    }

    // Use our new, efficient, and secure database function
    const statusPayload = getHistoryItemStatus(itemId, user.username);

    if (!statusPayload) {
      return NextResponse.json(
        { error: 'History item not found or you do not have permission to view it.' },
        { status: 404 }
      );
    }
    
    // Return the specific status payload
    return NextResponse.json(statusPayload, { status: 200 });

  } catch (error) {
    console.error(`Error fetching status for history item:`, error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown server error';
    return NextResponse.json({ error: 'Failed to fetch status', details: errorMessage }, { status: 500 });
  }
}
</file>

<file path="src/app/api/image-proxy/[...slug]/route.ts">
import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import mime from 'mime-types';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ slug: string[] }> }
) {
  const { slug } = await params;

  if (!slug || !Array.isArray(slug)) {
    return new NextResponse('Invalid image path', { status: 400 });
  }

  const imageSubPath = slug.join('/');

  // Enhanced path sanitization
  const intendedBaseDir = path.resolve(process.cwd(), 'public', 'uploads');
  const requestedFilePath = path.resolve(intendedBaseDir, imageSubPath);

  // Check if the resolved path is still within the intended base directory
  if (!requestedFilePath.startsWith(intendedBaseDir + path.sep)) {
    // path.sep is added to ensure "startsWith" doesn't match a directory that is a prefix of intendedBaseDir
    // e.g. /public/uploads-something if intendedBaseDir is /public/uploads
    // Although with path.resolve this is less likely, it's a good safeguard.
    // More importantly, this catches directory traversal like /public/uploads/../../secret.txt
    // where requestedFilePath would resolve to /secret.txt
    console.warn(`[IMAGE-PROXY] Directory traversal attempt or invalid path structure:
      Base: ${intendedBaseDir}
      SubPath: ${imageSubPath}
      Resolved: ${requestedFilePath}`);
    return new NextResponse('Invalid path', { status: 400 });
  }

  // The requestedFilePath is now considered safe for existence check
  console.log(`[IMAGE-PROXY] Attempting to serve image from: ${requestedFilePath}`);

  if (fs.existsSync(requestedFilePath)) {
    try {
      const fileBuffer = fs.readFileSync(requestedFilePath);
      const mimeType = mime.lookup(requestedFilePath) || 'application/octet-stream';
      
      console.log(`[IMAGE-PROXY] Successfully serving ${requestedFilePath} as ${mimeType}`);
      
      return new NextResponse(fileBuffer, {
        status: 200,
        headers: { 
          'Content-Type': mimeType,
          'Cache-Control': 'public, max-age=3600', // Cache for 1 hour
        },
      });
    } catch (error) {
      console.error('[IMAGE-PROXY] Error serving image:', error);
      return new NextResponse('Error serving file', { status: 500 });
    }
  } else {
    console.log(`[IMAGE-PROXY] Image not found at: ${requestedFilePath}`);
    return new NextResponse('Image not found', { status: 404 });
  }
}
</file>

<file path="src/app/api/upload-user-image/route.test.ts">
// @ts-nocheck
import { POST } from './route'; // Assuming route.ts is in the same directory
import { NextRequest } from 'next/server';
import { uploadToFalStorage, isFalVideoGenerationAvailable } from '@/ai/actions/generate-video.action';

// Mock dependencies
jest.mock('@/ai/actions/generate-video.action', () => ({
  uploadToFalStorage: jest.fn(),
  isFalVideoGenerationAvailable: jest.fn(),
}));

// Helper to create a mock NextRequest
function createMockRequest(body: any, contentType: string): NextRequest {
  const request = new NextRequest('http://localhost/api/upload-user-image', {
    method: 'POST',
    headers: { 'Content-Type': contentType },
    body: contentType.includes('json') ? JSON.stringify(body) : body, // body for FormData would be FormData itself
  });
  return request;
}

// Test dataURItoBlob (extracted and made available for testing, or tested via API behavior)
// For simplicity here, we'll test its effect through the API route.
// If it were exported, we'd test it directly:
// import { dataURItoBlob } from './route'; // if exported
// describe('dataURItoBlob', () => { ... })

describe('/api/upload-user-image POST', () => {
  beforeEach(() => {
    // Reset mocks before each test
    (uploadToFalStorage as jest.Mock).mockReset();
    (isFalVideoGenerationAvailable as jest.Mock).mockReset();
  });

  it('should return 503 if Fal service is unavailable', async () => {
    (isFalVideoGenerationAvailable as jest.Mock).mockResolvedValue(false);
    const request = createMockRequest({}, 'application/json');
    const response = await POST(request);
    const json = await response.json();

    expect(response.status).toBe(503);
    expect(json.success).toBe(false);
    expect(json.error).toContain('FAL_KEY missing');
  });

  it('should return 415 for unsupported content type', async () => {
    (isFalVideoGenerationAvailable as jest.Mock).mockResolvedValue(true);
    const request = createMockRequest({}, 'text/plain');
    const response = await POST(request);
    const json = await response.json();

    expect(response.status).toBe(415);
    expect(json.success).toBe(false);
    expect(json.error).toBe('Unsupported Content-Type');
  });

  describe('JSON imageDataUri uploads', () => {
    const testImageDataUri = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='; // 1x1 black PNG

    it('should successfully process imageDataUri and call uploadToFalStorage', async () => {
      (isFalVideoGenerationAvailable as jest.Mock).mockResolvedValue(true);
      (uploadToFalStorage as jest.Mock).mockResolvedValue('http://fake.fal.url/image.png');

      const request = createMockRequest({ imageDataUri: testImageDataUri }, 'application/json');
      const response = await POST(request);
      const json = await response.json();

      expect(response.status).toBe(200);
      expect(json.success).toBe(true);
      expect(json.imageUrl).toBe('http://fake.fal.url/image.png');
      expect(json.fileName).toMatch(/^cropped_image_\d+\.png$/);
      expect(uploadToFalStorage).toHaveBeenCalledTimes(1);
      const blobArg = (uploadToFalStorage as jest.Mock).mock.calls[0][0] as Blob;
      expect(blobArg).toBeInstanceOf(Blob);
      expect(blobArg.type).toBe('image/png');
      expect(blobArg.size).toBeGreaterThan(0);
    });

    it('should return 400 if imageDataUri is missing in JSON', async () => {
      (isFalVideoGenerationAvailable as jest.Mock).mockResolvedValue(true);
      const request = createMockRequest({}, 'application/json'); // Empty JSON body
      const response = await POST(request);
      const json = await response.json();

      expect(response.status).toBe(400);
      expect(json.success).toBe(false);
      expect(json.error).toBe('No imageDataUri provided in JSON body');
    });

    it('should handle errors from uploadToFalStorage', async () => {
        (isFalVideoGenerationAvailable as jest.Mock).mockResolvedValue(true);
        (uploadToFalStorage as jest.Mock).mockRejectedValue(new Error('Fal storage failed'));

        const request = createMockRequest({ imageDataUri: testImageDataUri }, 'application/json');
        const response = await POST(request);
        const json = await response.json();

        expect(response.status).toBe(500);
        expect(json.success).toBe(false);
        expect(json.error).toBe('Fal storage failed');
      });
  });

  describe('FormData file uploads', () => {
    it('should successfully process FormData file and call uploadToFalStorage', async () => {
      (isFalVideoGenerationAvailable as jest.Mock).mockResolvedValue(true);
      (uploadToFalStorage as jest.Mock).mockResolvedValue('http://fake.fal.url/formdata.jpg');

      const mockFile = new File(['dummy content'], 'formdata.jpg', { type: 'image/jpeg' });
      const formData = new FormData();
      formData.append('file', mockFile);

      // For FormData, the body is the FormData object itself, and NextRequest handles it.
      // However, creating a realistic NextRequest with FormData body in Jest without a browser env is tricky.
      // We'll simulate the structure the route expects after request.formData()

      const request = new NextRequest('http://localhost/api/upload-user-image', {
        method: 'POST',
        body: formData,
        // Content-Type header is automatically set by FormData in browsers/fetch,
        // but might need explicit mock if createMockRequest doesn't handle it well.
        // For this test, we assume NextRequest constructor or test env handles it.
      });

      // If direct FormData in NextRequest constructor is problematic in test env:
      // We might need to mock request.formData() itself.
      // jest.spyOn(request, 'formData').mockResolvedValue(formData);


      const response = await POST(request);
      const json = await response.json();

      expect(response.status).toBe(200);
      expect(json.success).toBe(true);
      expect(json.imageUrl).toBe('http://fake.fal.url/formdata.jpg');
      expect(json.fileName).toBe('formdata.jpg');
      expect(uploadToFalStorage).toHaveBeenCalledTimes(1);
      const fileArg = (uploadToFalStorage as jest.Mock).mock.calls[0][0] as File;
      expect(fileArg).toBeInstanceOf(File);
      expect(fileArg.name).toBe('formdata.jpg');
      expect(fileArg.type).toBe('image/jpeg');
    });

    it('should return 400 if no file is provided in FormData', async () => {
        (isFalVideoGenerationAvailable as jest.Mock).mockResolvedValue(true);
        const formData = new FormData(); // Empty FormData

        const request = new NextRequest('http://localhost/api/upload-user-image', {
            method: 'POST',
            body: formData,
          });
        // jest.spyOn(request, 'formData').mockResolvedValue(formData); // Mock if needed

        const response = await POST(request);
        const json = await response.json();

        expect(response.status).toBe(400);
        expect(json.success).toBe(false);
        expect(json.error).toBe('No file provided in formData');
      });
  });

  // TODO: Add tests for file type validation and size validation for both JSON and FormData
  // For example:
  // it('should return 400 for invalid file type in JSON upload', async () => { ... });
  // it('should return 400 for file too large in FormData upload', async () => { ... });

});
</file>

<file path="src/app/api/upload-user-image/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { uploadToFalStorage, isFalVideoGenerationAvailable } from '@/ai/actions/generate-video.action';
import { Buffer } from 'buffer';
import { getCurrentUser } from '@/actions/authActions';

// Helper function to convert Data URI to Blob
function dataURItoBlob(dataURI: string): Blob {
  const byteString = Buffer.from(dataURI.split(',')[1], 'base64').toString('binary');
  const mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  return new Blob([ab], { type: mimeString });
}

export async function POST(request: NextRequest) {
  try {
    const user = await getCurrentUser();
    if (!user) {
      return NextResponse.json({ success: false, error: 'Authentication required.' }, { status: 401 });
    }
    if (!(await isFalVideoGenerationAvailable())) {
      return NextResponse.json(
        { success: false, error: 'Image upload service is not configured (FAL_KEY missing).' },
        { status: 503 }
      );
    }

    let file: File | Blob;
    let fileName: string = 'uploaded_image.png'; // Default filename

    const contentType = request.headers.get('content-type') || '';

    if (contentType.includes('multipart/form-data')) {
      const formData = await request.formData();
      const inputFile = formData.get('file') as File;
      if (!inputFile) {
        return NextResponse.json({ success: false, error: 'No file provided in formData' }, { status: 400 });
      }
      file = inputFile;
      fileName = inputFile.name;
    } else if (contentType.includes('application/json')) {
      const body = await request.json();
      const imageDataUri = body.imageDataUri as string;
      if (!imageDataUri) {
        return NextResponse.json({ success: false, error: 'No imageDataUri provided in JSON body' }, { status: 400 });
      }
      file = dataURItoBlob(imageDataUri);
      // Attempt to extract a meaningful filename or use a default
      const mimeType = imageDataUri.match(/data:(image\/\w+);base64,/)?.[1] || 'image/png';
      const extension = mimeType.split('/')[1] || 'png';
      fileName = `cropped_image_${Date.now()}.${extension}`;
    } else {
      return NextResponse.json({ success: false, error: 'Unsupported Content-Type' }, { status: 415 });
    }

    // Validate file type (extracted from Blob/File)
    const allowedTypes = [
      'image/png', 'image/jpeg', 'image/webp', 'image/gif',
      'image/heic', 'image/heif', 'image/avif',
    ];
    if (!allowedTypes.includes(file.type)) {
      return NextResponse.json(
        { success: false, error: `Invalid file type: ${file.type}. Allowed: ${allowedTypes.join(', ')}` },
        { status: 400 }
      );
    }

    // Validate file size
    const maxSize = 25 * 1024 * 1024; // 25MB
    if (file.size > maxSize) {
      return NextResponse.json(
        { success: false, error: `File too large. Maximum size is ${maxSize / (1024 * 1024)}MB.` },
        { status: 400 }
      );
    }

    console.log(`Processing image for Fal Storage upload: ${fileName}, type: ${file.type}, size: ${file.size} bytes`);

    // Ensure 'file' is a File object if 'uploadToFalStorage' expects it
    // The current `uploadToFalStorage` in `generate-video.ts` takes `File | Blob`
    // so no explicit conversion is needed here if `file` is already a Blob from dataURI.
    const falImageUrl = await uploadToFalStorage(file, user.username);

    console.log(`File uploaded to Fal Storage, URL: ${falImageUrl}`);

    return NextResponse.json({
      success: true,
      imageUrl: falImageUrl,
      fileName: fileName
    });

  } catch (error: any) {
    console.error('Error in image upload endpoint:', error);
    let errorMessage = 'Internal server error during image upload.';
    if (error.message) {
      errorMessage = error.message;
    }
    if (error.message && error.message.toLowerCase().includes('fal_key')) {
      return NextResponse.json(
        { success: false, error: 'Image upload service is not configured (FAL_KEY missing for storage).' },
        { status: 503 }
      );
    }
    return NextResponse.json(
      { success: false, error: errorMessage },
      { status: 500 }
    );
  }
}
</file>

<file path="src/app/api/v1/generate/route.ts">
// src/app/api/v1/generate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { authenticateApiRequest } from '@/lib/api-auth';
import { createApiJob, processApiGenerationJob } from '@/actions/apiActions';
import { z } from 'zod';

const ModelAttributesSchema = z.object({
  gender: z.string(),
  bodyType: z.string(),
  bodySize: z.string(),
  ageRange: z.string(),
  ethnicity: z.string(),
  poseStyle: z.string(),
  background: z.string(),
  fashionStyle: z.string(),
  hairStyle: z.string(),
  modelExpression: z.string(),
  lightingType: z.string(),
  lightQuality: z.string(),
  cameraAngle: z.string(),
  lensEffect: z.string(),
  depthOfField: z.string(),
  timeOfDay: z.string(),
  overallMood: z.string(),
  fabricRendering: z.string(),
});

const GenerateRequestSchema = z.object({
  imageDataUri: z.string().optional(),
  imageUrl: z.string().url().optional(),
  parameters: ModelAttributesSchema,
  settingsMode: z.enum(['basic', 'advanced']).default('basic'),
});

export async function POST(request: NextRequest) {
  try {
    // Authenticate
    const user = await authenticateApiRequest(request);
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Parse and validate request body
    const body = await request.json();
    const validatedData = GenerateRequestSchema.parse(body);

    // Use imageUrl if provided, otherwise imageDataUri
    const imageDataSource = validatedData.imageUrl || validatedData.imageDataUri;
    if (!imageDataSource) {
      return NextResponse.json({
        error: 'Either imageDataUri or imageUrl is required.'
      }, { status: 400 });
    }

    // Create job record
    const jobId = await createApiJob({
      username: user.username,
      imageDataUri: imageDataSource,
      parameters: validatedData.parameters,
      settingsMode: validatedData.settingsMode,
    });

    // Start processing in background (don't await)
    processApiGenerationJob(jobId, {
      imageDataUri: imageDataSource,
      parameters: validatedData.parameters,
      settingsMode: validatedData.settingsMode,
    }, user.username).catch(console.error);

    // Return immediately with job ID
    return NextResponse.json({
      jobId,
      status: 'processing'
    }, { status: 202 });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({
        error: 'Invalid request data',
        details: error.errors
      }, { status: 400 });
    }

    console.error('API generate error:', error);
    return NextResponse.json({
      error: 'Internal server error'
    }, { status: 500 });
  }
}
</file>

<file path="src/app/api/v1/status/[jobId]/route.ts">
// src/app/api/v1/status/[jobId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { authenticateApiRequest } from '@/lib/api-auth';
import { findHistoryItemById } from '@/services/database.service';
import { getDisplayableImageUrl } from '@/lib/utils';

export async function GET(request: NextRequest, { params }: { params: Promise<{ jobId: string }> }) {
  try {
    // Authenticate
    const user = await authenticateApiRequest(request);
    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Extract jobId from params
    const { jobId } = await params;

    // Look up job status
    const historyItem = findHistoryItemById(jobId);
    if (!historyItem) {
      return NextResponse.json({ error: 'Job not found' }, { status: 404 });
    }

    // Verify ownership
    if (historyItem.username !== user.username) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // Return response based on status
    if (historyItem.status === 'processing') {
      return NextResponse.json({
        jobId,
        status: 'processing'
      });
    } else if (historyItem.status === 'completed') {
      // Use the public app URL from environment variables for correct URL construction.
      const baseUrl = process.env.NEXT_PUBLIC_APP_URL;
      if (!baseUrl) {
        console.error('CRITICAL: NEXT_PUBLIC_APP_URL is not set. Cannot form absolute URLs for API response.');
        return NextResponse.json({ error: 'Server configuration error: App URL not set.' }, { status: 500 });
      }

      // Use the getDisplayableImageUrl utility to create PROXY URLs
      const proxiedUrls = historyItem.editedImageUrls
        .filter((url): url is string => !!url) // Ensure we only process non-null URLs
        .map(url => getDisplayableImageUrl(url));
        
      // Make sure the URLs are absolute before sending them to the external plugin
      const absoluteImageUrls = proxiedUrls
        .filter((url): url is string => !!url)
        .map(url => url.startsWith('http') ? url : `${baseUrl}${url}`);

      return NextResponse.json({
        jobId,
        status: 'completed',
        generatedImageUrls: absoluteImageUrls
      });
    } else if (historyItem.status === 'failed') {
      return NextResponse.json({
        jobId,
        status: 'failed',
        error: historyItem.error || 'Unknown error occurred'
      });
    } else {
      return NextResponse.json({
        jobId,
        status: 'unknown'
      });
    }

  } catch (error) {
    console.error('API status error:', error);
    return NextResponse.json({
      error: 'Internal server error'
    }, { status: 500 });
  }
}
</file>

<file path="src/app/api/video/start/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { startVideoGenerationAndCreateHistory } from '@/ai/actions/generate-video.action';

export async function POST(request: NextRequest) {
  try {
    const videoInput = await request.json();
    
    const result = await startVideoGenerationAndCreateHistory(videoInput);
    
    if (result.error) {
      return NextResponse.json({ error: result.error }, { status: 400 });
    }
    
    return NextResponse.json({ 
      taskId: result.taskId, 
      historyItemId: result.historyItemId,
      success: true 
    });
    
  } catch (error) {
    console.error('Error in video start API:', error);
    return NextResponse.json({ 
      error: 'Failed to start video generation' 
    }, { status: 500 });
  }
}
</file>

<file path="src/app/api/video/webhook/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { updateVideoHistoryItem } from '@/actions/historyActions';
import { saveFileFromUrl } from '@/services/storage.service';

export async function POST(request: NextRequest) {
  try {
    // Get the raw body for signature verification
    const bodyText = await request.text();
    const bodyBuffer = Buffer.from(bodyText, 'utf-8');
    
    // Parse the JSON after we have the raw body
    let result;
    try {
      result = JSON.parse(bodyText);
    } catch (error) {
      console.error('Invalid JSON in webhook body:', error);
      return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 });
    }

    const url = new URL(request.url);
    console.log('Webhook received:', JSON.stringify(result, null, 2));

    // WARNING: Signature verification is not implemented.
    // For production, it's highly recommended to implement webhook signature verification
    // to ensure requests are genuinely from Fal.ai.
    console.warn('Webhook signature verification disabled - processing request without verification');

    // Extract our custom payload from query parameters
    const historyItemId = url.searchParams.get('historyItemId');
    const username = url.searchParams.get('username');

    if (!historyItemId || !username) {
      console.error('Webhook received incomplete params:', { historyItemId, username });
      return NextResponse.json({ error: 'Incomplete webhook parameters' }, { status: 400 });
    }

    // Check if the result indicates an error (Fal.ai webhook format)
    if (result.status === 'ERROR' || result.error) {
      console.error('fal.ai returned error:', result.error || 'Unknown error');
      
      // Update history item with error status
      await updateVideoHistoryItem({
        username,
        historyItemId,
        videoUrls: [null],
        localVideoUrl: null,
        seedUsed: null,
        status: 'failed',
        error: result.error || 'Video generation failed'
      });

      return NextResponse.json({ success: true, handled: 'error' });
    }

    // Extract video result for successful generation (Fal.ai webhook format)
    if (result.status !== 'OK') {
      console.error('Unexpected status from fal.ai:', result.status);
      
      await updateVideoHistoryItem({
        username,
        historyItemId,
        videoUrls: [null],
        localVideoUrl: null,
        seedUsed: null,
        status: 'failed',
        error: `Unexpected status: ${result.status}`
      });

      return NextResponse.json({ success: true, handled: 'unexpected_status' });
    }

    const falVideoUrl = result.payload?.video?.url;
    const seedUsed = result.payload?.seed;

    if (!falVideoUrl) {
      console.error('No video URL in successful result:', result.payload);
      
      await updateVideoHistoryItem({
        username,
        historyItemId,
        videoUrls: [null],
        localVideoUrl: null,
        seedUsed: seedUsed,
        status: 'failed',
        error: 'No video URL returned from fal.ai'
      });

      return NextResponse.json({ success: true, handled: 'no_video' });
    }

    // Download the video from the temporary fal.ai URL and save it locally
    const { relativeUrl: localVideoUrl } = await saveFileFromUrl(falVideoUrl, 'RefashionAI_video', 'generated_videos', 'mp4');
    
    // 6. Update the history item with the final details
    await updateVideoHistoryItem({
      username,
      historyItemId,
      videoUrls: [falVideoUrl], // Store remote URL for potential future use
      localVideoUrl: localVideoUrl,
      seedUsed: seedUsed,
      status: 'completed'
    });

    console.log(`Webhook processed successfully for history item ${historyItemId}`);
    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('Error processing fal.ai webhook:', error);
    
    // Try to update the history item with error status if we have the params
    try {
      const url = new URL(request.url);
      const historyItemId = url.searchParams.get('historyItemId');
      const username = url.searchParams.get('username');
      
      if (historyItemId && username) {
        await updateVideoHistoryItem({
          username,
          historyItemId,
          videoUrls: [null],
          localVideoUrl: null,
          seedUsed: null,
          status: 'failed',
          error: 'Webhook processing failed'
        });
      }
    } catch (updateError) {
      console.error('Failed to update history item with error status:', updateError);
    }
    
    return NextResponse.json({ error: 'Webhook processing failed' }, { status: 500 });
  }
}
</file>

<file path="src/app/create/page.tsx">
// src/app/create/page.tsx
import CreationHub from "@/components/creation-hub";
import { PageHeader } from "@/components/ui/page-header";
import { Palette } from "lucide-react"; // Import a suitable icon

export default function CreatePage() {
  return (
    <div className="container mx-auto max-w-7xl px-4 py-10 space-y-8">
      <PageHeader
        icon={Palette}
        title="Creation Hub"
        description="Generate new fashion images and videos using your uploaded clothing."
      />
      <CreationHub />
    </div>
  );
}
</file>

<file path="src/app/globals.css">
/* globals.css - Alternative 1: Deep Ocean Elegance */

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Motion constants for optimized animations */
:root {
  --motion-spring-quick: 450ms linear(0, 0.2348, 0.6075, 0.8763, 1.0076, 1.0451, 1.0389, 1.0217, 1.0079, 1.0006, 0.9981, 0.9981, 0.9988, 0.9995, 1);
  --motion-spring-standard: 900ms linear(0, 0.0697, 0.2323, 0.4311, 0.6265, 0.7946, 0.9243, 1.0138, 1.0669, 1.0909, 1.094, 1.0837, 1.0666, 1.0476, 1.0297, 1.0149, 1.0039, 0.9967, 0.9926, 0.9911, 0.9913, 0.9926, 0.9943, 0.9961, 0.9977, 0.999, 0.9999, 1.0005, 1, 1);
  --motion-bounce-subtle: 0.6s linear(0, 0.0022, 0.0087, 0.0196, 0.0348, 0.0543, 0.0782, 0.1065, 0.139, 0.176, 0.2173, 0.2629, 0.3128, 0.3672, 0.4258, 0.4888, 0.5562, 0.6279, 0.7039, 0.7843, 0.869, 0.9581, 0.9752, 0.9332, 0.8954, 0.8621, 0.833, 0.8083, 0.788, 0.772, 0.7603, 0.753, 0.7501, 0.7515, 0.7572, 0.7673, 0.7817, 0.8004, 0.8235, 0.851, 0.8828, 0.9189, 0.9594, 0.9979, 0.9772, 0.9608, 0.9487, 0.941, 0.9377, 0.9386, 0.944, 0.9537, 0.9677, 0.986, 0.996, 0.9881, 0.9846, 0.9854, 0.9905, 1);
  --motion-duration-fast: 100ms;
  --motion-duration-quick: 200ms;
  --motion-duration-standard: 300ms;
  --motion-duration-slow: 500ms;
  --motion-ease-out: cubic-bezier(0.16, 1, 0.3, 1);
  --motion-ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);
  --motion-ease-anticipate: cubic-bezier(0.68, -0.6, 0.32, 1.6);
}

@layer base {
  /* Remove existing :root and .dark color definitions and replace with these */
  :root {
    /* Light Theme (if you ever need it, but we'll focus on dark) */
    --background: 210 20% 98%;
    --background-accent: 210 20% 94%;
    --foreground: 210 10% 23%;
    --card: 210 20% 100%;
    --card-foreground: 210 10% 23%;
    --popover: 210 20% 100%;
    --popover-foreground: 210 10% 23%;
    --primary: 173 71% 38%; /* Darker Teal for contrast on light BG */
    --primary-foreground: 173 50% 98%;
    --secondary: 210 15% 90%;
    --secondary-foreground: 210 10% 23%;
    --muted: 210 15% 94%;
    --muted-foreground: 210 10% 45%;
    --accent: 177 63% 48%;
    --accent-foreground: 210 10% 23%;
    --destructive: 0 84% 60%;
    --destructive-foreground: 0 0% 98%;
    --border: 210 10% 88%;
    --input: 210 10% 92%;
    --ring: 173 71% 42%;
    --radius: 0.75rem;
  }

  .dark {
    /* Main Dark Theme */
    --background: 224 71% 4%;          /* hsl(224, 71%, 4%) - Almost black, deep blue */
    --background-accent: 224 40% 8%;   /* hsl(224, 40%, 8%) - Slightly lighter, for depth */
    --foreground: 210 20% 92%;         /* hsl(210, 20%, 92%) - Off-white with a cool tint */
    
    --card: 224 25% 12%;               /* hsl(224, 25%, 12%) - Dark blue-gray */
    --card-foreground: 210 20% 95%;    /* hsl(210, 20%, 95%) */

    --popover: 224 71% 4%;
    --popover-foreground: 210 20% 95%;

    --primary: 173 71% 42%;            /* #1fab99 */
    --primary-foreground: 224 20% 98%; /* Very light, almost white */

    --secondary: 210 15% 23%;          /* hsl(210, 15%, 23%) - Muted dark blue */
    --secondary-foreground: 210 20% 92%;

    --muted: 210 15% 18%;
    --muted-foreground: 210 10% 65%;

    --accent: 177 63% 48%;             /* #2abab1 */
    --accent-foreground: 224 20% 98%;

    --destructive: 19 87% 51%;         /* #ef571a */
    --destructive-foreground: 0 0% 98%;

    --border: 210 10% 23%;             /* A slightly lighter blue-gray */
    --input: 210 15% 18%;
    --ring: 177 63% 55%;               /* Lighter teal for focus rings */
    --radius: 0.75rem;
  }

  @keyframes aurora-animation {
    0% { transform: translate(-50%, -50%) rotate(0deg) scale(1.2); }
    50% { transform: translate(-50%, -50%) rotate(180deg) scale(1.5); }
    100% { transform: translate(-50%, -50%) rotate(360deg) scale(1.2); }
  }

  .aurora-bg {
    content: '';
    position: fixed;
    left: 50%;
    top: 50%;
    width: 120vw;
    height: 120vh;
    max-width: 1400px;
    max-height: 1400px;
    background-image: radial-gradient(circle at 20% 20%, hsl(173 71% 42% / 0.2), transparent 40%),
                      radial-gradient(circle at 80% 30%, hsl(278 48% 28% / 0.2), transparent 40%),
                      radial-gradient(circle at 60% 80%, hsl(244 62% 30% / 0.2), transparent 40%);
    filter: blur(100px);
    z-index: -1;
    pointer-events: none;
    animation: aurora-animation 45s linear infinite;
    opacity: 0.7;
  }

  /* --- Improvement 1: Aurora Background Glow --- */
  .dark body::before {
    content: '';
    position: fixed;
    left: 50%;
    top: 15%;
    width: 600px;
    height: 600px;
    border-radius: 50%;
    background: radial-gradient(circle, hsl(var(--primary) / 0.1), transparent 65%);
    transform: translateX(-50%);
    filter: blur(120px);
    z-index: -1;
    pointer-events: none;
    opacity: 0.7;
  }

  /* --- Improvement 2: Enhanced Card Styling --- */
  .dark .card {
    position: relative;
    background-clip: padding-box;
    border: 1px solid transparent;
  }
  .dark .card::before {
    content: '';
    position: absolute;
    top: 0; right: 0; bottom: 0; left: 0;
    z-index: -1;
    margin: -1px;
    border-radius: inherit;
    background: linear-gradient(145deg, hsl(var(--primary) / 0.3), hsl(var(--border) / 0.1) 80%);
  }

  /* Ensure theme transitions are smooth when hydrated */
  html.light,
  html.dark {
    transition: none;
  }

  html, body {
    width: 100%;
    overflow-x: hidden;
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: var(--font-geist-sans), Arial, Helvetica, sans-serif;
  }

  /* --- Improvement 4: Softer Focus Rings --- */
  .dark input:focus-visible, 
  .dark textarea:focus-visible, 
  .dark [data-radix-select-trigger]:focus-visible {
    border-color: hsl(var(--primary) / 0.8) !important;
    box-shadow: 0 0 0 2px hsl(var(--primary) / 0.2) !important;
  }
}

@layer components {
  .glass-card {
    @apply border border-white/10 bg-card/50 backdrop-blur-xl shadow-2xl shadow-black/20;
    @apply transition-all duration-300;
  }
  .glass-card:hover {
    @apply border-white/20 bg-card/60;
  }
  .uploader-dropzone {
    @apply border border-white/10; /* Default border */
    position: relative;
    overflow: hidden;
  }

  .uploader-dropzone::before {
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    padding: 1px; /* border thickness */
    background: radial-gradient(400px circle at 50% 50%, hsl(var(--primary) / 0.5), transparent 40%);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask-composite: exclude;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }
  
  .uploader-dropzone[data-state='drag-over']::before {
    opacity: 1;
  }
}
</file>

<file path="src/app/history/page.tsx">
// src/app/history/page.tsx
import HistoryGallery from "@/components/history-gallery";
import { PageHeader } from "@/components/ui/page-header";
import { History } from "lucide-react"; // Using History as the icon from lucide-react

export default function HistoryPage() {
  return (
    <div className="container mx-auto max-w-7xl px-4 py-10 space-y-8">
      <PageHeader
        icon={History}
        title="Creation History"
        description="Review your past image and video generations."
      />
      <HistoryGallery />
    </div>
  );
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from 'next';
import './globals.css';
import { Toaster } from "@/components/ui/toaster";
import { AuthProvider } from '@/contexts/AuthContext';
import { ThemeProvider } from '@/contexts/ThemeContext';
import { getCurrentUser } from '@/actions/authActions';
import type { SessionUser } from '@/lib/types';
import { cookies } from 'next/headers';
import { SiteHeader } from '@/components/SiteHeader'; // Import the new header

// Force dynamic rendering to ensure authentication state is determined at request time
export const dynamic = 'force-dynamic';

export const metadata: Metadata = {
  title: 'Refashion AI',
  description: 'Edit images with the power of AI, powered by Google Gemini.',
};

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  // Force dynamic rendering by accessing cookies
  // This ensures the layout is never statically generated at build time
  await cookies();
  
  // Fetch the initial user state on the server at request time
  const initialUser: SessionUser | null = await getCurrentUser();
  
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta name="theme-color" content="#020410" />
        <link href="https://api.fontshare.com/v2/css?f[]=satoshi@700,500,400&display=swap" rel="stylesheet" />
        <script
          dangerouslySetInnerHTML={{
            __html: `
              (function() {
                function setTheme() {
                  try {
                    var theme = localStorage.getItem('theme');
                    var systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    var shouldBeDark = theme === 'dark' || (theme === 'system' && systemPrefersDark) || (!theme && true);
                    var root = document.documentElement;
                    root.classList.remove('light', 'dark');
                    root.classList.add(shouldBeDark ? 'dark' : 'light');
                  } catch (e) {
                    console.error("Error setting initial theme:", e);
                    document.documentElement.classList.add('dark'); // Default fallback
                  }
                }
                setTheme();
              })();
            `,
          }}
        />
      </head>
      <body
        className="antialiased bg-gradient-to-br from-background-accent to-background text-foreground flex flex-col min-h-screen"
        style={{
          '--font-geist-sans': 'ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"',
          '--font-geist-mono': 'ui-monospace, SFMono-Regular, "SF Mono", Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
        } as React.CSSProperties}
      >
        <div className="aurora-bg"></div>
        <AuthProvider initialUser={initialUser}>
          <ThemeProvider>
            <SiteHeader /> {/* Use the new header component here */}
            <main className="flex-1 flex flex-col">
              {children}
            </main>
            <Toaster />
          </ThemeProvider>
        </AuthProvider>
      </body>
    </html>
  );
}
</file>

<file path="src/app/login/page.tsx">
"use client";

import { useState } from 'react';
import { useRouter } from 'next/navigation'; // Ensure this is from 'next/navigation'
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { LogIn } from 'lucide-react';
import { loginUser } from '@/actions/authActions'; // Your server action

export default function LoginPage() {
  const router = useRouter();
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setLoading(true);
    setError(null);
    const formData = new FormData(event.currentTarget);
    
    try {
      const result = await loginUser(formData); // Server action

      // If loginUser returns a value, it means it didn't redirect and there was an error.
      if (result?.error) {
        setError(result.error);
      }
      // If loginUser successfully redirects, it throws a NEXT_REDIRECT error,
      // which will be caught by the catch block. Nothing else to do in the 'try' success path.

    } catch (e: unknown) {
      // Check if it's the special redirect error that Next.js throws
      const errorWithDigest = e as { digest?: string };
      if (errorWithDigest.digest?.includes('NEXT_REDIRECT')) {
        // This is an expected error when redirect() is called.
        // Next.js handles the actual navigation, so we don't need to do anything
        console.log('Login successful, redirecting...');
        return; // Exit early, don't set loading to false
      } else if (e instanceof Error) {
        // It's a different, actual error
        console.error("Login error:", e.message);
        setError(e.message);
      } else {
        console.error("Login handleSubmit caught unexpected error:", e);
        setError('An unexpected error occurred during login.');
      }
    } finally {
      // This will run regardless of success or if a redirect is in progress.
      // If the component unmounts due to redirect, setting state here is a no-op or very brief.
      setLoading(false);
    }
  };
  // ... rest of your component
  return (
    <div className="flex justify-center items-center min-h-[calc(100vh-var(--header-height,80px))] p-4 bg-gradient-to-br from-background-accent to-background">
      <Card variant="glass" className="w-full max-w-md shadow-2xl">
        <form onSubmit={handleSubmit}>
          <CardHeader className="text-center">
            <CardTitle className="text-3xl font-bold flex items-center justify-center gap-2">
              <LogIn className="h-8 w-8 text-primary" />
              Login
            </CardTitle>
            <CardDescription>Enter your credentials to access the application.</CardDescription>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="username">Username</Label>
              <Input id="username" name="username" type="text" placeholder="admin" required />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Password</Label>
              <Input id="password" name="password" type="password" required />
            </div>
            {error && <p className="text-sm text-destructive">{error}</p>}
          </CardContent>
          <CardFooter>
            <Button type="submit" className="w-full" disabled={loading}>
              {loading ? 'Logging in...' : 'Login'}
            </Button>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/manifest.json">
{
  "name": "MyWebSite",
  "short_name": "MySite",
  "icons": [
    {
      "src": "/web-app-manifest-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable"
    },
    {
      "src": "/web-app-manifest-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable"
    }
  ],
  "theme_color": "#020410",
  "background_color": "#020410",
  "display": "standalone"
}
</file>

<file path="src/components/admin/UserManagementTable.tsx">
// src/components/admin/UserManagementTable.tsx
'use client';

import { useState } from 'react';
import {
  Table, TableBody, TableCell, TableHead, TableHeader, TableRow
} from '@/components/ui/table';
import {
  Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger
} from '@/components/ui/dialog';
import {
  AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle
} from "@/components/ui/alert-dialog";
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';
import { PlusCircle, Trash2, Loader2, Edit } from 'lucide-react';
import { createUser, deleteUser, updateUserConfiguration, generateApiKeyForUser } from '@/actions/adminActions';
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@/components/ui/accordion';
import { Card, CardContent } from '@/components/ui/card';

type User = {
  username: string;
  role: 'admin' | 'user';
  // New granular modes
  gemini_api_key_1_mode: 'global' | 'user_specific';
  gemini_api_key_2_mode: 'global' | 'user_specific';
  gemini_api_key_3_mode: 'global' | 'user_specific';
  fal_api_key_mode: 'global' | 'user_specific';
};

interface UserManagementTableProps {
  initialUsers: User[];
}

export function UserManagementTable({ initialUsers }: UserManagementTableProps) {
  const { toast } = useToast();
  const [users, setUsers] = useState<User[]>(initialUsers);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isCreateDialogOpen, setIsCreateDialogOpen] = useState(false);
  const [userToDelete, setUserToDelete] = useState<User | null>(null);
  const [userToEdit, setUserToEdit] = useState<User | null>(null);
  const [generatedApiKey, setGeneratedApiKey] = useState<string | null>(null);

  const handleCreateUser = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setIsSubmitting(true);
    const formData = new FormData(event.currentTarget);
    const result = await createUser(formData);
    
    if (result.success) {
      toast({ title: 'User Created', description: `User '${formData.get('username')}' has been successfully created.` });
      // Manually add user to local state to avoid full page reload
      setUsers([
        ...users,
        {
          username: formData.get('username') as string,
          role: formData.get('role') as 'admin' | 'user',
          gemini_api_key_1_mode: 'global' as 'global',
          gemini_api_key_2_mode: 'global' as 'global',
          gemini_api_key_3_mode: 'global' as 'global',
          fal_api_key_mode: 'global' as 'global',
        },
      ].sort((a, b) => a.username.localeCompare(b.username)));
      setIsCreateDialogOpen(false);
    } else {
      toast({ title: 'Error', description: result.error, variant: 'destructive' });
    }
    setIsSubmitting(false);
  };
  
  const handleDeleteUser = async () => {
    if (!userToDelete) return;
    setIsSubmitting(true);
    const result = await deleteUser(userToDelete.username);
    if (result.success) {
      toast({ title: 'User Deleted', description: `User '${userToDelete.username}' has been deleted.` });
      setUsers(users.filter(u => u.username !== userToDelete.username));
    } else {
      toast({ title: 'Error', description: result.error, variant: 'destructive' });
    }
    setUserToDelete(null);
    setIsSubmitting(false);
  }

  const handleUpdateUser = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setIsSubmitting(true);
    const formData = new FormData(event.currentTarget);
    const result = await updateUserConfiguration(formData);
    if (result.success) {
      toast({ title: 'User Updated', description: `User '${userToEdit?.username}' has been updated.` });
      // More robust optimistic update: only update what's in the form data
      setUsers(users.map(u => {
        if (u.username === userToEdit?.username) {
          const updatedUser: User = { ...u };
          if (formData.has('role')) updatedUser.role = formData.get('role') as 'admin' | 'user';
          if (formData.has('gemini_api_key_1_mode')) updatedUser.gemini_api_key_1_mode = formData.get('gemini_api_key_1_mode') as 'global' | 'user_specific';
          if (formData.has('gemini_api_key_2_mode')) updatedUser.gemini_api_key_2_mode = formData.get('gemini_api_key_2_mode') as 'global' | 'user_specific';
          if (formData.has('gemini_api_key_3_mode')) updatedUser.gemini_api_key_3_mode = formData.get('gemini_api_key_3_mode') as 'global' | 'user_specific';
          if (formData.has('fal_api_key_mode')) updatedUser.fal_api_key_mode = formData.get('fal_api_key_mode') as 'global' | 'user_specific';
          return updatedUser;
        }
        return u;
      }));
      setUserToEdit(null);
    } else {
      toast({ title: 'Update Error', description: result.error, variant: 'destructive' });
    }
    setIsSubmitting(false);
  };

  const handleGenerateKey = async () => {
    if (!userToEdit) return;
    setIsSubmitting(true);
    const result = await generateApiKeyForUser(userToEdit.username);
    if (result.success && result.apiKey) {
      setGeneratedApiKey(result.apiKey);
      toast({ title: 'API Key Generated', description: `A new key has been generated for ${userToEdit.username}.` });
    } else {
      toast({ title: 'Error', description: result.error, variant: 'destructive' });
    }
    setIsSubmitting(false);
  };

  const getApiKeyModeSummary = (user: User) => {
    const modes = [
      user.gemini_api_key_1_mode,
      user.gemini_api_key_2_mode,
      user.gemini_api_key_3_mode,
      user.fal_api_key_mode,
    ];
    const userSpecificCount = modes.filter(m => m === 'user_specific').length;

    if (userSpecificCount === 0) return 'All Global';
    if (userSpecificCount === modes.length) return 'All User-Specific';
    return `${userSpecificCount} / ${modes.length} User-Specific`;
  };

  return (
    <>
      <div className="flex justify-end mb-4">
        <Dialog open={isCreateDialogOpen} onOpenChange={setIsCreateDialogOpen}>
          <DialogTrigger asChild>
            <Button><PlusCircle className="mr-2 h-4 w-4" /> Create User</Button>
          </DialogTrigger>
          <DialogContent>
            <form onSubmit={handleCreateUser}>
              <DialogHeader>
                <DialogTitle>Create New User</DialogTitle>
                <DialogDescription>Enter the details for the new user account.</DialogDescription>
              </DialogHeader>
              <div className="grid gap-4 py-4">
                <div className="space-y-2">
                  <Label htmlFor="username">Username</Label>
                  <Input id="username" name="username" required />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="password">Password</Label>
                  <Input id="password" name="password" type="password" required />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="role">Role</Label>
                  <Select name="role" defaultValue="user" required>
                    <SelectTrigger id="role">
                      <SelectValue placeholder="Select a role" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="user">User</SelectItem>
                      <SelectItem value="admin">Admin</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </div>
              <DialogFooter>
                <Button type="submit" disabled={isSubmitting}>
                  {isSubmitting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                  Create User
                </Button>
              </DialogFooter>
            </form>
          </DialogContent>
        </Dialog>
      </div>

      <Card variant="glass" className="hidden md:block">
        <CardContent>
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead>Username</TableHead>
                <TableHead>Role</TableHead>
                <TableHead>API Key Mode</TableHead>
                <TableHead className="text-right">Actions</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {users.map((user) => (
                <TableRow key={user.username}>
                  <TableCell className="font-medium">{user.username}</TableCell>
                  <TableCell className="capitalize">{user.role}</TableCell>
                  <TableCell>{getApiKeyModeSummary(user)}</TableCell>
                  <TableCell className="text-right">
                    <Button variant="ghost" size="icon" onClick={() => setUserToEdit(user)} disabled={isSubmitting} aria-label={`Edit ${user.username}`}>
                      <Edit className="h-4 w-4" />
                    </Button>
                    <Button variant="ghost" size="icon" onClick={() => setUserToDelete(user)} disabled={isSubmitting}>
                      <Trash2 className="h-4 w-4 text-destructive" />
                    </Button>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </CardContent>
      </Card>

      {/* Mobile Card View */}
      <div className="md:hidden space-y-4">
        {users.map((user) => (
          <Card key={user.username} variant="glass">
            <CardContent className="p-4 flex justify-between items-center">
              <div>
                <p className="font-medium">{user.username}</p>
                <p className="text-sm text-muted-foreground capitalize">Role: {user.role}</p>
                <p className="text-sm text-muted-foreground">Keys: {getApiKeyModeSummary(user)}</p>
              </div>
              <div className="flex items-center">
                 <Button variant="ghost" size="icon" onClick={() => setUserToEdit(user)} disabled={isSubmitting} aria-label={`Edit ${user.username}`}>
                    <Edit className="h-4 w-4" />
                  </Button>
                  <Button variant="ghost" size="icon" onClick={() => setUserToDelete(user)} disabled={isSubmitting}>
                    <Trash2 className="h-4 w-4 text-destructive" />
                  </Button>
              </div>
            </CardContent>
          </Card>
        ))}
         {users.length === 0 && (
            <Card>
                <CardContent className="p-6 text-center text-muted-foreground">No users found.</CardContent>
            </Card>
         )}
      </div>

      {/* Edit User Dialog */}
      <Dialog open={!!userToEdit} onOpenChange={(open) => !open && setUserToEdit(null)}>
        <DialogContent>
          <form onSubmit={handleUpdateUser}>
            <DialogHeader>
              <DialogTitle>Edit User: {userToEdit?.username}</DialogTitle>
              <DialogDescription>Update user role and API key configuration.</DialogDescription>
            </DialogHeader>
            {/* Hidden input for username */}
            <input type="hidden" name="username" value={userToEdit?.username || ''} />
            <div className="grid gap-4 py-4 max-h-[60vh] overflow-y-auto px-2">
              <div className="space-y-2">
                <Label htmlFor="edit-role">Role</Label>
                <Select name="role" defaultValue={userToEdit?.role}>
                  <SelectTrigger id="edit-role"><SelectValue /></SelectTrigger>
                  <SelectContent>
                    <SelectItem value="user">User</SelectItem>
                    <SelectItem value="admin">Admin</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <Accordion type="multiple" className="w-full">
                {[1, 2, 3].map(i => (
                  <AccordionItem key={i} value={`gemini-${i}`}>
                    <AccordionTrigger>Gemini Key {i}</AccordionTrigger>
                    <AccordionContent className="space-y-4 pt-4">
                      <div className="space-y-2">
                        <Label htmlFor={`gemini_api_key_${i}_mode`}>Mode</Label>
                        <Select name={`gemini_api_key_${i}_mode`} defaultValue={(userToEdit as any)?.[`gemini_api_key_${i}_mode`] || 'global'}>
                          <SelectTrigger id={`gemini_api_key_${i}_mode`}><SelectValue/></SelectTrigger>
                          <SelectContent><SelectItem value="global">Global</SelectItem><SelectItem value="user_specific">User-Specific</SelectItem></SelectContent>
                        </Select>
                      </div>
                      <div className="space-y-2">
                        <Label htmlFor={`gemini_api_key_${i}`}>User-Specific Key (Optional)</Label>
                        <Input id={`gemini_api_key_${i}`} name={`gemini_api_key_${i}`} type="password" placeholder="Leave blank to keep unchanged" />
                      </div>
                    </AccordionContent>
                  </AccordionItem>
                ))}
                <AccordionItem value="fal">
                  <AccordionTrigger>Fal.ai Key</AccordionTrigger>
                  <AccordionContent className="space-y-4 pt-4">
                    <div className="space-y-2">
                      <Label htmlFor="fal_api_key_mode">Mode</Label>
                      <Select name="fal_api_key_mode" defaultValue={userToEdit?.fal_api_key_mode || 'global'}>
                        <SelectTrigger id="fal_api_key_mode"><SelectValue/></SelectTrigger>
                        <SelectContent><SelectItem value="global">Global</SelectItem><SelectItem value="user_specific">User-Specific</SelectItem></SelectContent>
                      </Select>
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="fal_api_key">User-Specific Key (Optional)</Label>
                      <Input id="fal_api_key" name="fal_api_key" type="password" placeholder="Leave blank to keep unchanged" />
                    </div>
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
              <div className="pt-4 border-t">
                <Label>External API Key</Label>
                <p className="text-xs text-muted-foreground pb-2">Generate a key for integrations like WordPress.</p>
                <Button type="button" variant="secondary" onClick={handleGenerateKey} disabled={isSubmitting}>
                  Generate New API Key
                </Button>
              </div>
            </div>
            <DialogFooter>
              <Button type="submit" disabled={isSubmitting}>{isSubmitting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />} Save Changes</Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>
      
      <AlertDialog open={!!userToDelete} onOpenChange={(open) => !open && setUserToDelete(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This will permanently delete the user account for &apos;{userToDelete?.username}&apos;. This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isSubmitting}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleDeleteUser} disabled={isSubmitting} className="bg-destructive hover:bg-destructive/90">
              {isSubmitting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      <AlertDialog open={!!generatedApiKey} onOpenChange={() => setGeneratedApiKey(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>API Key Generated</AlertDialogTitle>
            <AlertDialogDescription>
              Copy this key and store it securely. You will not see it again.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <div className="p-4 bg-muted rounded-md font-mono text-sm break-all">{generatedApiKey}</div>
          <AlertDialogFooter>
            <AlertDialogAction onClick={() => {
              navigator.clipboard.writeText(generatedApiKey || '');
              toast({ title: 'Copied!' });
              setGeneratedApiKey(null);
            }}>
              Copy & Close
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
</file>

<file path="src/components/AspectRatioSelector.tsx">
// src/components/AspectRatioSelector.tsx
"use client";

import React, { useMemo } from "react";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import {
  Crop as CropIcon, Square, RectangleVertical, RectangleHorizontal
} from "lucide-react";

interface AspectRatioSelectorProps {
  preparationMode: 'image' | 'video';
  aspect: number | undefined;
  onAspectChange: (aspect: number | undefined) => void;
  disabled?: boolean;
}

export default function AspectRatioSelector({ 
  preparationMode, 
  aspect, 
  onAspectChange, 
  disabled = false 
}: AspectRatioSelectorProps) {
  const aspectRatios = useMemo(() => {
    return [
      { name: "Free", value: undefined, icon: <CropIcon /> },
      { name: "Square", value: 1, icon: <Square /> },
      { name: "Video (9:16)", value: 9 / 16, icon: <RectangleVertical /> },
      { name: "Portrait (3:4)", value: 3 / 4, icon: <RectangleVertical /> },
    ];
  }, []);

  return (
    <div className={disabled ? 'opacity-50 pointer-events-none' : ''}>
      <div className="flex justify-between items-center mb-2">
        <Label className="font-semibold">Aspect Ratio</Label>
      </div>
      <div className="flex flex-row gap-1 w-full">
        {aspectRatios.map(ar => {
          const isActive = ar.value === aspect;
          return (
            <TooltipProvider key={ar.name}>
              <Tooltip>
                <TooltipTrigger asChild>
                  <Button
                    variant={isActive ? "secondary" : "ghost"}
                    onClick={() => onAspectChange(ar.value)}
                    className="flex-col h-auto p-3 gap-1 text-xs flex-1"
                    disabled={disabled}
                  >
                    {ar.icon}
                    <span>{ar.name}</span>
                  </Button>
                </TooltipTrigger>
                <TooltipContent>{ar.name}</TooltipContent>
              </Tooltip>
            </TooltipProvider>
          );
        })}
      </div>
    </div>
  );
}
</file>

<file path="src/components/creation-hub.tsx">
// src/components/creation-hub.tsx
"use client";

import { useState, useEffect, useCallback } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import ImagePreparationContainer from "./ImagePreparationContainer";
import ImageParameters from "./image-parameters";
import VideoParameters from "./video-parameters";
import { getHistoryItemById } from "@/actions/historyActions";
import { useAuth } from "@/contexts/AuthContext";
import { useToast } from "@/hooks/use-toast";
import { useImageStore } from "@/stores/imageStore";
import type { HistoryItem } from "@/lib/types";

export default function CreationHub() {
  const { user: currentUser } = useAuth();
  const { toast } = useToast();
  const searchParams = useSearchParams();
  const router = useRouter();
  const { reset: resetStore } = useImageStore();
  const [defaultTab, setDefaultTab] = useState<string>("image");
  const [processedContextId, setProcessedContextId] = useState<string | null>(null);
  const [sourceImageUrl, setSourceImageUrl] = useState<string | null>(null);
  const [historyItemToLoad, setHistoryItemToLoad] = useState<HistoryItem | null>(null);
  const [isLoadingHistory, setIsLoadingHistory] = useState<boolean>(false);

  // Centralized reset function
  const handleReset = useCallback(() => {
    router.push('/create', { scroll: false }); // Update URL first
    resetStore();
    setSourceImageUrl(null);
    setHistoryItemToLoad(null);
    setProcessedContextId(null);
    toast({
      title: "Image Cleared",
      description: "You can now upload a new image to start over.",
    });
  }, [router, resetStore, toast]);

  // Handle URL parameters and state synchronization on component mount
  useEffect(() => {
    const historyItemId = searchParams.get('historyItemId');
    const defaultTabParam = searchParams.get('defaultTab');
    const sourceImageUrlParam = searchParams.get('sourceImageUrl');
    const currentContextId = historyItemId || sourceImageUrlParam;

    // Set default tab from URL parameter, but only if it's different to avoid re-renders
    if (defaultTabParam && (defaultTabParam === 'image' || defaultTabParam === 'video')) {
      if (defaultTab !== defaultTabParam) {
        setDefaultTab(defaultTabParam);
      }
    }

    // If there's no context, and nothing was processed, do nothing.
    if (!currentContextId && !processedContextId) {
      return;
    }

    // Reset and load history item or source image URL based on URL parameters
    if (currentContextId && currentContextId !== processedContextId) {
      setHistoryItemToLoad(null);
      if (historyItemId) {
        const loadHistoryData = async () => {
          setIsLoadingHistory(true);
          try {
            const { success, item, error } = await getHistoryItemById(historyItemId);
            if (success && item) {
              setHistoryItemToLoad(item);
              setSourceImageUrl(item.originalClothingUrl || item.videoGenerationParams?.sourceImageUrl || null);
            } else if (!success && error) {
              toast({ title: "Error Loading Configuration", description: error, variant: "destructive" });
            }
          } catch (e) {
            toast({ title: "Error Loading Configuration", description: "An unexpected error occurred.", variant: "destructive" });
          } finally {
            setIsLoadingHistory(false);
          }
        };
        loadHistoryData();
      } else if (sourceImageUrlParam) {
        setSourceImageUrl(sourceImageUrlParam);
      }
      setProcessedContextId(currentContextId);
    } else if (!currentContextId && processedContextId) {
      setSourceImageUrl(null);
      setHistoryItemToLoad(null);
      setProcessedContextId(null);
    }
  }, [searchParams, currentUser, toast, processedContextId, defaultTab]);

  return (
    <div className="space-y-8">
      {/* Tabs at the top */}
      <Tabs value={defaultTab} onValueChange={setDefaultTab} className="w-full">
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="image">Image Generation</TabsTrigger>
          <TabsTrigger value="video">Video Generation</TabsTrigger>
        </TabsList>

        <TabsContent value="image" className="space-y-6 mt-8" forceMount>
          <ImagePreparationContainer 
            sourceImageUrl={sourceImageUrl} 
            preparationMode="image" 
            onReset={handleReset}
          />
          <ImageParameters 
            historyItemToLoad={historyItemToLoad}
            isLoadingHistory={isLoadingHistory}
          />
        </TabsContent>

        <TabsContent value="video" className="space-y-6 mt-8" forceMount>
          <ImagePreparationContainer 
            sourceImageUrl={sourceImageUrl} 
            preparationMode="video" 
            onReset={handleReset}
          />
          <VideoParameters 
            historyItemToLoad={historyItemToLoad}
            isLoadingHistory={isLoadingHistory}
          />
        </TabsContent>
      </Tabs>
    </div>
  );
}
</file>

<file path="src/components/history-gallery.tsx">
// src/components/history-gallery.tsx
"use client";

import React, { useState, useEffect, useCallback, useRef } from "react";
import { motion, AnimatePresence, LayoutGroup } from "motion/react";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { getHistoryPaginated, deleteHistoryItem } from "@/actions/historyActions";
import type { HistoryItem } from "@/lib/types";
import { useToast } from "@/hooks/use-toast";
import { Loader2, AlertTriangle, ImageIcon } from "lucide-react";
import HistoryCard from "./HistoryCard";
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from "@/components/ui/alert-dialog";
import { useRouter } from "next/navigation";
import { Card, CardContent } from "@/components/ui/card";
import { HistoryDetailModal } from './HistoryDetailModal'; // Import the new image modal
import { VideoPlaybackModal } from './VideoPlaybackModal'; // Import the video modal

type FilterType = 'all' | 'image' | 'video';

export default function HistoryGallery() {
  const { toast } = useToast();
  const router = useRouter();
  const [showSkeletons, setShowSkeletons] = useState<boolean>(false); // NEW: controls skeleton visibility
  const [historyItems, setHistoryItems] = useState<HistoryItem[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [currentPage, setCurrentPage] = useState<number>(1);
  const [hasMore, setHasMore] = useState<boolean>(false);
  const [totalCount, setTotalCount] = useState<number>(0);
  const [currentFilter, setCurrentFilter] = useState<FilterType>('all');
  const [isLoadingMore, setIsLoadingMore] = useState<boolean>(false);

  // State for details modal
  const [detailItem, setDetailItem] = useState<HistoryItem | null>(null);

  // State for delete confirmation
  const [itemToDelete, setItemToDelete] = useState<HistoryItem | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);

  // Ref for the element that will trigger loading more items
  const loadMoreRef = useRef<HTMLDivElement>(null);

  // Animation variants for the gallery
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.08,
      },
    },
  };

  const itemVariants = {
    hidden: { y: 20, opacity: 0 },
    visible: {
      y: 0,
      opacity: 1,
      transition: { stiffness: 300, damping: 25 }, // Removed 'type' property for compatibility
    },
    exit: { y: -20, opacity: 0, transition: { duration: 0.2 } },
  };


  const itemsPerPage = 9; // Or any other number you prefer

  // Effect for initial load and filter changes
  useEffect(() => {
    // NEW: Timer to delay skeletons
    const skeletonTimer = setTimeout(() => {
      if (isLoading) setShowSkeletons(true);
    }, 500);
    const loadInitialHistory = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const result = await getHistoryPaginated(1, itemsPerPage, currentFilter);
        setHistoryItems(result.items);
        setCurrentPage(result.currentPage);
        setHasMore(result.hasMore);
        setTotalCount(result.totalCount);
      } catch (err) {
        console.error("Failed to fetch history:", err);
        const errorMessage = err instanceof Error ? err.message : "An unknown error occurred.";
        setError(errorMessage);
        toast({
          title: "Error Loading History",
          description: errorMessage,
          variant: "destructive",
        });
      } finally {
        setIsLoading(false);
        setShowSkeletons(false); // NEW: always hide skeletons after load
      }
    };
    loadInitialHistory();
    // NEW: cleanup timer
    return () => clearTimeout(skeletonTimer);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [currentFilter, toast, itemsPerPage]);

  const handleLoadMore = useCallback(async () => {
    if (!hasMore || isLoadingMore) return;
    setIsLoadingMore(true);
    try {
      const result = await getHistoryPaginated(currentPage + 1, itemsPerPage, currentFilter);
      setHistoryItems(prevItems => [...prevItems, ...result.items]);
      setCurrentPage(result.currentPage);
      setHasMore(result.hasMore);
    } catch (err) {
      console.error("Failed to fetch history:", err);
      setError(err instanceof Error ? err.message : "An unknown error occurred.");
      toast({
        title: "Error Loading History",
        description: err instanceof Error ? err.message : "Could not fetch history items.",
        variant: "destructive",
      });
    } finally {
      setIsLoadingMore(false);
    }
  }, [hasMore, isLoadingMore, currentPage, currentFilter, itemsPerPage, toast]);

  // Set up the IntersectionObserver to watch the loadMoreRef
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        // If the trigger element is intersecting and we have more items to load
        if (entries[0].isIntersecting && hasMore && !isLoading && !isLoadingMore) {
          handleLoadMore();
        }
      },
      { 
        threshold: 1.0, // Trigger when 100% of the element is visible
        rootMargin: '100px' // Start loading 100px before the element is visible
      }
    );
    const currentRef = loadMoreRef.current;
    if (currentRef) {
      observer.observe(currentRef);
    }
    return () => {
      if (currentRef) {
        observer.unobserve(currentRef);
      }
    };
  }, [hasMore, isLoading, isLoadingMore, handleLoadMore]); // Dependencies updated

  const handleFilterChange = (newFilter: string) => {
    setCurrentFilter(newFilter as FilterType);
    setCurrentPage(1); // Reset to first page on filter change
  };

  const handleViewDetails = (item: HistoryItem) => {
    setDetailItem(item);
  };

  const handleReloadConfig = (item: HistoryItem) => {
    // Only navigate, do not show a toast here
    router.push(`/create?historyItemId=${item.id}`);
  };

  const handleDeleteRequest = (item: HistoryItem) => {
    setItemToDelete(item);
  };

  const handleConfirmDelete = async () => {
    if (!itemToDelete) return;

    setIsDeleting(true);
    try {
      const result = await deleteHistoryItem(itemToDelete.id);

      if (result.success) {
        // Optimistic UI Update: Remove the item from the local state
        setHistoryItems(prevItems => prevItems.filter(item => item.id !== itemToDelete.id));
        setTotalCount(prevCount => prevCount - 1); // Decrement total count
        toast({
          title: "Item Deleted",
          description: "The history item has been permanently removed.",
        });
      } else {
        throw new Error(result.error || "Failed to delete the item.");
      }
    } catch (err) {
      console.error("Deletion failed:", err);
      toast({
        title: "Deletion Failed",
        description: err instanceof Error ? err.message : "An unknown error occurred.",
        variant: "destructive",
      });
    } finally {
      setIsDeleting(false);
      setItemToDelete(null); // Close the dialog
    }
  };


  // Function to get display label for attribute values (similar to one in image-forge)
  // This might be better placed in a utils file if used in multiple places
  const getDisplayLabelForValue = (options: { value: string, displayLabel: string }[], value: string | undefined): string => {
    if (!value) return "N/A";
    return options.find(o => o.value === value)?.displayLabel || value;
  };

  // Simplified options for display in modal - ideally import from a shared location
  const FASHION_STYLE_OPTIONS_SIMPLE = [{value: "default_style", displayLabel: "Default"}, /* ... other styles */];
  const GENDER_OPTIONS_SIMPLE = [{value: "female", displayLabel: "Female"},  /* ... other genders */];
  // ... add other simplified option arrays as needed for the modal


  // Helper to check if item is a video
  const itemIsVideo = (item: HistoryItem) => !!(item.videoGenerationParams || (item.generatedVideoUrls && item.generatedVideoUrls.some(url => !!url)));

  return (
    <>
      <Tabs value={currentFilter} onValueChange={handleFilterChange} className="w-full">
        <TabsList className="grid w-full grid-cols-3">
          <TabsTrigger value="all">All</TabsTrigger>
          <TabsTrigger value="image">Images</TabsTrigger>
          <TabsTrigger value="video">Videos</TabsTrigger>
        </TabsList>
      </Tabs>

      {isLoading && showSkeletons && !isLoadingMore && (
        <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4 mt-4">
          {Array.from({ length: itemsPerPage }).map((_, index) => (
            <div key={`skel-${index}`} className="p-4 border rounded-lg shadow-sm space-y-2 bg-muted/50">
              <div className="h-5 w-3/4 bg-gray-300 dark:bg-gray-700 rounded animate-pulse"></div>
              <div className="h-4 w-1/2 bg-gray-300 dark:bg-gray-700 rounded animate-pulse"></div>
              <div className="h-4 w-1/3 bg-gray-300 dark:bg-gray-700 rounded animate-pulse"></div>
            </div>
          ))}
        </div>
      )}

      {!isLoading && error && (
        <div className="text-center py-10 text-red-600">
          <AlertTriangle className="mx-auto h-12 w-12 mb-2" />
          <p>Error loading history: {error}</p>
        </div>
      )}

      {!isLoading && !error && historyItems.length === 0 && (
        <Card variant="glass" className="mt-8">
          <CardContent className="py-16 flex flex-col items-center justify-center text-center">
            <ImageIcon className="h-16 w-16 text-muted-foreground/50 mb-4" />
            <h3 className="text-xl font-semibold">No History Found</h3>
            <p className="text-muted-foreground mt-1">Creations for this filter will appear here once you&apos;ve made some.</p>
          </CardContent>
        </Card>
      )}

      <LayoutGroup>
        {!isLoading && !error && historyItems.length > 0 && (
          <motion.div
            className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-6 mt-4"
            variants={containerVariants}
            initial="hidden"
            animate="visible"
            layout
          >
            <AnimatePresence>
              {historyItems.map((item) => (
                <motion.div key={item.id} variants={itemVariants} layout>
                  <HistoryCard
                    item={item}
                    onViewDetails={handleViewDetails}
                    onReloadConfig={handleReloadConfig}
                    onDeleteItem={handleDeleteRequest}
                  />
                </motion.div>
              ))}
            </AnimatePresence>
          </motion.div>
        )}
        <AnimatePresence>
          {detailItem && itemIsVideo(detailItem) && (
            <VideoPlaybackModal
              item={detailItem}
              onClose={() => setDetailItem(null)}
            />
          )}
        </AnimatePresence>
        <AnimatePresence>
          {detailItem && !itemIsVideo(detailItem) && (
            <HistoryDetailModal
              isOpen={!!detailItem}
              onClose={() => setDetailItem(null)}
              item={detailItem}
              onReloadConfig={handleReloadConfig}
            />
          )}
        </AnimatePresence>
      </LayoutGroup>

      {/* Invisible trigger element for infinite scroll */}
      {hasMore && <div ref={loadMoreRef} className="h-4" />}

      {isLoadingMore && (
        <div className="text-center mt-8 flex justify-center">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
        </div>
      )}

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={!!itemToDelete} onOpenChange={(isOpen) => !isOpen && setItemToDelete(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the history item and all associated images and videos.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleConfirmDelete} disabled={isDeleting} className="bg-destructive hover:bg-destructive/90">
              {isDeleting ? (
                <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Deleting...</>
              ) : (
                "Yes, delete it"
              )}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
}
</file>

<file path="src/components/HistoryCard.tsx">
// src/components/HistoryCard.tsx
"use client";

import React, { useState, useRef, useEffect } from "react";
import Image from "next/image";
import { Card, CardContent, CardFooter, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { HistoryItem } from "@/lib/types";
import { getDisplayableImageUrl } from "@/lib/utils";
import { Eye, RefreshCw, Video, Image as ImageIcon, AlertTriangle, Loader2, PlayCircle, MoreVertical, Trash2 } from "lucide-react";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { motion } from 'motion/react';

interface HistoryCardProps {
  item: HistoryItem;
  onViewDetails: (item: HistoryItem) => void;
  onReloadConfig: (item: HistoryItem) => void;
  onDeleteItem: (item: HistoryItem) => void;
  username?: string; // Add optional username prop
}

export default function HistoryCard({ item, onViewDetails, onReloadConfig, onDeleteItem, username }: HistoryCardProps) {
  const [isInView, setIsInView] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const cardRef = useRef<HTMLDivElement>(null);
  const isVideoItem = !!(item.videoGenerationParams || (item.generatedVideoUrls && item.generatedVideoUrls.some(url => !!url)));
  const primaryImageUrl = item.editedImageUrls?.[0] || item.originalClothingUrl;
  const videoUrl = item.generatedVideoUrls?.[0];

  let status: 'completed' | 'processing' | 'failed' | null = null;
  let statusText = "";

  if (isVideoItem && (item.videoGenerationParams as any)?.status) {
    status = (item.videoGenerationParams as any).status;
    statusText = status ? status.charAt(0).toUpperCase() + status.slice(1) : "";
  } else if (!isVideoItem && item.editedImageUrls && item.editedImageUrls.every(url => url === null) && item.constructedPrompt) {
    // This is a basic heuristic for failed image jobs if all URLs are null but a prompt existed.
    // More robust status would require adding it to HistoryItem for images.
    status = 'failed';
    statusText = 'Failed';
  } else if (item.editedImageUrls && item.editedImageUrls.some(url => !!url) || primaryImageUrl) {
    status = 'completed';
    // For completed images, we don't usually show a "Completed" badge unless it's a specific design choice.
    // statusText = "Completed";
  }

  // IntersectionObserver for autoplay-in-view
  useEffect(() => {
    const currentCard = cardRef.current;
    if (!currentCard || !isVideoItem || !videoUrl) return;

    const observer = new IntersectionObserver(
      (entries) => {
        const entry = entries[0];
        setIsInView(entry.isIntersecting);
      },
      {
        root: null, // viewport
        rootMargin: '0px',
        threshold: 0.5 // Play when 50% of the card is visible
      }
    );

    observer.observe(currentCard);

    return () => {
      observer.unobserve(currentCard);
    };
  }, [isVideoItem, videoUrl]);

  // Handle video play/pause based on visibility
  useEffect(() => {
    const video = videoRef.current;
    if (!video || !isVideoItem || !videoUrl) return;

    if (isInView) {
      const playPromise = video.play();
      if (playPromise !== undefined) {
        playPromise.catch(error => {
          // Autoplay was prevented or interrupted. This is expected.
          // We can ignore the AbortError specifically.
          if (error.name !== 'AbortError') {
            console.error("Video play failed:", error);
          }
        });
      }
    } else {
      video.pause();
    }
  }, [isInView, isVideoItem, videoUrl]);

  // Add more sophisticated status detection if needed, e.g. for image processing steps

  return (
    <motion.div
      layout
      whileHover={{ scale: 1.02, y: -4 }}
      whileTap={{ scale: 0.98 }}
      transition={{ type: "spring", stiffness: 400, damping: 20 }}
    >
      <Card ref={cardRef} variant="glass" className="flex flex-col h-full group shadow-sm transition-shadow">
        <CardHeader className="p-3 sm:p-4">
          <div className="flex items-center justify-between">
            <CardTitle className="text-base sm:text-lg font-semibold truncate" title={item.constructedPrompt || (isVideoItem ? "Video Generation" : "Image Generation")}>
              {item.constructedPrompt || (isVideoItem ? "Video Generation" : "Image Generation")}
            </CardTitle>
            <Badge variant={
              status === 'completed' ? 'default' : // 'success' if you have it
              status === 'processing' ? 'secondary' :
              status === 'failed' ? 'destructive' : 'outline'
            } className="ml-2 text-xs whitespace-nowrap">
              {isVideoItem ? <Video className="h-3 w-3 mr-1.5" /> : <ImageIcon className="h-3 w-3 mr-1.5" />}
              {isVideoItem ? "Video" : "Image"}
            </Badge>
            {/* Render username badge if provided */}
            {username && (
              <Badge variant="secondary" className="ml-2 text-xs font-medium">{username}</Badge>
            )}
          </div>
          <CardDescription className="text-xs text-muted-foreground mt-1">
            {new Date(item.timestamp).toLocaleDateString()} {new Date(item.timestamp).toLocaleTimeString()}
          </CardDescription>
        </CardHeader>
        <CardContent 
          className="p-3 sm:p-4 flex-grow relative cursor-pointer"
          onClick={() => onViewDetails(item)}
        >
          <motion.div
            initial={{ opacity: 0, scale: 0.97 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.97 }}
            transition={{ duration: 0.3, ease: 'easeInOut' }}
            className="aspect-[2/3] w-full bg-muted rounded-md overflow-hidden relative pointer-events-none"
          >
            {isVideoItem && videoUrl ? (
              <>
                <Image
                  src={getDisplayableImageUrl(primaryImageUrl) || '/placeholder.png'}
                  alt="Video thumbnail"
                  fill
                  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                  className={`object-cover object-top transition-opacity duration-300 ${isInView ? 'opacity-0' : 'opacity-100'}`}
                />
                <video
                  ref={videoRef}
                  src={getDisplayableImageUrl(videoUrl) || undefined}
                  loop
                  muted
                  playsInline
                  preload="metadata"
                  className={`w-full h-full object-cover object-top absolute inset-0 transition-opacity duration-300 ${isInView ? 'opacity-100' : 'opacity-0'}`}
                />
              </>
            ) : primaryImageUrl ? (
              <Image
                src={getDisplayableImageUrl(primaryImageUrl) || '/placeholder.png'}
                alt={isVideoItem ? "Video thumbnail" : "Generated image"}
                fill
                sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                className={`object-cover object-top transition-transform duration-300 ease-in-out`}
              />
            ) : (
              <div className="flex flex-col items-center justify-center h-full text-muted-foreground">
                <ImageIcon size={48} />
                <p className="mt-2 text-sm">No preview available</p>
              </div>
            )}
            {!isInView && isVideoItem && videoUrl && (
              <div className="absolute inset-0 flex items-center justify-center bg-black/40 transition-opacity">
                <PlayCircle className="h-12 w-12 text-white/80" />
              </div>
            )}
             {status && status !== 'completed' && (
             <div className="absolute top-2 right-2">
                <Badge variant={status === 'failed' ? 'destructive' : 'secondary'} className="text-xs">
                    {status === 'processing' && <Loader2 className="h-3 w-3 mr-1.5 animate-spin" />}
                    {status === 'failed' && <AlertTriangle className="h-3 w-3 mr-1.5" />}
                    {statusText}
                </Badge>
             </div>
           )}
          </motion.div>

          {/* Display a few key parameters if available */}
          <div className="mt-2 space-y-1 text-xs text-muted-foreground">
            {item.attributes?.fashionStyle && item.attributes.fashionStyle !== "default_style" && (
              <p className="truncate">Style: {item.attributes.fashionStyle.replace(/_/g, ' ')}</p>
            )}
          </div>
        </CardContent>

        <CardFooter className="p-3 sm:p-4 flex gap-2 bg-muted/30 border-t">
          <Button variant="outline" size="sm" onClick={() => onViewDetails(item)} className="flex-1">
            <Eye className="h-4 w-4 sm:mr-2" /> <span className="hidden sm:inline">View Details</span>
          </Button>
          <Button variant="secondary" size="sm" onClick={() => onReloadConfig(item)} className="flex-1">
            <RefreshCw className="h-4 w-4 sm:mr-2" /> <span className="hidden sm:inline">Reload Config</span>
          </Button>

          {/* Options Menu */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="icon" className="h-9 w-9">
                <MoreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem 
                className="text-destructive focus:text-destructive focus:bg-destructive/10"
                onClick={(e) => {
                  e.stopPropagation(); // Prevent card click events
                  onDeleteItem(item);
                }}
              >
                <Trash2 className="mr-2 h-4 w-4" />
                <span>Delete</span>
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </CardFooter>
      </Card>
    </motion.div>
  );
}
</file>

<file path="src/components/HistoryDetailModal.tsx">
"use client";

import React, { useState, useEffect, useMemo } from "react";
import Image from "next/image";
import { motion, AnimatePresence } from "motion/react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { Download, Copy, X } from "lucide-react";
import { getDisplayableImageUrl } from "@/lib/utils";
import type { HistoryItem } from "@/lib/types";
import { useToast } from "@/hooks/use-toast";
import { cn } from "@/lib/utils";

interface HistoryDetailModalProps {
  item: HistoryItem | null;
  isOpen: boolean;
  onClose: () => void;
  onReloadConfig: (item: HistoryItem) => void;
}

export function HistoryDetailModal({ item, isOpen, onClose, onReloadConfig }: HistoryDetailModalProps) {
  const [selectedImageUrl, setSelectedImageUrl] = useState<string | null>(null);
  const { toast } = useToast();

  const allImages = useMemo(() => {
    if (!item) return [];
    return [
      { type: 'Original', url: item.originalClothingUrl },
      ...item.editedImageUrls
        .map((url, i) => (url ? { type: `Generated #${i + 1}`, url } : null))
        .filter((img): img is { type: string; url: string } => img !== null)
    ];
  }, [item]);

  useEffect(() => {
    if (item) {
      const firstGenerated = item.editedImageUrls?.find(url => url);
      setSelectedImageUrl(firstGenerated || item.originalClothingUrl);
    } else {
      setSelectedImageUrl(null);
    }
  }, [item]);

  if (!item) return null;

  const handleCopyPrompt = () => {
    if (!item.constructedPrompt) return;
    navigator.clipboard.writeText(item.constructedPrompt);
    toast({ title: 'Copied!', description: 'Prompt has been copied to clipboard.' });
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-6xl w-full h-full sm:h-auto sm:max-h-[90vh] p-0 flex flex-col glass-card">
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.95 }}
          transition={{ duration: 0.3, ease: "easeInOut" }}
          className="flex flex-col h-full overflow-hidden"
        >
          <DialogHeader className="p-4 sm:p-6 pb-4 flex-shrink-0 border-b border-white/10">
            <DialogTitle>History Item Details</DialogTitle>
            <DialogDescription>
              Review of saved configuration from {new Date(item.timestamp).toLocaleString()}.
            </DialogDescription>
          </DialogHeader>

          {/* Main content area - switches from stacked to side-by-side layout */}
          <div className="flex flex-col lg:flex-row flex-1 min-h-0">
            {/* Main Image Viewer */}
            <div className="flex-shrink-0 lg:flex-1 bg-black/20 lg:rounded-l-lg overflow-hidden flex items-center justify-center relative p-4 lg:p-0 min-h-[300px]">
              <AnimatePresence mode="wait">
                {selectedImageUrl && (
                  <motion.div
                    key={selectedImageUrl}
                    initial={{ opacity: 0, scale: 0.98 }}
                    animate={{ opacity: 1, scale: 1 }}
                    exit={{ opacity: 0, scale: 0.98 }}
                    transition={{ duration: 0.2 }}
                    className="w-full h-full"
                  >
                    <Image
                      src={getDisplayableImageUrl(selectedImageUrl) ?? '/placeholder.png'}
                      alt="Selected view"
                      fill
                      className="object-contain"
                      sizes="(max-width: 1024px) 100vw, 66vw"
                    />
                  </motion.div>
                )}
              </AnimatePresence>
            </div>

            {/* Sidebar with Details and Thumbnails */}
            <div className="flex flex-col lg:w-[350px] xl:w-[400px] flex-shrink-0 min-h-0 border-t lg:border-t-0 lg:border-l border-white/10">
              <ScrollArea className="flex-1">
                <div className="p-4 sm:p-6 space-y-6">
                  {/* Thumbnails */}
                  <div className="grid grid-cols-2 gap-4">
                    {allImages.map(({ type, url }, index) => (
                      <button
                        key={`${url}-${index}`}
                        onClick={() => setSelectedImageUrl(url)}
                        className={cn(
                          "relative aspect-[2/3] rounded-md overflow-hidden border border-white/10 transition-all ring-offset-background ring-offset-2 focus:outline-none focus:ring-2 focus:ring-ring",
                          selectedImageUrl === url ? 'ring-2 ring-primary' : 'hover:opacity-80'
                        )}
                      >
                        <Image
                          src={getDisplayableImageUrl(url) ?? '/placeholder.png'}
                          alt={type}
                          fill
                          className={cn(
                            type === 'Original' ? 'object-contain p-1' : 'object-cover'
                          )}
                          sizes="(max-width: 1023px) 50vw, 15vw"
                        />
                        <div className="absolute bottom-0 w-full bg-black/70 text-white text-[10px] p-1 text-center truncate backdrop-blur-sm">
                          {type}
                        </div>
                      </button>
                    ))}
                  </div>

                  {/* Configuration Accordion */}
                  <Accordion type="multiple" defaultValue={['attributes']} className="w-full">
                    {item.attributes && Object.keys(item.attributes).length > 0 && (
                      <AccordionItem value="attributes">
                        <AccordionTrigger>Generation Parameters</AccordionTrigger>
                        <AccordionContent className="text-xs space-y-1 bg-muted/50 p-3 rounded-md">
                          {Object.entries(item.attributes).map(([key, value]) => {
                            if (value === 'default' || !value) return null;
                            const formattedKey = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                            return (
                              <p key={key}>
                                <strong>{formattedKey}:</strong> {String(value)}
                              </p>
                            );
                          })}
                        </AccordionContent>
                      </AccordionItem>
                    )}

                    <AccordionItem value="prompt">
                      <AccordionTrigger>Full Prompt</AccordionTrigger>
                      <AccordionContent className="relative text-xs text-muted-foreground bg-muted/50 p-3 rounded-md pr-10 whitespace-pre-wrap break-words">
                        {item.constructedPrompt}
                        <Button
                          variant="ghost"
                          size="icon"
                          className="absolute top-1 right-1"
                          onClick={handleCopyPrompt}
                        >
                          <Copy className="h-3.5 w-3.5" />
                        </Button>
                      </AccordionContent>
                    </AccordionItem>

                    <AccordionItem value="metadata">
                      <AccordionTrigger>Metadata</AccordionTrigger>
                      <AccordionContent className="text-xs space-y-1 bg-muted/50 p-3 rounded-md">
                        <p><strong>Created:</strong> {new Date(item.timestamp).toLocaleString()}</p>
                        <p><strong>User:</strong> {item.username}</p>
                        <p><strong>Settings Mode:</strong> {item.settingsMode || 'basic'}</p>
                        <p className="break-all"><strong>ID:</strong> {item.id}</p>
                      </AccordionContent>
                    </AccordionItem>
                  </Accordion>
                </div>
              </ScrollArea>
            </div>
          </div>

          <DialogFooter className="flex-shrink-0 p-4 border-t border-white/10 flex flex-col sm:flex-row justify-end gap-2 bg-background/50">
            <Button variant="outline" onClick={onClose}>
              <X className="mr-2 h-4 w-4" /> Close
            </Button>
            <Button onClick={() => onReloadConfig(item)}>
              <Copy className="mr-2 h-4 w-4" /> <span className="hidden sm:inline">Use as Template</span>
            </Button>
            {selectedImageUrl &&
              <a href={getDisplayableImageUrl(selectedImageUrl) ?? '#'} download={`Refashion_Image_${item.id.substring(0, 6)}.png`}>
                <Button>
                  <Download className="mr-2 h-4 w-4" /> <span className="hidden sm:inline">Download Selected</span>
                </Button>
              </a>
            }
          </DialogFooter>
        </motion.div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/components/image-parameters.tsx">
// src/components/image-parameters.tsx
"use client";

import React, { useState, useEffect, useCallback } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion";
import { useToast } from "@/hooks/use-toast";
import { Loader2, Palette, PersonStanding, Settings2, Sparkles, Wand2, FileText, Shuffle, Save, Trash2, Eye, RefreshCw, Download, Video as VideoIcon, UserCheck, UploadCloud, AlertTriangle } from 'lucide-react';
import { generateImageEdit, regenerateSingleImage, type GenerateImageEditInput, type GenerateMultipleImagesOutput } from "@/ai/flows/generate-image-edit";
import { upscaleImageAction } from "@/ai/actions/upscale-image.action";
import { addHistoryItem, updateHistoryItem, getHistoryItemById } from "@/actions/historyActions";
import { useAuth } from "@/contexts/AuthContext";
import type { ModelAttributes, HistoryItem } from "@/lib/types";
import { getDisplayableImageUrl } from "@/lib/utils";
import Image from "next/image";
import { useRouter } from 'next/navigation';
import { usePromptManager } from '@/hooks/usePromptManager';
import { Textarea } from '@/components/ui/textarea';
import { useActiveImage, useImageStore } from "@/stores/imageStore";
import {
    FASHION_STYLE_OPTIONS, GENDER_OPTIONS, AGE_RANGE_OPTIONS, ETHNICITY_OPTIONS,
    BODY_TYPE_OPTIONS, BODY_SIZE_OPTIONS, HAIR_STYLE_OPTIONS, MODEL_EXPRESSION_OPTIONS,
    POSE_STYLE_OPTIONS, BACKGROUND_OPTIONS, TIME_OF_DAY_OPTIONS, OVERALL_MOOD_OPTIONS,
    LIGHTING_TYPE_OPTIONS, LIGHT_QUALITY_OPTIONS, CAMERA_ANGLE_OPTIONS, LENS_EFFECT_OPTIONS,
    DEPTH_OF_FIELD_OPTIONS, FABRIC_RENDERING_OPTIONS, OptionWithPromptSegment
} from '@/lib/prompt-builder';
import { motion, AnimatePresence, useReducedMotion } from 'motion/react';
import { MOTION_TRANSITIONS } from '@/lib/motion-constants';

// Interface for image generation parameters
interface ImageGenerationParams extends ModelAttributes {
  settingsMode: 'basic' | 'advanced';
}

// Props interface for the component
interface ImageParametersProps {
  historyItemToLoad?: HistoryItem | null;
  isLoadingHistory?: boolean;
}

// Constants
const NUM_IMAGES_TO_GENERATE = 3;

// Component now accepts props for loading configuration
export default function ImageParameters({ 
  historyItemToLoad = null, 
  isLoadingHistory = false 
}: ImageParametersProps) {
  const { user: currentUser } = useAuth();
  const { toast } = useToast();
  const router = useRouter();
  
  // Get prepared image from store instead of props
  const activeImage = useActiveImage();
  const resetImageState = useImageStore((state) => state.reset);
  const preparedImageUrl = activeImage?.dataUri || null;

  // State for parameters
  const [gender, setGender] = useState<string>(GENDER_OPTIONS.find(o => o.value === "female")?.value || GENDER_OPTIONS[0].value);
  const [bodyType, setBodyType] = useState<string>(BODY_TYPE_OPTIONS[0].value);
  const [bodySize, setBodySize] = useState<string>(BODY_SIZE_OPTIONS[0].value);
  const [ageRange, setAgeRange] = useState<string>(AGE_RANGE_OPTIONS[0].value);
  const [ethnicity, setEthnicity] = useState<string>(ETHNICITY_OPTIONS[0].value);
  const [poseStyle, setPoseStyle] = useState<string>(POSE_STYLE_OPTIONS.find(o => o.value === "natural_relaxed_pose")?.value || POSE_STYLE_OPTIONS[0].value);
  const [background, setBackground] = useState<string>(BACKGROUND_OPTIONS.find(o => o.value === "outdoor_nature_elements")?.value || BACKGROUND_OPTIONS[0].value);
  const [fashionStyle, setFashionStyle] = useState<string>(FASHION_STYLE_OPTIONS[0].value);
  const [hairStyle, setHairStyle] = useState<string>(HAIR_STYLE_OPTIONS[0].value);
  const [modelExpression, setModelExpression] = useState<string>(MODEL_EXPRESSION_OPTIONS[0].value);
  const [lightingType, setLightingType] = useState<string>(LIGHTING_TYPE_OPTIONS[0].value);
  const [lightQuality, setLightQuality] = useState<string>(LIGHT_QUALITY_OPTIONS[0].value);
  const [cameraAngle, setCameraAngle] = useState<string>(CAMERA_ANGLE_OPTIONS[0].value);
  const [lensEffect, setLensEffect] = useState<string>(LENS_EFFECT_OPTIONS[0].value);
  const [depthOfField, setDepthOfField] = useState<string>(DEPTH_OF_FIELD_OPTIONS[0].value);
  const [timeOfDay, setTimeOfDay] = useState<string>(TIME_OF_DAY_OPTIONS[0].value);
  const [overallMood, setOverallMood] = useState<string>(OVERALL_MOOD_OPTIONS[0].value);
  const [fabricRendering, setFabricRendering] = useState<string>(FABRIC_RENDERING_OPTIONS[0].value);

  const [settingsMode, setSettingsMode] = useState<'basic' | 'advanced'>('basic');
  const [showAdvancedSettingsActiveMessage, setShowAdvancedSettingsActiveMessage] = useState<boolean>(false);
  const [loadedHistoryItemId, setLoadedHistoryItemId] = useState<string | null>(null);

  // State for generation results
  const [outputImageUrls, setOutputImageUrls] = useState<(string | null)[]>(Array(NUM_IMAGES_TO_GENERATE).fill(null));
  const [originalOutputImageUrls, setOriginalOutputImageUrls] = useState<(string | null)[]>(Array(NUM_IMAGES_TO_GENERATE).fill(null));
  const [generationErrors, setGenerationErrors] = useState<(string | null)[]>(Array(NUM_IMAGES_TO_GENERATE).fill(null));
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [isReRollingSlot, setIsReRollingSlot] = useState<number | null>(null);
  const [isUpscalingSlot, setIsUpscalingSlot] = useState<number | null>(null);
  const [comparingSlotIndex, setComparingSlotIndex] = useState<number | null>(null);
  const [activeHistoryItemId, setActiveHistoryItemId] = useState<string | null>(null);

  const commonFormDisabled = !preparedImageUrl || isLoading;

  // Initial default values for all configurable parameters
  const initialAppDefaults = React.useRef({
    gender: GENDER_OPTIONS.find(o => o.value === "female")?.value || GENDER_OPTIONS[0].value,
    bodyType: BODY_TYPE_OPTIONS[0].value,
    bodySize: BODY_SIZE_OPTIONS[0].value,
    ageRange: AGE_RANGE_OPTIONS[0].value,
    ethnicity: ETHNICITY_OPTIONS[0].value,
    poseStyle: POSE_STYLE_OPTIONS.find(o => o.value === "natural_relaxed_pose")?.value || POSE_STYLE_OPTIONS[0].value,
    background: BACKGROUND_OPTIONS.find(o => o.value === "outdoor_nature_elements")?.value || BACKGROUND_OPTIONS[0].value,
    fashionStyle: FASHION_STYLE_OPTIONS[0].value,
    hairStyle: HAIR_STYLE_OPTIONS[0].value,
    modelExpression: MODEL_EXPRESSION_OPTIONS[0].value,
    lightingType: LIGHTING_TYPE_OPTIONS[0].value,
    lightQuality: LIGHT_QUALITY_OPTIONS[0].value,
    cameraAngle: CAMERA_ANGLE_OPTIONS[0].value,
    lensEffect: LENS_EFFECT_OPTIONS[0].value,
    depthOfField: DEPTH_OF_FIELD_OPTIONS[0].value,
    timeOfDay: TIME_OF_DAY_OPTIONS[0].value,
    overallMood: OVERALL_MOOD_OPTIONS[0].value,
    fabricRendering: FABRIC_RENDERING_OPTIONS[0].value,
  }).current;

  const PARAMETER_CONFIG = React.useMemo(() => ({
    gender: { setter: setGender, options: GENDER_OPTIONS, defaultVal: initialAppDefaults.gender },
    bodyType: { setter: setBodyType, options: BODY_TYPE_OPTIONS, defaultVal: initialAppDefaults.bodyType },
    bodySize: { setter: setBodySize, options: BODY_SIZE_OPTIONS, defaultVal: initialAppDefaults.bodySize },
    ageRange: { setter: setAgeRange, options: AGE_RANGE_OPTIONS, defaultVal: initialAppDefaults.ageRange },
    ethnicity: { setter: setEthnicity, options: ETHNICITY_OPTIONS, defaultVal: initialAppDefaults.ethnicity },
    poseStyle: { setter: setPoseStyle, options: POSE_STYLE_OPTIONS, defaultVal: initialAppDefaults.poseStyle },
    background: { setter: setBackground, options: BACKGROUND_OPTIONS, defaultVal: initialAppDefaults.background },
    fashionStyle: { setter: setFashionStyle, options: FASHION_STYLE_OPTIONS, defaultVal: initialAppDefaults.fashionStyle },
    hairStyle: { setter: setHairStyle, options: HAIR_STYLE_OPTIONS, defaultVal: initialAppDefaults.hairStyle },
    modelExpression: { setter: setModelExpression, options: MODEL_EXPRESSION_OPTIONS, defaultVal: initialAppDefaults.modelExpression },
    lightingType: { setter: setLightingType, options: LIGHTING_TYPE_OPTIONS, defaultVal: initialAppDefaults.lightingType },
    lightQuality: { setter: setLightQuality, options: LIGHT_QUALITY_OPTIONS, defaultVal: initialAppDefaults.lightQuality },
    cameraAngle: { setter: setCameraAngle, options: CAMERA_ANGLE_OPTIONS, defaultVal: initialAppDefaults.cameraAngle },
    lensEffect: { setter: setLensEffect, options: LENS_EFFECT_OPTIONS, defaultVal: initialAppDefaults.lensEffect },
    depthOfField: { setter: setDepthOfField, options: DEPTH_OF_FIELD_OPTIONS, defaultVal: initialAppDefaults.depthOfField },
    timeOfDay: { setter: setTimeOfDay, options: TIME_OF_DAY_OPTIONS, defaultVal: initialAppDefaults.timeOfDay },
    overallMood: { setter: setOverallMood, options: OVERALL_MOOD_OPTIONS, defaultVal: initialAppDefaults.overallMood },
    fabricRendering: { setter: setFabricRendering, options: FABRIC_RENDERING_OPTIONS, defaultVal: initialAppDefaults.fabricRendering },
  }), [initialAppDefaults]);

  // Load/Save settingsMode and user defaults from localStorage
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const storedMode = window.localStorage.getItem('imageForgeSettingsMode');
      if (storedMode === 'basic' || storedMode === 'advanced') {
        setSettingsMode(storedMode);
      }

      const savedDefaultsString = window.localStorage.getItem('imageForgeDefaults');
      if (savedDefaultsString) {
        try {
          const savedDefaults = JSON.parse(savedDefaultsString) as ModelAttributes;
          Object.entries(savedDefaults).forEach(([key, value]) => {
            const config = PARAMETER_CONFIG[key as keyof ModelAttributes];
            if (config && config.options.some(opt => opt.value === value)) {
              config.setter(value as string);
            }
          });
        } catch (e) { console.error("Failed to parse imageForgeDefaults", e); }
      }
    }
  }, [PARAMETER_CONFIG]);

  useEffect(() => {
    if (typeof window !== 'undefined') {
      window.localStorage.setItem('imageForgeSettingsMode', settingsMode);
    }
    if (settingsMode === 'basic') {
      const advancedParams: (keyof ModelAttributes)[] = [
        "fashionStyle", "hairStyle", "modelExpression", "lightingType",
        "lightQuality", "cameraAngle", "lensEffect", "depthOfField",
        "timeOfDay", "overallMood", "fabricRendering"
      ];
      const advancedSettingsAreActive = advancedParams.some(param => {
        const stateValue = { 
          gender, bodyType, bodySize, ageRange, ethnicity, poseStyle, background,
          fashionStyle, hairStyle, modelExpression, lightingType, lightQuality, 
          cameraAngle, lensEffect, depthOfField, timeOfDay, overallMood, fabricRendering 
        }[param];
        return stateValue !== initialAppDefaults[param];
      });
      setShowAdvancedSettingsActiveMessage(advancedSettingsAreActive);
    } else {
      setShowAdvancedSettingsActiveMessage(false);
    }
  }, [settingsMode, initialAppDefaults, gender, bodyType, bodySize, ageRange, ethnicity, poseStyle, background, fashionStyle, hairStyle, modelExpression, lightingType, lightQuality, cameraAngle, lensEffect, depthOfField, timeOfDay, overallMood, fabricRendering]);

  // Consolidate all params for the hook
  const currentImageGenParams = React.useMemo((): ImageGenerationParams => ({
    gender, bodyType, bodySize, ageRange, ethnicity, poseStyle, background,
    fashionStyle, hairStyle, modelExpression, lightingType, lightQuality,
    cameraAngle, lensEffect, depthOfField, timeOfDay, overallMood, fabricRendering,
    settingsMode,
  }), [
    gender, bodyType, bodySize, ageRange, ethnicity, poseStyle, background,
    fashionStyle, hairStyle, modelExpression, lightingType, lightQuality,
    cameraAngle, lensEffect, depthOfField, timeOfDay, overallMood, fabricRendering,
    settingsMode
  ]);

  const {
    currentPrompt,
    isPromptManuallyEdited,
    handlePromptChange,
    resetPromptToAuto,
    isManualPromptOutOfSync,
  } = usePromptManager({
    generationType: 'image',
    generationParams: currentImageGenParams,
  });

  // Effect to populate state when a history item is loaded
  useEffect(() => {
    if (historyItemToLoad && !isLoadingHistory && historyItemToLoad.id !== loadedHistoryItemId) {
      const { attributes, constructedPrompt, settingsMode, editedImageUrls, originalImageUrls, id } = historyItemToLoad;
      // Set all attribute states from the loaded history item
      setGender(attributes.gender || GENDER_OPTIONS.find(o => o.value === "female")?.value || GENDER_OPTIONS[0].value);
      setBodyType(attributes.bodyType || BODY_TYPE_OPTIONS[0].value);
      setBodySize(attributes.bodySize || BODY_SIZE_OPTIONS[0].value);
      setAgeRange(attributes.ageRange || AGE_RANGE_OPTIONS[0].value);
      setEthnicity(attributes.ethnicity || ETHNICITY_OPTIONS[0].value);
      setPoseStyle(attributes.poseStyle || POSE_STYLE_OPTIONS.find(o => o.value === "natural_relaxed_pose")?.value || POSE_STYLE_OPTIONS[0].value);
      setBackground(attributes.background || BACKGROUND_OPTIONS.find(o => o.value === "outdoor_nature_elements")?.value || BACKGROUND_OPTIONS[0].value);
      setFashionStyle(attributes.fashionStyle || FASHION_STYLE_OPTIONS[0].value);
      setHairStyle(attributes.hairStyle || HAIR_STYLE_OPTIONS[0].value);
      setModelExpression(attributes.modelExpression || MODEL_EXPRESSION_OPTIONS[0].value);
      setLightingType(attributes.lightingType || LIGHTING_TYPE_OPTIONS[0].value);
      setLightQuality(attributes.lightQuality || LIGHT_QUALITY_OPTIONS[0].value);
      setCameraAngle(attributes.cameraAngle || CAMERA_ANGLE_OPTIONS[0].value);
      setLensEffect(attributes.lensEffect || LENS_EFFECT_OPTIONS[0].value);
      setDepthOfField(attributes.depthOfField || DEPTH_OF_FIELD_OPTIONS[0].value);
      setTimeOfDay(attributes.timeOfDay || TIME_OF_DAY_OPTIONS[0].value);
      setOverallMood(attributes.overallMood || OVERALL_MOOD_OPTIONS[0].value);
      setFabricRendering(attributes.fabricRendering || FABRIC_RENDERING_OPTIONS[0].value);
      // Set settings mode
      setSettingsMode(settingsMode || 'basic');
      // Set the generated image URLs to display them in the results section
      if (editedImageUrls && editedImageUrls.length > 0) {
        setOutputImageUrls(editedImageUrls);
      }
      // Set the original URLs for the "Compare" feature
      if (originalImageUrls && originalImageUrls.length > 0) {
        setOriginalOutputImageUrls(originalImageUrls);
      } else {
        setOriginalOutputImageUrls(Array(NUM_IMAGES_TO_GENERATE).fill(null));
      }
      setActiveHistoryItemId(id);
      // Set the prompt and mark it as manually edited to prevent auto-generation
      if (constructedPrompt) {
        handlePromptChange(constructedPrompt);
      }
      setLoadedHistoryItemId(historyItemToLoad.id);
      toast({
        title: "History Restored",
        description: "Image and all generation parameters have been successfully restored.",
      });
    }
  }, [historyItemToLoad, isLoadingHistory, loadedHistoryItemId, handlePromptChange, toast]);

  const handleSaveDefaults = () => {
    if (typeof window === 'undefined') return;
    const currentSettingsToSave: ModelAttributes = {
      gender, bodyType, bodySize, ageRange, ethnicity, poseStyle, background,
      fashionStyle, hairStyle, modelExpression, lightingType, lightQuality,
      cameraAngle, lensEffect, depthOfField, timeOfDay, overallMood, fabricRendering,
    };
    window.localStorage.setItem('imageForgeDefaults', JSON.stringify(currentSettingsToSave));
    toast({ 
      title: "Defaults Saved",
      description: "Your current settings have been saved for future sessions."
    });
  };

  const resetAllParametersToAppDefaults = useCallback(() => {
    Object.values(PARAMETER_CONFIG).forEach(config => config.setter(config.defaultVal));
  }, [PARAMETER_CONFIG]);

  const handleClearDefaults = () => {
    if (typeof window === 'undefined') return;
    window.localStorage.removeItem('imageForgeDefaults');
    resetAllParametersToAppDefaults();
    toast({ 
      title: "Defaults Cleared",
      description: "All saved settings have been reset to application defaults."
    });
  };

  const handleRandomizeConfiguration = () => {
    const pickRandom = (options: OptionWithPromptSegment[]) => options[Math.floor(Math.random() * options.length)].value;
    Object.values(PARAMETER_CONFIG).forEach(config => {
        if (settingsMode === 'advanced' ||
            ['gender', 'bodyType', 'bodySize', 'ageRange', 'ethnicity', 'poseStyle', 'background'].includes(Object.keys(PARAMETER_CONFIG).find(k => PARAMETER_CONFIG[k as keyof ModelAttributes] === config) || "")) {
            config.setter(pickRandom(config.options));
        }
    });
    toast({ title: "Configuration Randomized!" });
  };

  const handleSubmit = async () => {
    if (!preparedImageUrl) {
      toast({ title: "Image Not Prepared", description: "Please prepare an image in the previous step.", variant: "destructive" });
      return;
    }
    setIsLoading(true);
    setOutputImageUrls(Array(NUM_IMAGES_TO_GENERATE).fill(null));
    setOriginalOutputImageUrls(Array(NUM_IMAGES_TO_GENERATE).fill(null));
    setGenerationErrors(Array(NUM_IMAGES_TO_GENERATE).fill(null));

    const finalPromptToUse = currentPrompt;
    const currentAttributes: ModelAttributes = {
      gender, bodyType, bodySize, ageRange, ethnicity, poseStyle, background,
      fashionStyle, hairStyle, modelExpression, lightingType, lightQuality,
      cameraAngle, lensEffect, depthOfField, timeOfDay, overallMood, fabricRendering
    };

    try {
      const input: GenerateImageEditInput = { prompt: finalPromptToUse, imageDataUriOrUrl: preparedImageUrl };
      const result: GenerateMultipleImagesOutput = await generateImageEdit(input, currentUser?.username || '');
      setOutputImageUrls(result.editedImageUrls);
      setGenerationErrors(result.errors || Array(NUM_IMAGES_TO_GENERATE).fill(null));

      if (result.errors && result.errors.some(e => e !== null)) {
        toast({ title: "Generation Issues", description: `${result.errors.filter(e => e !== null).length} image(s) failed.`, variant: "destructive" });
      } else {
        toast({ title: "Images Generated!", description: "Your edited images are ready." });
      }

      // Add to history
      if (currentUser && preparedImageUrl) {
        const newHistoryId = await addHistoryItem(currentAttributes, finalPromptToUse, preparedImageUrl, result.editedImageUrls, settingsMode);
        setActiveHistoryItemId(newHistoryId);
      }

    } catch (error) {
      console.error("Error generating images:", error);
      const errorMessage = (error as Error).message || "Unexpected error during image generation.";
      setGenerationErrors(Array(NUM_IMAGES_TO_GENERATE).fill(errorMessage));
      toast({ title: "Generation Failed", description: errorMessage, variant: "destructive" });
    } finally {
      setIsLoading(false);
    }
  };

  const handleReRollImage = async (slotIndex: number) => {
    if (!preparedImageUrl) {
      toast({ title: "Image Not Prepared", variant: "destructive" });
      return;
    }
    setIsReRollingSlot(slotIndex);
    
    try {
        const inputForReroll: GenerateImageEditInput = { prompt: currentPrompt, imageDataUriOrUrl: preparedImageUrl };
        const result = await regenerateSingleImage(inputForReroll, slotIndex, currentUser?.username || '');

        const updatedUrls = [...outputImageUrls];
        const newImageUrl = result.editedImageUrl;
        updatedUrls[slotIndex] = newImageUrl;
        setOutputImageUrls(updatedUrls);

        const updatedErrors = [...generationErrors];
        updatedErrors[slotIndex] = null; // Clear previous error on success
        setGenerationErrors(updatedErrors);

        // After re-rolling, the original for comparison might be gone.
        // We should clear the original URL for this slot.
        const currentOriginals = [...originalOutputImageUrls];
        currentOriginals[slotIndex] = null;
        setOriginalOutputImageUrls(currentOriginals);

        if (activeHistoryItemId && newImageUrl) {
            await updateHistoryItem(activeHistoryItemId, { 
              editedImageUrls: updatedUrls,
              originalImageUrls: currentOriginals 
            });
        }
        toast({ 
          title: `Image ${slotIndex + 1} Re-rolled`,
          description: "A new version of the image has been generated."
        });
    } catch (error) {
        toast({title: `Re-roll Failed (Slot ${slotIndex+1})`, description: (error as Error).message, variant: "destructive"});
        const updatedErrors = [...generationErrors];
        updatedErrors[slotIndex] = (error as Error).message || "Unknown re-roll error";
        setGenerationErrors(updatedErrors);
    } finally {
        setIsReRollingSlot(null);
    }
  };

  const handleUpscale = async (slotIndex: number) => {
    // Capture the URL to be upscaled at the beginning of the action.
    const imageUrlToUpscale = outputImageUrls[slotIndex];
    if (!imageUrlToUpscale) {
      toast({ title: "Image Not Available", variant: "destructive" });
      return;
    }
    setIsUpscalingSlot(slotIndex);
    try {
      let imageDataUriForAction: string;

      // Check if the imageUrl is a local path or already a data URI
      if (imageUrlToUpscale.startsWith('/uploads/')) {
        // It's a local path, convert to data URI
        const displayUrl = getDisplayableImageUrl(imageUrlToUpscale);
        if (!displayUrl) throw new Error("Could not create displayable URL.");
        const absoluteUrl = `${window.location.origin}${displayUrl}`;
        const response = await fetch(absoluteUrl);
        if (!response.ok) throw new Error(`Failed to fetch image for processing: ${response.statusText}`);
        const blob = await response.blob();
        imageDataUriForAction = await new Promise<string>((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result as string);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      } else {
        // It's already a data URI or a public URL, use it directly
        imageDataUriForAction = imageUrlToUpscale;
      }

      // We pass undefined for hash as this is a generated image, not the original upload
      const { savedPath } = await upscaleImageAction(imageDataUriForAction, undefined);

      if (activeHistoryItemId) {
        // The state isn't updated yet, so we build the arrays manually for the DB update
        const finalOriginals = [...originalOutputImageUrls];
        finalOriginals[slotIndex] = imageUrlToUpscale;
        const finalOutputs = [...outputImageUrls];
        finalOutputs[slotIndex] = savedPath;
        await updateHistoryItem(activeHistoryItemId, {
          editedImageUrls: finalOutputs,
          originalImageUrls: finalOriginals,
        });
      }

      // Use functional updates to prevent stale state issues in the UI.
      setOriginalOutputImageUrls(prev => {
        const newOriginals = [...prev];
        newOriginals[slotIndex] = imageUrlToUpscale;
        return newOriginals;
      });

      setOutputImageUrls(prev => {
        const newUrls = [...prev];
        newUrls[slotIndex] = savedPath;
        return newUrls;
      });

      toast({ title: `Image ${slotIndex + 1} Upscaled Successfully` });
    } catch (error) {
      console.error(`Error upscaling image ${slotIndex}:`, error);
      const errorMessage = (error as Error).message || "Unexpected error during upscaling.";
      toast({ title: "Upscaling Failed", description: errorMessage, variant: "destructive" });
    } finally {
      setIsUpscalingSlot(null);
    }
  };

  const handleDownloadOutput = (imageUrl: string | null, index: number) => {
    if (!imageUrl) return;
    const downloadUrl = getDisplayableImageUrl(imageUrl);
    if (!downloadUrl) return;

    fetch(downloadUrl)
      .then(res => res.blob())
      .then(blob => {
        const link = document.createElement("a");
        const url = URL.createObjectURL(blob);
        link.href = url;
        link.download = `RefashionAI_image_${index + 1}_${Date.now()}.png`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }).catch(err => {
        toast({ title: "Download Error", variant: "destructive" });
    });
  };

  const handleSendToVideoPage = (imageUrl: string | null) => {
    if (!imageUrl) return;
    
    // 1. Reset the image store to clear the current session.
    resetImageState();

    // 2. Prepare and navigate to the create page for video generation.
    const params = new URLSearchParams();
    // The 'create' page expects 'sourceImageUrl' to load an image
    // and 'defaultTab' to select the correct tab.
    params.set('sourceImageUrl', imageUrl);
    params.set('defaultTab', 'video');
    router.push(`/create?${params.toString()}`);
  };

  // Helper to render select components
  const renderSelect = ({ id, label, value, onChange, options, disabled }: {
    id: string; label: string; value: string; onChange: (value: string) => void; options: OptionWithPromptSegment[]; disabled?: boolean;
  }) => (
    <div className="space-y-1">
      <Label htmlFor={id} className="text-sm font-medium">{label}</Label>
      <Select value={value} onValueChange={onChange} disabled={disabled}>
        <SelectTrigger id={id} className="w-full text-sm">
          <SelectValue placeholder={options.find(o => o.value === value)?.displayLabel || `Select ${label.toLowerCase()}`} />
        </SelectTrigger>
        <SelectContent>
          {options.map((option) => (<SelectItem key={option.value} value={option.value} className="text-sm">{option.displayLabel}</SelectItem>))}
        </SelectContent>
      </Select>
    </div>
  );

  // Animation variants for results grid
  const resultsContainerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        delayChildren: 0.1,
      },
    },
  };
  const resultItemVariant = {
    hidden: { opacity: 0, scale: 0.9 },
    visible: { opacity: 1, scale: 1, transition: MOTION_TRANSITIONS.spring.standard },
  };
  
  const shouldReduceMotion = useReducedMotion();
  const containerAnim = shouldReduceMotion
    ? {
        hidden: { opacity: 0 },
        visible: { opacity: 1 },
      }
    : resultsContainerVariants;
  const itemAnim = shouldReduceMotion
    ? {
        hidden: { opacity: 0 },
        visible: { opacity: 1 },
      }
    : resultItemVariant;

  return (
    <div className="space-y-6">
      <Card variant="glass">
        <CardHeader className="flex flex-row items-start justify-between">
          <div>
            <CardTitle className="text-xl flex items-center gap-2">
              <Palette className="h-6 w-6 text-primary" />
              Configure Image Parameters
            </CardTitle>
            <CardDescription className="hidden lg:block">Define the model, style, and scene for your fashion images.</CardDescription>
          </div>
          <div className="flex items-center gap-3">
            <div className="flex items-center gap-2">
                <Label htmlFor="settings-mode-switch" className="text-sm font-medium whitespace-nowrap">
                    {settingsMode === 'basic' ? 'Basic' : 'Advanced'}
                </Label>
                <Switch
                    id="settings-mode-switch"
                    checked={settingsMode === 'advanced'}
                    onCheckedChange={(checked: boolean) => setSettingsMode(checked ? 'advanced' : 'basic')}
                    disabled={commonFormDisabled}
                    aria-label="Toggle settings mode"
                />
            </div>
            <Button variant="outline" size="icon" onClick={handleRandomizeConfiguration} disabled={commonFormDisabled} aria-label="Randomize Configuration" title="Randomize Settings">
                <Shuffle className="h-5 w-5" />
            </Button>
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Parameter Controls */}
          {settingsMode === 'advanced' ? (
            <>
              {/* Advanced Settings Accordions */}
              <Accordion type="multiple" defaultValue={["style-concept", "model-attributes"]} className="w-full">
                <AccordionItem value="style-concept">
                  <AccordionTrigger className="text-lg"><Sparkles className="h-5 w-5 mr-2 text-primary" />Overall Style & Concept</AccordionTrigger>
                  <AccordionContent className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 pt-4">
                    {renderSelect({ id: "fashionStyle", label: "Photographic Style", value: fashionStyle, onChange: setFashionStyle, options: FASHION_STYLE_OPTIONS, disabled: commonFormDisabled })}
                    {renderSelect({ id: "overallMood", label: "Desired Mood & Atmosphere", value: overallMood, onChange: setOverallMood, options: OVERALL_MOOD_OPTIONS, disabled: commonFormDisabled })}
                  </AccordionContent>
                </AccordionItem>
                <AccordionItem value="model-attributes">
                  <AccordionTrigger className="text-lg"><PersonStanding className="h-5 w-5 mr-2 text-primary" />Model Attributes</AccordionTrigger>
                  <AccordionContent className="pt-4 space-y-4">
                    <RadioGroup value={gender} onValueChange={setGender} className="flex flex-row flex-wrap gap-2 pt-1" disabled={commonFormDisabled}>
                        {GENDER_OPTIONS.map((option) => (
                          <div key={option.value} className="flex items-center space-x-2">
                            <RadioGroupItem value={option.value} id={`gender-${option.value}`} />
                            <Label htmlFor={`gender-${option.value}`} className="text-sm font-medium">{option.displayLabel}</Label>
                          </div>
                        ))}
                    </RadioGroup>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                        {renderSelect({ id: "ageRange", label: "Age Range", value: ageRange, onChange: setAgeRange, options: AGE_RANGE_OPTIONS, disabled: commonFormDisabled })}
                        {renderSelect({ id: "ethnicity", label: "Ethnicity", value: ethnicity, onChange: setEthnicity, options: ETHNICITY_OPTIONS, disabled: commonFormDisabled })}
                        {renderSelect({ id: "bodyType", label: "Body Type", value: bodyType, onChange: setBodyType, options: BODY_TYPE_OPTIONS, disabled: commonFormDisabled })}
                        {renderSelect({ id: "bodySize", label: "Body Frame/Stature", value: bodySize, onChange: setBodySize, options: BODY_SIZE_OPTIONS, disabled: commonFormDisabled })}
                        {renderSelect({ id: "hairStyle", label: "Hair Style", value: hairStyle, onChange: setHairStyle, options: HAIR_STYLE_OPTIONS, disabled: commonFormDisabled })}
                        {renderSelect({ id: "modelExpression", label: "Model Expression", value: modelExpression, onChange: setModelExpression, options: MODEL_EXPRESSION_OPTIONS, disabled: commonFormDisabled })}
                        {renderSelect({ id: "poseStyle", label: "Pose Style", value: poseStyle, onChange: setPoseStyle, options: POSE_STYLE_OPTIONS, disabled: commonFormDisabled })}
                    </div>
                  </AccordionContent>
                </AccordionItem>
                <AccordionItem value="scene-photographic">
                  <AccordionTrigger className="text-lg"><Settings2 className="h-5 w-5 mr-2 text-primary" />Scene & Photographic Details</AccordionTrigger>
                  <AccordionContent className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 pt-4">
                    {renderSelect({ id: "background", label: "Background Setting", value: background, onChange: setBackground, options: BACKGROUND_OPTIONS, disabled: commonFormDisabled })}
                    {renderSelect({ id: "timeOfDay", label: "Time of Day", value: timeOfDay, onChange:setTimeOfDay, options: TIME_OF_DAY_OPTIONS, disabled: commonFormDisabled })}
                    {renderSelect({ id: "lightingType", label: "Lighting Type/Setup", value: lightingType, onChange: setLightingType, options: LIGHTING_TYPE_OPTIONS, disabled: commonFormDisabled })}
                    {renderSelect({ id: "lightQuality", label: "Light Quality", value: lightQuality, onChange: setLightQuality, options: LIGHT_QUALITY_OPTIONS, disabled: commonFormDisabled })}
                    {renderSelect({ id: "cameraAngle", label: "Camera Angle", value: cameraAngle, onChange: setCameraAngle, options: CAMERA_ANGLE_OPTIONS, disabled: commonFormDisabled })}
                  </AccordionContent>
                </AccordionItem>
              </Accordion>
            </>
          ) : (
            /* Basic Mode Settings */
            (<div className="space-y-4">
              {showAdvancedSettingsActiveMessage && (
                <div className="p-3 text-sm text-amber-700 bg-amber-50 border border-amber-200 rounded-md">
                  <p><strong>Note:</strong> Some advanced settings are active. Switch to Advanced mode to review or modify them.</p>
                </div>
              )}
              <RadioGroup value={gender} onValueChange={setGender} className="flex flex-row flex-wrap gap-2 pt-1" disabled={commonFormDisabled}>
                {GENDER_OPTIONS.map((option) => (
                  <div key={option.value} className="flex items-center space-x-2">
                    <RadioGroupItem value={option.value} id={`gender-${option.value}`} />
                    <Label htmlFor={`gender-${option.value}`} className="text-sm font-medium">{option.displayLabel}</Label>
                  </div>
                ))}
              </RadioGroup>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4">
                {renderSelect({ id: "bodyType", label: "Body Type", value: bodyType, onChange: setBodyType, options: BODY_TYPE_OPTIONS, disabled: commonFormDisabled })}
                {renderSelect({ id: "bodySize", label: "Body Frame/Stature", value: bodySize, onChange: setBodySize, options: BODY_SIZE_OPTIONS, disabled: commonFormDisabled })}
                {renderSelect({ id: "ageRange", label: "Age Range", value: ageRange, onChange: setAgeRange, options: AGE_RANGE_OPTIONS, disabled: commonFormDisabled })}
                {renderSelect({ id: "ethnicity", label: "Ethnicity", value: ethnicity, onChange: setEthnicity, options: ETHNICITY_OPTIONS, disabled: commonFormDisabled })}
                {renderSelect({ id: "poseStyle", label: "Pose Style", value: poseStyle, onChange: setPoseStyle, options: POSE_STYLE_OPTIONS, disabled: commonFormDisabled })}
                {renderSelect({ id: "background", label: "Background Setting", value: background, onChange: setBackground, options: BACKGROUND_OPTIONS, disabled: commonFormDisabled })}
              </div>
            </div>)
          )}
           {/* Save/Clear Defaults Buttons */}
           <div className="flex gap-2 pt-4 border-t mt-4">
                <Button variant="outline" onClick={handleSaveDefaults} size="sm" disabled={commonFormDisabled}><Save className="mr-2 h-4 w-4"/>Save Defaults</Button>
                <Button variant="ghost" onClick={handleClearDefaults} size="sm" disabled={commonFormDisabled}><Trash2 className="mr-2 h-4 w-4"/>Clear Defaults</Button>
            </div>

          {/* Prompt Textarea */}
          <div className="space-y-2 pt-4 border-t">
            <div className="flex justify-between items-center">
              <Label htmlFor="imagePromptTextarea" className="text-sm font-medium">Full Prompt</Label>
              {isManualPromptOutOfSync() && (
                <div className="flex items-center gap-2">
                  <AlertTriangle className="h-4 w-4 text-amber-500" />
                  <span className="text-xs text-amber-600">Prompt manually edited</span>
                  <Button variant="link" size="sm" onClick={resetPromptToAuto} className="text-xs text-amber-600 hover:text-amber-700 p-0 h-auto">
                    Reset to Auto
                  </Button>
                </div>
              )}
            </div>
            <Textarea
              id="imagePromptTextarea"
              value={currentPrompt}
              onChange={(e) => handlePromptChange(e.target.value)}
              rows={5}
              className="text-xs font-mono"
              placeholder="Prompt will be generated here based on your selections, or you can type your own."
              disabled={commonFormDisabled}
            />
          </div>
        </CardContent>
        <CardFooter className="flex-col items-stretch space-y-4">
          <motion.div whileHover={{ scale: 1.02 }} whileTap={{ scale: 0.98 }}>
            <Button
              variant="gradient"
              onClick={handleSubmit}
              disabled={isLoading || !preparedImageUrl || isReRollingSlot !== null || !currentPrompt.trim()}
              className="w-full text-lg hover:animate-shimmer"
              size="lg"
            >
              <AnimatePresence mode="wait" initial={false}>
                {isLoading ? (
                  <motion.span
                    key="loading"
                    initial={{ opacity: 0, y: -5 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: 5 }}
                    transition={{ duration: 0.2 }}
                    className="flex items-center justify-center"
                  >
                    <Loader2 className="mr-2 h-5 w-5 animate-spin" /> Generating Images...
                  </motion.span>
                ) : (
                  <motion.span
                    key="idle"
                    initial={{ opacity: 0, y: -5 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: 5 }}
                    transition={{ duration: 0.2 }}
                    className="flex items-center justify-center"
                  >
                    <Wand2 className="mr-2 h-5 w-5" /> Generate {NUM_IMAGES_TO_GENERATE} Images
                  </motion.span>
                )}
              </AnimatePresence>
            </Button>
          </motion.div>
        </CardFooter>
      </Card>
      {/* Generated Images Display */}
      {(outputImageUrls.some(uri => uri !== null) || generationErrors.some(err => err !== null) || isLoading) && (
        <Card variant="glass">
          <CardHeader>
            <CardTitle className="text-xl flex items-center gap-2">
              <Palette className="h-6 w-6 text-primary" />
              Generated Images
            </CardTitle>
            <CardDescription className="hidden lg:block">Your AI-generated fashion model images.</CardDescription>
          </CardHeader>
          <CardContent>
            <motion.div
              className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"
              variants={containerAnim}
              initial="hidden"
              animate="visible"
            >
              {/* If loading, render placeholders. Otherwise, map over results. */}
              {isLoading ? (
                Array.from({ length: NUM_IMAGES_TO_GENERATE }).map((_, index) => (
                  <div key={`loader-${index}`} className="aspect-[3/4] bg-muted/50 rounded-md border animate-pulse flex items-center justify-center">
                    <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
                  </div>
                ))
              ) : (
                outputImageUrls.map((uri, index) => {
                  if (uri === null) {
                    return (
                      <div key={index} className="aspect-[3/4] bg-muted/50 rounded-md border flex items-center justify-center">
                        <p className="text-sm text-muted-foreground">Image {index + 1} not generated</p>
                      </div>
                    );
                  }
                  const isError = generationErrors[index] !== null;
                  const displayUrl = getDisplayableImageUrl(comparingSlotIndex === index ? originalOutputImageUrls[index] : uri) || '';
                  return (
                    <motion.div key={index} variants={itemAnim} className="group rounded-md overflow-hidden flex flex-col border border-border/20">
                      <div className="relative aspect-[3/4] w-full">
                        <Image
                          src={displayUrl || ''}
                          alt={`Generated Image ${index + 1}`}
                          fill
                          sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 33vw"
                          className="object-cover group-hover:scale-105 transition-transform duration-300"
                        />
                        {/* Loading overlay for reroll/upscale */}
                        {(isReRollingSlot === index || isUpscalingSlot === index) && (
                          <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
                            <Loader2 className="h-8 w-8 text-white animate-spin" />
                          </div>
                        )}
                      </div>
                      <div className="p-2 bg-card/80 backdrop-blur-md space-y-2">
                        <div className="grid grid-cols-2 gap-2">
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => handleReRollImage(index)}
                            disabled={isLoading || isReRollingSlot !== null || isUpscalingSlot !== null}
                          >
                            <RefreshCw className="mr-2 h-4 w-4" /> Re-roll
                          </Button>
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => handleUpscale(index)}
                            disabled={isLoading || isUpscalingSlot !== null || isReRollingSlot !== null || !!originalOutputImageUrls[index]}
                          >
                            <Sparkles className="mr-2 h-4 w-4" /> Upscale
                          </Button>
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => handleDownloadOutput(uri, index)}
                            className="flex-1"
                            disabled={isLoading || isReRollingSlot !== null || isUpscalingSlot !== null}
                          >
                            <Download className="mr-2 h-4 w-4" /> Download
                          </Button>
                          <Button
                            variant="secondary"
                            size="sm"
                            onClick={() => handleSendToVideoPage(uri)}
                            className="flex-1"
                            disabled={isLoading || isReRollingSlot !== null || isUpscalingSlot !== null}
                          >
                            <VideoIcon className="mr-2 h-4 w-4" /> Video
                          </Button>
                        </div>
                        {originalOutputImageUrls[index] && (
                          <Button variant="ghost" size="sm" className="w-full select-none"
                            onMouseDown={() => setComparingSlotIndex(index)}
                            onMouseUp={() => setComparingSlotIndex(null)}
                            onMouseLeave={() => setComparingSlotIndex(null)}
                            onTouchStart={(e) => { e.preventDefault(); setComparingSlotIndex(index); }}
                            onTouchEnd={() => setComparingSlotIndex(null)}
                          >
                            <Eye className="mr-2 h-4 w-4" /> Hold to Compare
                          </Button>
                        )}
                        {isError ? (
                          <p className="mt-2 text-sm text-red-500">{generationErrors[index]}</p>
                        ) : null}
                      </div>
                    </motion.div>
                  );
                })
              )}
            </motion.div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
</file>

<file path="src/components/ImageComparator.tsx">
"use client";

import React from 'react';
import ReactCompareImage from 'react-compare-image';
import { ChevronsLeftRight } from 'lucide-react';
import { Skeleton } from '@/components/ui/skeleton';
import { getDisplayableImageUrl } from '@/lib/utils';
import { cn } from '@/lib/utils';

interface ImageComparatorProps {
  leftImageUri: string;
  rightImageUri: string;
}

const CustomHandle = () => (
  <div className="flex items-center justify-center h-10 w-10 bg-white/80 backdrop-blur-sm rounded-full border shadow-md cursor-ew-resize opacity-75 group-hover:opacity-100 transition-opacity">
    <ChevronsLeftRight className="h-5 w-5 text-gray-700" />
  </div>
);

const ComparisonSkeleton = () => (
  <div className="w-full h-full max-h-[60vh] bg-muted rounded-md flex items-center justify-center">
    <Skeleton className="w-full h-full" />
  </div>
);

export default function ImageComparator({
  leftImageUri,
  rightImageUri,
}: ImageComparatorProps) {
  return (
    // This div makes the component fill its parent container.
    <div className="w-full h-full image-comparator-wrapper">
      {/*
        The react-compare-image library applies an inline style of `object-fit: cover`, which crops the image.
        To override this, we must use a <style> tag with `!important`. This is the only
        way to win the CSS specificity battle against inline styles. The parent `.image-comparator-wrapper`
        scopes this override to only this component.
      */}
      <style jsx global>{`
        .image-comparator-wrapper .ReactCompareImage_img {
          object-fit: contain !important;
        }
      `}</style>
      <ReactCompareImage
        leftImage={getDisplayableImageUrl(leftImageUri) || ''}
        rightImage={getDisplayableImageUrl(rightImageUri) || ''}
        hover={true}
        handle={<CustomHandle />}
        sliderLineWidth={3}
        sliderLineColor="hsl(var(--primary))"
        skeleton={<ComparisonSkeleton />}
      />
    </div>
  );
}
</file>

<file path="src/components/ImageEditorCanvas.tsx">
// src/components/ImageEditorCanvas.tsx
"use client";

import React, { useCallback, useEffect, useRef, useMemo } from "react";
import ReactCrop, { type Crop, type PixelCrop, centerCrop, makeAspectCrop } from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';
import Image from 'next/image';
import { getDisplayableImageUrl } from "@/lib/utils";

interface DisplayImage {
  id: string;
  dataUri: string;
}

interface ImageEditorCanvasProps {
  image: DisplayImage | null;
  preparationMode: 'image' | 'video';
  aspect?: number;
  disabled?: boolean;
  onAspectChange: (aspect: number | undefined) => void;
  crop?: Crop;
  onCropChange?: (crop: Crop) => void;
  onCropComplete?: (crop: PixelCrop) => void;
  onImageLoad?: (img: HTMLImageElement) => void;
}

// --- Helper Functions ---
// The getCroppedImgDataUrl function has been moved to the parent component

export default function ImageEditorCanvas({ 
  image,
  preparationMode, 
  aspect, 
  disabled = false, 
  onAspectChange,
  crop,
  onCropChange,
  onCropComplete,
  onImageLoad
}: ImageEditorCanvasProps) {
  // Use a ref for the displayed image element to avoid re-renders.
  const imgRef = useRef<HTMLImageElement | null>(null);
  
  // Use passed crop state or fallback to local state
  const currentCrop = crop;
  const handleCropChange = useMemo(() => onCropChange || (() => {}), [onCropChange]);
  const handleCropComplete = useMemo(() => onCropComplete || (() => {}), [onCropComplete]);

  // --- Recalculation logic when aspect ratio changes ---
  const recalculateCrop = useCallback((aspectRatio: number | undefined, imageElement: HTMLImageElement) => {
    const { naturalWidth: imgWidth, naturalHeight: imgHeight } = imageElement;
    let newCrop: Crop;

    if (aspectRatio) {
      // Check if a full-height crop with the target aspect ratio fits within the image width
      const requiredWidthForFullHeight = imgHeight * aspectRatio;
      if (requiredWidthForFullHeight <= imgWidth) {
        // It fits, so use full height
        newCrop = centerCrop(
          makeAspectCrop(
            {
              unit: '%',
              height: 100,
            },
            aspectRatio,
            imgWidth,
            imgHeight
          ),
          imgWidth,
          imgHeight
        );
      } else {
        // It doesn't fit (image is too narrow/tall), so use full width instead
        newCrop = centerCrop(
          makeAspectCrop(
            {
              unit: '%',
              width: 100,
            },
            aspectRatio,
            imgWidth,
            imgHeight
          ),
          imgWidth,
          imgHeight
        );
      }
    } else {
      // Fallback for "free" aspect ratio
      newCrop = centerCrop(
        makeAspectCrop(
          {
            unit: '%',
            width: 90,
          },
          imgWidth / imgHeight,
          imgWidth,
          imgHeight
        ),
        imgWidth,
        imgHeight
      );
    }

    // Set crop through the callback
    handleCropChange(newCrop as Crop);
    handleCropComplete({
      unit: 'px',
      x: (newCrop.x / 100) * imgWidth,
      y: (newCrop.y / 100) * imgHeight,
      width: (newCrop.width / 100) * imgWidth,
      height: (newCrop.height / 100) * imgHeight,
    });
  }, [handleCropChange, handleCropComplete]);

  // --- Event Handlers ---
  const handleImageLoad = useCallback((e: React.SyntheticEvent<HTMLImageElement>) => {
    const img = e.currentTarget;
    imgRef.current = img;
    if (onImageLoad) {
      onImageLoad(img);
    }
    // No longer automatically calculates crop here - only when aspect changes
  }, [onImageLoad]);

  // --- Effects ---
  
  // Handle crop activation and deactivation based on aspect ratio
  useEffect(() => {
    if (imgRef.current && aspect !== undefined) {
      // Activate cropping mode: calculate and set the crop
      recalculateCrop(aspect, imgRef.current);
    }
    // No need to clear crop states here - handled by parent
  }, [aspect, recalculateCrop]);

  // Reset imgRef when active image changes
  useEffect(() => {
    imgRef.current = null;
  }, [image?.id]);

  if (!image) {
    return null;
  }

  const imageUrlToDisplay = getDisplayableImageUrl(image.dataUri);

  return (
    <>
      {/* Processing overlay */}
      {/* Removed processing overlay as it's now handled in the parent component */}

      {/* Image with crop overlay */}
      <ReactCrop 
        crop={currentCrop}
        onChange={(_, percentCrop) => handleCropChange(percentCrop)} 
        onComplete={(c) => handleCropComplete(c)} 
        aspect={aspect} 
        className="max-h-[60vh]" 
        disabled={disabled}
      >
        <Image 
          key={image.id}
          src={imageUrlToDisplay || ''} 
          alt="Editable image" 
          onLoad={handleImageLoad} 
          className="max-h-[60vh] object-contain" 
          width={800}
          height={600}
          sizes="(max-width: 1023px) 100vw, 75vw"
          style={{ maxHeight: '60vh', objectFit: 'contain' }}
        />
      </ReactCrop>
    </>
  );
}
</file>

<file path="src/components/ImagePreparationContainer.tsx">
// src/components/ImagePreparationContainer.tsx
"use client";

import React, { useState, useCallback, useEffect, useRef } from "react";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useImageStore, useActiveImage } from "@/stores/imageStore";
import { useToast } from "@/hooks/use-toast";
import { getDisplayableImageUrl } from "@/lib/utils";
import { type Crop, type PixelCrop, centerCrop, makeAspectCrop } from 'react-image-crop';
import { motion, AnimatePresence } from "motion/react";

// New Components
import ImageUploader from "./ImageUploader";
import ImageEditorCanvas from "./ImageEditorCanvas";
import ImageProcessingTools from "./ImageProcessingTools";
import AspectRatioSelector from "./AspectRatioSelector";
import ImageVersionStack from "./ImageVersionStack";

import { 
  UploadCloud, CheckCircle, RefreshCw, Loader2, Trash2, Eye, X, Check, Edit 
} from "lucide-react";

// --- Constants ---
const SERVER_IMAGE_PATH_PREFIX = '/uploads/';

// --- Helper function to get the default aspect based on mode ---
const getDefaultAspect = (mode: 'image' | 'video') => {
  return mode === 'video' ? 9 / 16 : 3 / 4;
};

// --- Hashing Helper Function ---
const generateDataUriHash = async (dataUri: string): Promise<string> => {
  const base64 = dataUri.split(',')[1];
  if (!base64) throw new Error('Invalid data URI for hashing');
  const buffer = Uint8Array.from(atob(base64), c => c.charCodeAt(0)).buffer;
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
};

// --- Cropping Helper Function ---
async function getCroppedImgDataUrl(
  displayedImage: HTMLImageElement,
  crop: PixelCrop,
  sourceDataUri: string
): Promise<string> {
  const offscreenImage = new window.Image();
  offscreenImage.src = sourceDataUri;

  return new Promise((resolve, reject) => {
    offscreenImage.onload = () => {
      const canvas = document.createElement('canvas');
      const scaleX = offscreenImage.naturalWidth / displayedImage.width;
      const scaleY = offscreenImage.naturalHeight / displayedImage.height;

      canvas.width = Math.floor(crop.width * scaleX);
      canvas.height = Math.floor(crop.height * scaleY);

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        return reject(new Error('Failed to get canvas context'));
      }

      ctx.drawImage(
        offscreenImage,
        crop.x * scaleX,
        crop.y * scaleY,
        crop.width * scaleX,
        crop.height * scaleY,
        0, 0, canvas.width, canvas.height
      );

      resolve(canvas.toDataURL('image/jpeg', 0.9));
    };
    offscreenImage.onerror = (err) => reject(err);
  });
}

interface ImagePreparationContainerProps {
  sourceImageUrl?: string | null;
  preparationMode: 'image' | 'video';
  onReset: () => void;
  isLoadingHistory?: boolean;
}

export default function ImagePreparationContainer({ 
  sourceImageUrl, 
  preparationMode,
  onReset,
  isLoadingHistory = false
}: ImagePreparationContainerProps) {
  const { toast } = useToast();
  
  // Store state
  const { 
    original, 
    versions, 
    activeVersionId, 
    isProcessing, 
    processingStep,
    setActiveVersion,
    reset: resetStore,
    setProcessing,
    addVersion
  } = useImageStore();
  
  const activeImage = useActiveImage();

  // Local UI state
  const [aspect, setAspect] = useState<number | undefined>(undefined);
  const [isComparing, setIsComparing] = useState(false);
  const [isLoadingFromUrl, setIsLoadingFromUrl] = useState(false);
  
  // Cropping state
  const [crop, setCrop] = useState<Crop>();
  const [completedCrop, setCompletedCrop] = useState<PixelCrop>();
  const imgRef = useRef<HTMLImageElement | null>(null);

  // Logic to determine if comparison is possible
  const sourceVersion = activeImage?.sourceVersionId ? versions[activeImage.sourceVersionId] : null;

  // --- Effects ---

  // Recalculation logic when aspect ratio changes
  const recalculateCrop = useCallback((aspectRatio: number | undefined, imageElement: HTMLImageElement) => {
    const { naturalWidth: imgWidth, naturalHeight: imgHeight } = imageElement;
    let newCrop: Crop;

    if (aspectRatio) {
      // Check if a full-height crop with the target aspect ratio fits within the image width
      const requiredWidthForFullHeight = imgHeight * aspectRatio;
      if (requiredWidthForFullHeight <= imgWidth) {
        // It fits, so use full height
        newCrop = centerCrop(
          makeAspectCrop(
            { unit: '%', height: 100 },
            aspectRatio, imgWidth, imgHeight
          ),
          imgWidth, imgHeight
        );
      } else {
        // It doesn't fit (image is too narrow/tall), so use full width instead
        newCrop = centerCrop(
          makeAspectCrop(
            { unit: '%', width: 100 },
            aspectRatio, imgWidth, imgHeight
          ),
          imgWidth, imgHeight
        );
      }
    } else {
      // Fallback for "free" aspect ratio
      newCrop = centerCrop(
        makeAspectCrop(
          { unit: '%', width: 90 },
          imgWidth / imgHeight, imgWidth, imgHeight
        ),
        imgWidth, imgHeight
      );
    }

    setCrop(newCrop as Crop);
    setCompletedCrop({
      unit: 'px',
      x: (newCrop.x / 100) * imgWidth,
      y: (newCrop.y / 100) * imgHeight,
      width: (newCrop.width / 100) * imgWidth,
      height: (newCrop.height / 100) * imgHeight,
    });
  }, []);
  
  useEffect(() => {
    setAspect(undefined);
  }, [preparationMode]);

  // Handle crop activation and deactivation based on aspect ratio
  useEffect(() => {
    if (imgRef.current && aspect !== undefined) {
      recalculateCrop(aspect, imgRef.current);
    }
  }, [aspect, recalculateCrop]);

  // Effect to load image from URL, moved from ImageUploader
  useEffect(() => {
    if (sourceImageUrl && !original && !isLoadingFromUrl) {
      const loadImageFromUrl = async () => {
        setIsLoadingFromUrl(true);
        try {
          const displayUrl = getDisplayableImageUrl(sourceImageUrl);
          if (!displayUrl) throw new Error("Could not generate displayable URL.");
          const response = await fetch(displayUrl);
          if (!response.ok) throw new Error(`Failed to fetch image: ${response.statusText}`);
          const blob = await response.blob();
          const file = new File([blob], 'loaded-image.jpg', { type: blob.type });
          await useImageStore.getState().uploadOriginalImage(file);
        } catch (error) {
          console.error('Error loading image from sourceImageUrl:', error);
          toast({ title: "Load Error", description: "Failed to load the image from history.", variant: "destructive" });
        } finally {
          setIsLoadingFromUrl(false);
        }
      };
      loadImageFromUrl();
    }
  }, [sourceImageUrl, original, isLoadingFromUrl, toast]);

  // --- Cropping Handlers ---
  
  const handleApplyCrop = useCallback(async () => {
    if (!completedCrop || !imgRef.current || !activeImage) return;
    
    try {
      const croppedDataUrl = await getCroppedImgDataUrl(
        imgRef.current,
        completedCrop,
        activeImage.dataUri
      );
      
      const croppedHash = await generateDataUriHash(croppedDataUrl);

      addVersion({
        dataUri: croppedDataUrl,
        label: 'Cropped',
        sourceVersionId: activeImage.id,
        hash: croppedHash,
      });
      
      toast({ title: "Crop Applied", description: "A new cropped version has been added to your history." });
      setAspect(undefined); // Deactivate cropping mode
    } catch (error) {
      console.error('Cropping failed:', error);
      toast({ title: "Cropping Failed", description: "Could not apply the crop.", variant: "destructive" });
    }
  }, [completedCrop, activeImage, addVersion, toast]);

  const handleCancelCrop = () => {
    setAspect(undefined); // This will clear the crop UI
  };

  const handleImageLoad = (img: HTMLImageElement) => {
    imgRef.current = img;
  };

  // --- Render Logic ---
  
  // Show a loading skeleton if loading from URL or waiting for history data
  if (isLoadingFromUrl || (isLoadingHistory && sourceImageUrl)) {
    return (
      <Card variant="glass">
        <CardContent className="flex items-center justify-center p-10 min-h-[400px]">
          <Loader2 className="h-8 w-8 animate-spin text-primary" />
        </CardContent>
      </Card>
    );
  }

  // Show uploader if no image
  if (!original) {
    return (
      <AnimatePresence mode="wait">
        <motion.div key="uploader" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
          <ImageUploader />
        </motion.div>
      </AnimatePresence>
    );
  }

  // Determine which image data to pass to the canvas
  const imageForCanvas = isComparing && sourceVersion ? sourceVersion : activeImage;

  // Main editor interface
  return (
    <motion.div layout transition={{ duration: 0.5, type: 'spring', bounce: 0.2 }}>
      <Card variant="glass">
        <CardHeader>
          <div className="flex justify-between items-start gap-4">
            <div>
              <CardTitle className="text-xl flex items-center gap-2">
                <UploadCloud className="h-6 w-6 text-primary" />
                Prepare Your Image
              </CardTitle>
              <CardDescription className="hidden lg:block">
                Upload, crop, and process your clothing image. The canvas shows the version that will be used for generation.
              </CardDescription>
            </div>
            {activeImage && (
              <Button 
                variant="destructive" 
                size="sm" 
                onClick={onReset} 
                disabled={isProcessing}
              >
                <Trash2 className="mr-2 h-4 w-4" />
                Remove Image
              </Button>
            )}
          </div>
        </CardHeader>
        <CardContent className="space-y-6 pt-6">
          <AnimatePresence mode="wait">
            <motion.div key="editor" initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }}>
              <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
                {/* Main View Area: Now with a unified container */}
                <div className="lg:col-span-3 relative flex flex-col items-center justify-center bg-muted/20 p-2 rounded-lg border">
                  <ImageEditorCanvas 
                    image={imageForCanvas}
                    preparationMode={preparationMode}
                    aspect={aspect}
                    disabled={false}
                    onAspectChange={setAspect}
                    crop={crop}
                    onCropChange={setCrop}
                    onCropComplete={setCompletedCrop}
                    onImageLoad={handleImageLoad}
                  />

                  {/* 'Hold to Compare' button */}
                  {sourceVersion && (
                    <Button 
                      variant="outline" 
                      className="absolute bottom-4 right-4 z-10 bg-background/80 backdrop-blur-sm select-none"
                      onMouseDown={() => setIsComparing(true)}
                      onMouseUp={() => setIsComparing(false)}
                      onMouseLeave={() => setIsComparing(false)}
                      onTouchStart={(e) => { e.preventDefault(); setIsComparing(true); }}
                      onTouchEnd={() => setIsComparing(false)}
                    >
                      <Eye className="mr-2 h-4 w-4" />
                      Compare
                    </Button>
                  )}
                </div>

                {/* Controls Panel: Conditionally render controls based on view */}
                <div className="lg:col-span-1 flex flex-col space-y-6">
                  {/* Only editor controls, no comparison controls */}
                  <AspectRatioSelector
                    preparationMode={preparationMode}
                    aspect={aspect}
                    onAspectChange={setAspect}
                    disabled={false}
                  />

                  {/* Processing Tools are always visible but disabled during crop */}
                  <ImageProcessingTools 
                    preparationMode={preparationMode} 
                    disabled={isProcessing || aspect !== undefined} 
                  />

                  {/* Contextual Crop Action Bar */}
                  {aspect !== undefined && (
                    <div className="flex gap-2 animate-in fade-in">
                      <Button
                        variant="outline"
                        size="sm"
                        className="flex-1"
                        onClick={handleCancelCrop}
                        disabled={isProcessing}
                      >
                        <X className="mr-2 h-4 w-4" /> Cancel
                      </Button>
                      <Button
                        size="sm"
                        className="flex-1"
                        onClick={handleApplyCrop}
                        disabled={isProcessing}
                      >
                        <Check className="mr-2 h-4 w-4" /> Apply Crop
                      </Button>
                    </div>
                  )}
                </div>
              </div>
              
              {/* Version Stack - Always visible when there are images */}
              {Object.keys(versions).length > 0 && (
                <ImageVersionStack
                  versions={versions}
                  activeVersionId={activeVersionId}
                  isProcessing={isProcessing}
                />
              )}
            </motion.div>
          </AnimatePresence>
        </CardContent>
      </Card>
    </motion.div>
  );
}
</file>

<file path="src/components/ImageProcessingTools.tsx">
// src/components/ImageProcessingTools.tsx
"use client";

import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { useImageStore, useActiveImage } from "@/stores/imageStore";
import { useToast } from "@/hooks/use-toast";
import { 
  isBackgroundRemovalAvailable as checkBgAvailable,
} from "@/ai/actions/remove-background.action";
import { 
  isUpscaleServiceAvailable as checkUpscaleAvailable, 
  isFaceDetailerAvailable as checkFaceDetailerAvailable 
} from "@/ai/actions/upscale-image.action";
import { 
  Wand2, Sparkles, UserCheck, CheckCircle, Loader2 
} from "lucide-react";
import { useAuth } from '@/contexts/AuthContext';

interface ImageProcessingToolsProps {
  preparationMode: 'image' | 'video';
  disabled?: boolean;
}

export default function ImageProcessingTools({ preparationMode, disabled = false }: ImageProcessingToolsProps) {
  const { toast } = useToast();
  const { 
    removeBackground, 
    upscaleImage, 
    faceDetailer, 
    isProcessing, 
    processingStep,
    setActiveVersion,
    versions
  } = useImageStore();
  
  const activeImage = useActiveImage();
  const { user } = useAuth();

  // Service availability state
  const [isBgRemovalAvailable, setIsBgRemovalAvailable] = useState(false);
  const [isUpscalingAvailable, setIsUpscalingAvailable] = useState(false);
  const [isFaceDetailerAvailable, setIsFaceDetailerAvailable] = useState(false);

  // --- Effects ---
  useEffect(() => {
    // Check service availability on mount
    checkBgAvailable().then(setIsBgRemovalAvailable);
    checkUpscaleAvailable().then(setIsUpscalingAvailable);
    checkFaceDetailerAvailable().then(setIsFaceDetailerAvailable);
  }, []);

  // Don't render if no active image
  if (!activeImage) {
    return null;
  }

  // Computed states based on version labels
  const isBgRemoved = activeImage.label.includes('Background Removed');
  const isUpscaled = activeImage.label.includes('Upscaled');
  const isFaceDetailed = activeImage.label.includes('Face Enhanced');

  // --- Event Handlers ---
  const handleToggleBackgroundRemoval = async (checked: boolean) => {
    if (!user?.username) return toast({ title: 'Authentication Error', variant: 'destructive' });
    if (checked) {
      try {
        await removeBackground(user.username);
        toast({ title: 'Background Removed', description: 'Background has been successfully removed.' });
      } catch (error) {
        toast({ 
          title: 'Background Removal Failed', 
          description: (error as Error).message, 
          variant: 'destructive' 
        });
      }
    } else {
      // Find and switch to a version without background removal
      if (activeImage.sourceVersionId && versions[activeImage.sourceVersionId]) {
        setActiveVersion(activeImage.sourceVersionId);
        toast({ 
          title: "Switched to Previous Version", 
          description: "Background restoration isn't needed - just select a different version." 
        });
      } else {
        toast({ 
          title: "Info", 
          description: "Use the version history below to switch between different processed versions." 
        });
      }
    }
  };

  const handleUpscaleImage = async () => {
    if (!user?.username) return toast({ title: 'Authentication Error', variant: 'destructive' });
    try {
      await upscaleImage(user.username);
      toast({ title: 'Image Upscaled', description: 'Your image has been upscaled successfully.' });
    } catch (error) {
      toast({ 
        title: 'Upscaling Failed', 
        description: (error as Error).message, 
        variant: 'destructive' 
      });
    }
  };

  const handleFaceDetailer = async () => {
    if (!user?.username) return toast({ title: 'Authentication Error', variant: 'destructive' });
    try {
      await faceDetailer(user.username);
      toast({ title: 'Face Details Enhanced', description: 'Face details have been enhanced successfully.' });
    } catch (error) {
      toast({ 
        title: 'Face Enhancement Failed', 
        description: (error as Error).message, 
        variant: 'destructive' 
      });
    }
  };

  const isToolDisabled = disabled || isProcessing;

  return (
    <div className="space-y-3">
      <h3 className="font-semibold text-sm">Processing Tools</h3>
      
      {/* Background Removal */}
      {isBgRemovalAvailable && (
        <div className="flex items-center justify-between p-3 border rounded-md">
          <Label htmlFor="bg-remove-switch" className="flex items-center gap-2">
            <Wand2 className="h-4 w-4" />
            Remove Background
          </Label>
          <div className="flex items-center gap-2">
            {isProcessing && processingStep === 'bg' && (
              <Loader2 className="h-4 w-4 animate-spin" />
            )}
            <Switch 
              id="bg-remove-switch" 
              checked={isBgRemoved} 
              onCheckedChange={handleToggleBackgroundRemoval} 
              disabled={isToolDisabled || isUpscaled} 
            />
          </div>
        </div>
      )}

      {/* Upscale Image - Only for video mode */}
      {preparationMode === 'video' && isUpscalingAvailable && (
        <Button 
          onClick={handleUpscaleImage} 
          variant="outline" 
          disabled={isToolDisabled || isUpscaled} 
          className="w-full"
        >
          {isProcessing && processingStep === 'upscale' ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Upscaling...
            </>
          ) : isUpscaled ? (
            <>
              <CheckCircle className="mr-2 h-4 w-4" />
              Upscaled
            </>
          ) : (
            <>
              <Sparkles className="mr-2 h-4 w-4" />
              Upscale Image
            </>
          )}
        </Button>
      )}

      {/* Face Detailer - Only for video mode */}
      {preparationMode === 'video' && isFaceDetailerAvailable && (
        <Button 
          onClick={handleFaceDetailer} 
          variant="outline" 
          disabled={isToolDisabled || isFaceDetailed} 
          className="w-full"
        >
          {isProcessing && processingStep === 'face' ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              Enhancing...
            </>
          ) : isFaceDetailed ? (
            <>
              <CheckCircle className="mr-2 h-4 w-4" />
              Face Detailed
            </>
          ) : (
            <>
              <UserCheck className="mr-2 h-4 w-4" />
              Face Detailer
            </>
          )}
        </Button>
      )}
    </div>
  );
}
</file>

<file path="src/components/ImageUploader.tsx">
// src/components/ImageUploader.tsx
"use client";

import React, { useRef, useState, useCallback, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import { useImageStore } from "@/stores/imageStore";
import { UploadCloud } from "lucide-react";
import { motion, AnimatePresence } from 'motion/react';

// --- Constants ---
const MAX_FILE_SIZE_MB = 50;
const MAX_FILE_SIZE_BYTES = MAX_FILE_SIZE_MB * 1024 * 1024;
const ALLOWED_FILE_TYPES = ['image/png', 'image/jpeg', 'image/webp', 'image/gif', 'image/heic', 'image/heif', 'image/avif'];

export default function ImageUploader() {
  const { toast } = useToast();
  const fileInputRef = useRef<HTMLInputElement>(null);
  const dragCounter = useRef(0);
  
  // Store state
  const { original, isProcessing, reset, uploadOriginalImage } = useImageStore();
  
  // Local UI state
  const [isDraggingOverPage, setIsDraggingOverPage] = useState(false);
  const [isDraggingOverDropZone, setIsDraggingOverDropZone] = useState(false);

  // Define variants for the dropzone's different states
  const dropZoneVariants = {
    idle: {
      borderColor: 'hsl(210 10% 23%)',
      backgroundColor: 'hsla(224 40% 8% / 0.5)'
    },
    dragOver: {
      borderColor: 'hsl(173 71% 42%)',
      backgroundColor: 'hsla(173 71% 42% / 0.1)',
      scale: 1.02,
    },
  };

  // --- File Processing ---
  const processFile = useCallback(async (file: File | null | undefined) => {
    if (!file) return;
    
    // Validate file
    if (file.size > MAX_FILE_SIZE_BYTES) {
      toast({ 
        title: "File Too Large", 
        description: `File must be under ${MAX_FILE_SIZE_MB}MB.`, 
        variant: "destructive" 
      });
      return;
    }
    
    if (!ALLOWED_FILE_TYPES.includes(file.type)) {
      toast({ 
        title: "Invalid File Type", 
        description: "Please upload a valid image file (PNG, JPG, WEBP, etc.).", 
        variant: "destructive" 
      });
      return;
    }

    try {
      const { resized, originalWidth, originalHeight } = await uploadOriginalImage(file);
      let toastDescription = "Your image is ready for editing.";
      if (resized) {
        toastDescription = `Image was downscaled from ${originalWidth}x${originalHeight} and is ready for editing.`;
      }
      toast({ 
        title: "Image Uploaded", 
        description: toastDescription
      });
    } catch (error) {
      console.error('Error processing file:', error);
      const errorMessage = error instanceof Error ? error.message : "Failed to process the uploaded image.";
      toast({ 
        title: "Upload Failed", 
        description: errorMessage, 
        variant: "destructive" 
      });
    }
  }, [toast, uploadOriginalImage]);

  // --- Event Handlers ---
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    processFile(e.target.files?.[0]);
  };
  
  const handleDragAction = useCallback((e: React.DragEvent, action: 'enter' | 'leave' | 'over' | 'drop') => {
    e.preventDefault();
    e.stopPropagation();
    
    if (isProcessing) return;
    
    if (action === 'enter') {
      dragCounter.current++;
    }
    if (action === 'leave') {
      dragCounter.current--;
    }
    
    setIsDraggingOverPage(dragCounter.current > 0);

    if (action === 'drop' && e.dataTransfer.files.length > 0) {
      dragCounter.current = 0;
      setIsDraggingOverPage(false);
      processFile(e.dataTransfer.files[0]);
    }
  }, [processFile, isProcessing]);

  // Modify handleDragAction to set state for the drop zone specifically
  const handleDropZoneDrag = (e: React.DragEvent, action: 'enter' | 'leave') => {
    e.preventDefault();
    e.stopPropagation();
    setIsDraggingOverDropZone(action === 'enter');
  };

  // --- Effects ---
  
  // Handle drag and drop events on the page
  useEffect(() => {
    const enter = (e: DragEvent) => handleDragAction(e as any, 'enter');
    const leave = (e: DragEvent) => handleDragAction(e as any, 'leave');
    const over = (e: DragEvent) => handleDragAction(e as any, 'over');
    const drop = (e: DragEvent) => handleDragAction(e as any, 'drop');

    window.addEventListener('dragenter', enter);
    window.addEventListener('dragleave', leave);
    window.addEventListener('dragover', over);
    window.addEventListener('drop', drop);

    return () => {
      window.removeEventListener('dragenter', enter);
      window.removeEventListener('dragleave', leave);
      window.removeEventListener('dragover', over);
      window.removeEventListener('drop', drop);
    };
  }, [handleDragAction]);

  return (
    <>
      {/* Global drag overlay */}
      {isDraggingOverPage && (
        <div className="fixed inset-0 z-50 flex flex-col items-center justify-center bg-background/80 backdrop-blur-sm pointer-events-none">
          <UploadCloud 
            className="h-24 w-24 text-primary"
            style={{ animation: 'var(--motion-bounce-subtle) infinite' }}
          />
          <p className="mt-4 text-2xl font-semibold text-foreground">Drop image to upload</p>
        </div>
      )}

      <Card>
        <CardHeader>
          <CardTitle className="text-xl flex items-center gap-2">
            <UploadCloud className="h-6 w-6 text-primary" />
            Upload Your Image
          </CardTitle>
          <CardDescription>
            Upload your clothing image to get started. Drag and drop or click to browse.
          </CardDescription>
        </CardHeader>

        <CardContent>
          <motion.div
            animate={isDraggingOverDropZone ? "dragOver" : "idle"}
            variants={dropZoneVariants}
            transition={{ stiffness: 500, damping: 30 }}
            className="p-12 rounded-lg flex flex-col items-center justify-center text-center text-muted-foreground border-2 border-dashed cursor-pointer"
            onClick={() => fileInputRef.current?.click()}
            onDragEnter={(e) => handleDropZoneDrag(e, 'enter')}
            onDragLeave={(e) => handleDropZoneDrag(e, 'leave')}
            onDragOver={(e) => e.preventDefault()}
            onDrop={(e) => { setIsDraggingOverDropZone(false); handleDragAction(e, 'drop'); }}
          >
            <motion.div
              animate={{ scale: isDraggingOverDropZone ? 1.1 : 1, y: isDraggingOverDropZone ? -5 : 0 }}
            >
              <UploadCloud className="w-16 h-16 mb-4 text-muted-foreground" />
            </motion.div>
            <p className="font-semibold text-foreground">Click to upload or drag & drop</p>
            <p className="text-sm">PNG, JPG, WEBP, etc.</p>
            <Input 
              id="image-upload" 
              type="file" 
              className="sr-only" 
              ref={fileInputRef} 
              onChange={handleFileChange} 
              accept={ALLOWED_FILE_TYPES.join(',')} 
              disabled={isProcessing}
            />
          </motion.div>
        </CardContent>
      </Card>
    </>
  );
}
</file>

<file path="src/components/ImageVersionStack.tsx">
// src/components/ImageVersionStack.tsx
"use client";

import React from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { 
  Camera, 
  Crop as CropIcon, 
  Wand2, 
  Sparkles, 
  UserCheck, 
  Clock
} from "lucide-react";
import { useImageStore } from "@/stores/imageStore";

interface ImageVersion {
  id: string;
  dataUri: string;
  label: string;
  sourceVersionId: string;
  createdAt: number;
}

interface ImageVersionStackProps {
  versions: Record<string, ImageVersion>;
  activeVersionId: string | null;
  isProcessing: boolean;
}

const getVersionIcon = (label: string) => {
  if (label.includes('Original')) return <Camera className="h-4 w-4" />;
  if (label.includes('Cropped')) return <CropIcon className="h-4 w-4" />;
  if (label.includes('Background')) return <Wand2 className="h-4 w-4" />;
  if (label.includes('Upscaled')) return <Sparkles className="h-4 w-4" />;
  if (label.includes('Face')) return <UserCheck className="h-4 w-4" />;
  return <Camera className="h-4 w-4" />;
};

const formatTime = (timestamp: number) => {
  const now = Date.now();
  const diff = now - timestamp;
  const seconds = Math.floor(diff / 1000);
  const minutes = Math.floor(seconds / 60);
  
  if (minutes === 0) return 'Just now';
  if (minutes === 1) return '1 minute ago';
  if (minutes < 60) return `${minutes} minutes ago`;
  
  const hours = Math.floor(minutes / 60);
  if (hours === 1) return '1 hour ago';
  return `${hours} hours ago`;
};

export default function ImageVersionStack({ 
  versions, 
  activeVersionId, 
  isProcessing 
}: ImageVersionStackProps) {
  const { setActiveVersion } = useImageStore();
  // Sort versions by creation time, with original first
  const sortedVersions = Object.values(versions).sort((a, b) => {
    if (a.id === 'original') return -1;
    if (b.id === 'original') return 1;
    return a.createdAt - b.createdAt;
  });

  if (sortedVersions.length === 0) {
    return null;
  }

  return (
    <Card>
      <CardHeader className="pb-3">
        <CardTitle className="text-lg flex items-center gap-2">
          <Clock className="h-5 w-5 text-primary" />
          Version History
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-2">
        {sortedVersions.map((version, index) => {
          const isActive = version.id === activeVersionId;
          const sourceVersion = version.sourceVersionId ? versions[version.sourceVersionId] : null;
          
          return (
            <div
              key={version.id}
              className={`
                flex items-center justify-between p-3 rounded-lg border transition-all
                ${isActive 
                  ? 'bg-primary/10 border-primary ring-2 ring-primary/20' 
                  : 'bg-muted/30 border-muted-foreground/20 hover:bg-muted/50'
                }
                ${isProcessing ? 'opacity-50' : 'cursor-pointer'}
              `}
              onClick={() => !isProcessing && setActiveVersion(version.id)}
            >
              <div className="flex items-center gap-3 flex-1 min-w-0">
                <div className={`
                  flex items-center justify-center w-8 h-8 rounded-full
                  ${isActive ? 'bg-primary text-primary-foreground' : 'bg-muted text-muted-foreground'}
                `}>
                  {getVersionIcon(version.label)}
                </div>
                
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2">
                    <span className={`font-medium truncate ${isActive ? 'text-primary' : ''}`}>
                      {version.label}
                    </span>
                    {isActive && (
                      <Badge variant="secondary" className="text-xs">
                        Active
                      </Badge>
                    )}
                  </div>
                  
                  <div className="flex items-center gap-2 text-xs text-muted-foreground">
                    <span>{formatTime(version.createdAt)}</span>
                    {sourceVersion && (
                      <span>• from {sourceVersion.label}</span>
                    )}
                  </div>
                </div>
              </div>
            </div>
          );
        })}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/components/SiteHeader.tsx">
"use client";

import Image from 'next/image';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Separator } from '@/components/ui/separator';
import { ThemeToggleImproved } from '@/components/ui/ThemeToggleImproved';
import { UserAuthStatus, useAuth } from '@/contexts/AuthContext';
import { Home, History as HistoryIcon, ShieldCheck } from 'lucide-react';
import React, { useState, useEffect } from 'react';

export function SiteHeader() {
  const pathname = usePathname();
  const { user } = useAuth();
  const [isClient, setIsClient] = useState(false);
  const [isNavigating, setIsNavigating] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  useEffect(() => {
    setIsNavigating(false);
  }, [pathname]);

  return (
    <header className="border-b border-border sticky top-0 bg-background/95 backdrop-blur-sm z-50">
      <div className="container mx-auto flex justify-between items-center max-w-7xl h-20 px-4">
        {/* Make Logo and Title a link to the homepage */}
        <Link
          href="/create"
          className="flex items-center gap-2.5 sm:gap-3 text-foreground hover:text-primary transition-colors"
          legacyBehavior>
          <Image
            src="/refashion.webp"
            alt="Refashion AI logo"
            width={40}
            height={60}
            className="h-12 w-auto sm:h-14 sm:w-auto"
          />
          <span className="text-xl sm:text-3xl font-bold">
            Refashion AI
          </span>
        </Link>
        <div className="flex items-center gap-2">
          {/* Add Navigation Links */}
          <nav className="flex items-center gap-1">
            {/* Only render the navigation buttons on the client to avoid hydration mismatch */}
            {isClient && (
              <>
                {/* Admin Console Button */}
                {user?.role === 'admin' && (
                  <Button asChild variant={pathname.startsWith('/admin') ? 'active' : 'ghost'} size="sm" className="px-2" onClick={() => setIsNavigating(true)} loading={isNavigating}>
                    <Link href="/admin" legacyBehavior><ShieldCheck className="h-5 w-5 md:mr-2" /><span className="hidden md:inline">Admin</span></Link>
                  </Button>
                )}
                {/* Conditionally render the "Create" button */}
                {pathname.startsWith('/history') && (
                  <Button asChild variant={pathname === '/create' ? 'active' : 'ghost'} size="sm" className="px-2" onClick={() => setIsNavigating(true)} loading={isNavigating}>
                    <Link href="/create" legacyBehavior><Home className="h-5 w-5 md:mr-2" /><span className="hidden md:inline">Create</span></Link>
                  </Button>
                )}
                {/* Conditionally render the "History" button */}
                {pathname.startsWith('/create') && (
                  <Button asChild variant={pathname === '/history' ? 'active' : 'ghost'} size="sm" className="px-2" onClick={() => setIsNavigating(true)} loading={isNavigating}>
                    <Link href="/history" legacyBehavior><HistoryIcon className="h-5 w-5 md:mr-2" /><span className="hidden md:inline">History</span></Link>
                  </Button>
                )}
              </>
            )}
          </nav>
          <Separator orientation="vertical" className="mx-2 h-8" />
          <ThemeToggleImproved />
        </div>
      </div>
    </header>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/alert-dialog.tsx">
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-1 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2", // Increased py-1 for vertical padding
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary/90 text-primary-foreground shadow-sm", // Removed hover effect to keep it static
        secondary:
          "border-transparent bg-secondary text-secondary-foreground",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src/components/ui/button.tsx">
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { motion } from "motion/react"
import { Loader2 } from 'lucide-react';

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
        gradient:
          "bg-gradient-to-r from-primary via-accent to-primary bg-[length:200%_auto] text-primary-foreground hover:shadow-lg hover:shadow-primary/30 transition-shadow",
        active:
          "bg-primary/10 text-primary hover:bg-primary/20",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
  loading?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, loading = false, children, ...props }, ref) => {
    // Only use motion.button for native buttons, and Slot for asChild (no animation)
    if (asChild) {
      return (
        <Slot
          className={cn(buttonVariants({ variant, size, className }), loading && "opacity-80 cursor-not-allowed")}
          ref={ref}
          {...props}
        />
      )
    }
    // Remove onDrag from props to avoid type conflict with motion.button
    const { onDrag, ...rest } = props as any;
    return (
      <motion.button
        className={cn(buttonVariants({ variant, size, className }), loading && "opacity-80 cursor-not-allowed")}
        ref={ref}
        whileHover={{ scale: 1.03 }}
        whileTap={{ scale: 0.97 }}
        transition={{ type: 'spring', stiffness: 400, damping: 15 }}
        disabled={loading || props.disabled}
        {...rest}
      >
        {loading && <Loader2 className="animate-spin" />}
        {!loading && children}
      </motion.button>
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="src/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("h-4 w-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("h-4 w-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  variant?: "default" | "glass"
}

const Card = React.forwardRef<HTMLDivElement, CardProps>(
  ({ className, variant = "default", ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        "rounded-lg text-card-foreground shadow-sm",
        variant === "default" && "bg-card",
        variant === "glass" && "glass-card",
        className
      )}
      {...props}
    />
  )
)
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6 md:p-8", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 md:p-8 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 md:p-8 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content> & { asChild?: boolean }
>(({ className, children, asChild, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      asChild={asChild}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"
import { motion } from "motion/react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => {
  return (
    <motion.div
      whileHover={{ x: 2 }}
      style={{ display: 'contents' }}
    >
      <DropdownMenuPrimitive.Item
        ref={ref}
        className={cn(
          "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
          inset && "pl-8",
          className
        )}
        {...props}
      />
    </motion.div>
  );
})
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="src/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  FormProvider,
  useFormContext,
  type ControllerProps,
  type FieldPath,
  type FieldValues,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message ?? "") : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full items-center rounded-md border border-input bg-transparent px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-card/50 dark:border-white/10 dark:placeholder:text-muted-foreground/60",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="src/components/ui/menubar.tsx">
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

function MenubarMenu({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Menu>) {
  return <MenubarPrimitive.Menu {...props} />
}

function MenubarGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Group>) {
  return <MenubarPrimitive.Group {...props} />
}

function MenubarPortal({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Portal>) {
  return <MenubarPrimitive.Portal {...props} />
}

function MenubarRadioGroup({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.RadioGroup>) {
  return <MenubarPrimitive.RadioGroup {...props} />
}

function MenubarSub({
  ...props
}: React.ComponentProps<typeof MenubarPrimitive.Sub>) {
  return <MenubarPrimitive.Sub data-slot="menubar-sub" {...props} />
}

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}
</file>

<file path="src/components/ui/motion.ts">
// This file re-exports motion from motion/react for consistent usage across the app.
export { motion } from "motion/react";
</file>

<file path="src/components/ui/page-header.tsx">
// src/components/ui/page-header.tsx
import React from 'react';
import { LucideIcon } from 'lucide-react';
import { cn } from '@/lib/utils';

interface PageHeaderProps {
  icon: LucideIcon;
  title: string;
  description: string;
  className?: string;
}

export function PageHeader({ icon: Icon, title, description, className }: PageHeaderProps) {
  return (
    <header className={cn("text-center py-4", className)}>
      <div className="flex items-center justify-center gap-3 sm:gap-4">
        <Icon className="w-10 h-10 sm:w-12 sm:h-12 text-primary" />
        <h1 className="text-4xl sm:text-5xl font-extrabold tracking-tight text-foreground font-sans">
          {title}
        </h1>
      </div>
      <p className="mt-3 text-base sm:text-lg text-muted-foreground max-w-2xl mx-auto">
        {description}
      </p>
    </header>
  );
}
</file>

<file path="src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="src/components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root> & { isEstimating?: boolean; isCompleting?: boolean }
>(({ className, value, isEstimating = false, isCompleting = false, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className={cn(
        "h-full w-full flex-1 bg-primary transition-all duration-300",
        {
          'bg-green-600 animate-progress-completion': isCompleting,
          'animate-progress-ribbings animate-progress-pulsation': isEstimating,
          '[background-image:linear-gradient(45deg,rgba(255,255,255,.15)_25%,transparent_25%,transparent_50%,rgba(255,255,255,.15)_50%,rgba(255,255,255,.15)_75%,transparent_75%,transparent)] [background-size:40px_40px]': isEstimating,
        }
      )}
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</file>

<file path="src/components/ui/radio-group.tsx">
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
</file>

<file path="src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1 dark:bg-card/50 dark:border-white/10",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 dark:border-white/10 dark:bg-card/70 dark:backdrop-blur-xl",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="src/components/ui/slider.tsx">
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }
</file>

<file path="src/components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</file>

<file path="src/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import { motion, LayoutGroup } from "motion/react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

// 1. Create a context to hold the active tab's value
const TabsContext = React.createContext<{
  activeTab: string
}>({
  activeTab: "",
})

// 2. Tabs component provides the active tab value to context
const Tabs = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Root>
>(({ value, ...props }, ref) => (
  <TabsPrimitive.Root ref={ref} value={value} {...props}>
    <TabsContext.Provider value={{ activeTab: value || "" }}>
      {props.children}
    </TabsContext.Provider>
  </TabsPrimitive.Root>
))
Tabs.displayName = TabsPrimitive.Root.displayName

// 3. TabsList wraps children in LayoutGroup for shared layout animations
const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, children, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "relative inline-flex h-12 items-center justify-center rounded-full bg-muted p-0",
      className
    )}
    {...props}
  >
    <LayoutGroup id={React.useId()}>{children}</LayoutGroup>
  </TabsPrimitive.List>
))
TabsList.displayName = TabsPrimitive.List.displayName

// 4. TabsTrigger uses context to determine if it's active and renders the indicator
const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, children, value, ...props }, ref) => {
  const { activeTab } = React.useContext(TabsContext)
  const isActive = activeTab === value

  return (
    <TabsPrimitive.Trigger
      ref={ref}
      value={value}
      className={cn(
        "relative inline-flex items-center justify-center whitespace-nowrap rounded-full px-6 py-2.5 text-base font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
        isActive
          ? "text-primary-foreground"
          : "text-muted-foreground hover:text-foreground",
        className
      )}
      {...props}
    >
      <span className="relative z-10">{children}</span>
      {isActive && (
        <motion.div
          layoutId="active-tab-indicator"
          className="absolute inset-0 z-0 rounded-full bg-primary"
          transition={{ type: "spring", stiffness: 400, damping: 30 }}
        />
      )}
    </TabsPrimitive.Trigger>
  )
})
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      "data-[state=inactive]:hidden",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from 'react';

import {cn} from '@/lib/utils';

const Textarea = React.forwardRef<HTMLTextAreaElement, React.ComponentProps<'textarea'>>(
  ({className, ...props}, ref) => {
    return (
      <textarea
        className={cn(
          'flex min-h-[80px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm dark:bg-card/50 dark:border-white/10 dark:placeholder:text-muted-foreground/60',
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Textarea.displayName = 'Textarea';

export {Textarea};
</file>

<file path="src/components/ui/ThemeToggleImproved.tsx">
"use client";

import React, { useState, useEffect } from 'react';
import { Moon, Sun, Monitor, Check, ChevronDown, Settings } from 'lucide-react';
import { useTheme } from '@/contexts/ThemeContext';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
} from '@/components/ui/dropdown-menu';
import { cn } from '@/lib/utils';

interface ThemeToggleProps {
  variant?: 'icon' | 'button' | 'compact';
  showLabel?: boolean;
}

export function ThemeToggleImproved({ variant = 'button', showLabel = true }: ThemeToggleProps) {
  const { theme, setTheme, isHydrated } = useTheme();
  const [effectiveTheme, setEffectiveTheme] = useState<'light' | 'dark'>('light');

  useEffect(() => {
    if (typeof window === 'undefined') return;

    if (theme === 'system') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      setEffectiveTheme(mediaQuery.matches ? 'dark' : 'light');
      const handler = (e: MediaQueryListEvent) => setEffectiveTheme(e.matches ? 'dark' : 'light');
      mediaQuery.addEventListener('change', handler);
      return () => mediaQuery.removeEventListener('change', handler);
    } else {
      setEffectiveTheme(theme);
    }
  }, [theme]);

  const getIcon = () => {
    if (!isHydrated) {
      return <Monitor className="h-4 w-4" />;
    }

    if (theme === 'light') {
      return <Sun className="h-4 w-4" />;
    } else if (theme === 'dark') {
      return <Moon className="h-4 w-4" />;
    } else {
      return <Monitor className="h-4 w-4" />;
    }
  };

  const getThemeLabel = () => {
    if (!isHydrated) return "Theme";
    
    if (theme === 'light') return "Light";
    if (theme === 'dark') return "Dark";
    return "System";
  };

  const themeOptions = [
    { value: 'light', label: 'Light', icon: Sun, description: 'Always use light theme' },
    { value: 'dark', label: 'Dark', icon: Moon, description: 'Always use dark theme' },
    { value: 'system', label: 'System', icon: Monitor, description: 'Use system preference' },
  ] as const;

  // Quick cycle for icon variant
  const cycleTheme = () => {
    if (theme === 'system') {
      setTheme('light');
    } else if (theme === 'light') {
      setTheme('dark');
    } else {
      setTheme('system');
    }
  };

  // Icon-only variant (cycling button)
  if (variant === 'icon') {
    return (
      <Button
        variant="ghost"
        size="icon"
        onClick={cycleTheme}
        className="h-8 w-8 transition-all duration-200 hover:bg-accent/50"
        title={`Current: ${getThemeLabel()}${theme === 'system' ? ` (${effectiveTheme})` : ''}`}
      >
        <span className="transition-transform duration-200 hover:scale-110">
          {getIcon()}
        </span>
      </Button>
    );
  }

  // Compact variant (smaller dropdown)
  if (variant === 'compact') {
    return (
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button
            variant="ghost"
            size="sm"
            className="h-8 w-8 p-0 transition-all duration-200 hover:bg-accent/50"
          >
            <span className="transition-transform duration-200">
              {getIcon()}
            </span>
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end" className="w-32">
          {themeOptions.map((option) => {
            const Icon = option.icon;
            const isSelected = theme === option.value;
            
            return (
              <DropdownMenuItem
                key={option.value}
                onClick={() => setTheme(option.value)}
                className="flex items-center gap-2 cursor-pointer"
              >
                <Icon className="h-4 w-4" />
                <span className="flex-1">{option.label}</span>
                {isSelected && (
                  <Check className="h-3 w-3 text-primary" />
                )}
              </DropdownMenuItem>
            );
          })}
        </DropdownMenuContent>
      </DropdownMenu>
    );
  }

  // Full button variant (default)
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button
          variant="outline"
          size="sm"
          className={cn(
            "transition-all duration-200 hover:bg-accent/50 group",
            showLabel ? "h-8 gap-2" : "h-8 w-8 p-0"
          )}
        >
          <span className="transition-transform duration-200 group-hover:scale-110">
            {getIcon()}
          </span>
          {showLabel && (
            <>
              <span className="text-sm font-medium">
                {getThemeLabel()}
              </span>
              <ChevronDown className="h-3 w-3 transition-transform duration-200 group-data-[state=open]:rotate-180" />
            </>
          )}
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-48">
        <div className="px-2 py-1.5 text-sm font-semibold text-muted-foreground">
          Theme Settings
        </div>
        <DropdownMenuSeparator />
        {themeOptions.map((option) => {
          const Icon = option.icon;
          const isSelected = theme === option.value;
          
          return (
            <DropdownMenuItem
              key={option.value}
              onClick={() => setTheme(option.value)}
              className="flex items-start gap-3 cursor-pointer py-3"
            >
              <Icon className="h-4 w-4 mt-0.5 flex-shrink-0" />
              <div className="flex-1 space-y-1">
                <div className="flex items-center justify-between">
                  <span className="font-medium">{option.label}</span>
                  {isSelected && (
                    <Check className="h-4 w-4 text-primary" />
                  )}
                </div>
                <p className="text-xs text-muted-foreground leading-relaxed">
                  {option.description}
                </p>
                {option.value === 'system' && isHydrated && (
                  <p className="text-xs text-muted-foreground">
                    Currently: <span className="font-medium">{effectiveTheme}</span>
                  </p>
                )}
              </div>
            </DropdownMenuItem>
          );
        })}
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

// Export variants as separate components for convenience
export const ThemeToggleIcon = () => <ThemeToggleImproved variant="icon" />;
export const ThemeToggleCompact = () => <ThemeToggleImproved variant="compact" />;
export const ThemeToggleButton = ({ showLabel = true }: { showLabel?: boolean }) => 
  <ThemeToggleImproved variant="button" showLabel={showLabel} />;
</file>

<file path="src/components/ui/toast.tsx">
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-auto flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}
</file>

<file path="src/components/ui/toaster.tsx">
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}
</file>

<file path="src/components/ui/toggle-group.tsx">
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleGroupVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3",
        sm: "h-9 px-2.5",
        lg: "h-11 px-5",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleGroupVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    {children}
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleGroupVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleGroupVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleGroupVariants>
>({})

export { ToggleGroup, ToggleGroupItem }
</file>

<file path="src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/components/video-parameters.tsx">
// src/components/video-parameters.tsx
"use client";

import React, { useState, useEffect, useCallback } from "react";
import { Button } from "@/components/ui/button";
import {
    Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle
} from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Textarea } from "@/components/ui/textarea";
import { Progress } from "@/components/ui/progress";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Badge } from "@/components/ui/badge";
import { useToast } from "@/hooks/use-toast";
import { uploadToFalStorage } from '@/ai/actions/generate-video.action';
import { useActiveImage } from "@/stores/imageStore";
import { useAuth } from "@/contexts/AuthContext";
import {
    PREDEFINED_PROMPTS, MODEL_MOVEMENT_OPTIONS, FABRIC_MOTION_OPTIONS_VIDEO, // Use FABRIC_MOTION_OPTIONS_VIDEO
    CAMERA_ACTION_OPTIONS, AESTHETIC_VIBE_OPTIONS as AESTHETIC_STYLE_OPTIONS
} from "@/lib/prompt-builder";
import { AlertTriangle, CheckCircle, Download, Info, Loader2, PaletteIcon, Settings2, Shuffle, Video } from "lucide-react";
import { OptionWithPromptSegment } from "@/lib/prompt-builder";
import { usePromptManager } from "@/hooks/usePromptManager";
import { getDisplayableImageUrl } from "@/lib/utils";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import type { HistoryItem } from "@/lib/types";
import { calculateVideoCost, formatPrice, VideoModel, VideoResolution, VideoDuration } from "@/lib/pricing";


// Type for video generation parameters
interface VideoGenerationParams {
  selectedPredefinedPrompt: string;
  modelMovement: string;
  fabricMotion: string;
  cameraAction: string;
  aestheticVibe: string;
}

// Types and constants from video-generation/page.tsx
// interface VideoPromptOption { // Now OptionWithPromptSegment from prompt-builder
//   value: string;
//   displayLabel: string;
//   promptSegment: string;
// }

// interface PredefinedPromptOption { // Now OptionWithPromptSegment from prompt-builder
//   value: string;
//   displayLabel: string;
//   promptText: string;
// }

// --- Options & Constants are now imported from prompt-builder.ts ---

const isVideoServiceAvailable = !!process.env.NEXT_PUBLIC_FAL_KEY; // Or however it's determined globally

// Helper function to convert data URI to Blob
function dataUriToBlob(dataUri: string): Blob {
  const arr = dataUri.split(',');
  const mime = arr[0].match(/:(.*?);/)![1];
  const byteString = atob(arr[1]);
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  return new Blob([ab], { type: mime });
}


interface RenderSelectProps {
  id: string;
  label: string;
  value: string;
  onChange: (value: string) => void;
  options: OptionWithPromptSegment[]; // Use the imported type
  disabled?: boolean;
  placeholder?: string;
  priceData?: { model: VideoModel; duration: VideoDuration; resolution: VideoResolution; };
}

const RenderSelectComponent: React.FC<RenderSelectProps> = ({ 
  id, label, value, onChange, options, disabled, placeholder, priceData 
}) => {
  return (
    <div>
      <Label htmlFor={id} className="text-sm">{label}</Label>
      <Select value={value} onValueChange={onChange} disabled={disabled}>
        <SelectTrigger id={id} className="mt-1 text-sm">
          <SelectValue placeholder={placeholder || `Select ${label.toLowerCase()}`} />
        </SelectTrigger>
        <SelectContent>
          {options.map(option => {
            let priceLabel = '';
            if (priceData) {
              // Dynamically calculate price for this specific option
              const cost = calculateVideoCost(
                priceData.model,
                (id === 'resolution' ? option.value : priceData.resolution) as VideoResolution,
                (id === 'duration' ? option.value : priceData.duration) as VideoDuration
              );
              priceLabel = formatPrice(cost);
            }

            return (
              <TooltipProvider key={option.value}>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <SelectItem value={option.value} className="text-sm">
                      <div className="flex justify-between w-full items-center">
                        <span>{option.displayLabel}</span>
                        {priceLabel && <span className="text-xs text-muted-foreground ml-2">{priceLabel}</span>}
                      </div>
                    </SelectItem>
                  </TooltipTrigger>
                  {priceLabel && (
                    <TooltipContent>
                      <p>Estimated cost: {priceLabel}</p>
                    </TooltipContent>
                  )}
                </Tooltip>
              </TooltipProvider>
            );
          })}
        </SelectContent>
      </Select>
    </div>
  );
};


// Component is now prop-less - gets prepared image from Zustand store
// Props interface for the component
interface VideoParametersProps {
  historyItemToLoad?: HistoryItem | null;
  isLoadingHistory?: boolean;
}

export default function VideoParameters({ 
  historyItemToLoad = null, 
  isLoadingHistory = false 
}: VideoParametersProps) {
  const { toast } = useToast();
  const { user } = useAuth();
  
  // Get prepared image from store instead of props
  const activeImage = useActiveImage();
  const preparedImageUrl = activeImage?.dataUri || null;

  // State for video parameters
  const [videoModel, setVideoModel] = useState<VideoModel>('lite');
  const [resolution, setResolution] = useState<VideoResolution>('480p');
  const [duration, setDuration] = useState<VideoDuration>('5');
  const [seed, setSeed] = useState<string>("-1");
  const [cameraFixed, setCameraFixed] = useState<boolean>(false);
  const [estimatedCost, setEstimatedCost] = useState<number | null>(null);

  // Prompt builder states
  const [selectedPredefinedPrompt, setSelectedPredefinedPrompt] = useState<string>('custom');
  const [modelMovement, setModelMovement] = useState<string>(MODEL_MOVEMENT_OPTIONS[0].value);
  const [fabricMotion, setFabricMotion] = useState<string>(FABRIC_MOTION_OPTIONS_VIDEO[0].value);
  const [cameraAction, setCameraAction] = useState<string>(CAMERA_ACTION_OPTIONS[0].value);
  const [aestheticVibe, setAestheticVibe] = useState<string>(AESTHETIC_STYLE_OPTIONS[0].value);

  // Generation states
  const [isGenerating, setIsGenerating] = useState<boolean>(false);
  const [isUploadingToFal, setIsUploadingToFal] = useState<boolean>(false);
  const [generationError, setGenerationError] = useState<string | null>(null);
  const [generatedVideoUrl, setGeneratedVideoUrl] = useState<string | null>(null);
  const [generatedSeedValue, setGeneratedSeedValue] = useState<number | null>(null);

  // For webhook-based flow
  const [generationTaskId, setGenerationTaskId] = useState<string | null>(null);
  const [historyItemId, setHistoryItemId] = useState<string | null>(null);
  const [loadedHistoryItemId, setLoadedHistoryItemId] = useState<string | null>(null);
  const [progressValue, setProgressValue] = useState(0);

  // Check if data URI is provided (not a server URL)
  const isDataUri = preparedImageUrl?.startsWith('data:') || false;
  const commonFormDisabled = isGenerating || isUploadingToFal || !isVideoServiceAvailable || !preparedImageUrl;

  const currentVideoGenParams = React.useMemo((): VideoGenerationParams => ({
    selectedPredefinedPrompt,
    modelMovement,
    fabricMotion, // Ensure this is the video-specific one from prompt-builder if names differ
    cameraAction,
    aestheticVibe,
  }), [selectedPredefinedPrompt, modelMovement, fabricMotion, cameraAction, aestheticVibe]);

  const {
    currentPrompt,
    isPromptManuallyEdited,
    handlePromptChange,
    resetPromptToAuto,
    isManualPromptOutOfSync,
  } = usePromptManager({
    generationType: 'video',
    generationParams: currentVideoGenParams,
  });

  // Effect to calculate and update the estimated cost
  useEffect(() => {
    const cost = calculateVideoCost(videoModel, resolution, duration);
    setEstimatedCost(cost);
  }, [videoModel, resolution, duration]);

  // Dynamic resolution options based on the selected model
  const resolutionOptions = React.useMemo(() => {
    if (videoModel === 'pro') {
      return [
        { value: '480p', displayLabel: '480p (Faster)', promptSegment: '' },
        { value: '1080p', displayLabel: '1080p (Higher Quality)', promptSegment: '' },
      ];
    }
    // Default to 'lite' model resolutions
    return [
      { value: '480p', displayLabel: '480p (Faster)', promptSegment: '' },
      { value: '720p', displayLabel: '720p (Higher Quality)', promptSegment: '' },
    ];
  }, [videoModel]);

  // Effect to reset resolution if it becomes invalid after a model change
  useEffect(() => {
    if (!resolutionOptions.some(opt => opt.value === resolution)) {
      setResolution('480p');
    }
  }, [videoModel, resolution, resolutionOptions]);

  // Effect to populate state when a history item with video parameters is loaded
  useEffect(() => {
    if (historyItemToLoad && !isLoadingHistory && historyItemToLoad.videoGenerationParams && historyItemToLoad.id !== loadedHistoryItemId) {
      const { videoGenerationParams } = historyItemToLoad;
      
      // Set video-specific parameters if they exist
      if (videoGenerationParams.prompt) {
        handlePromptChange(videoGenerationParams.prompt);
      }
      if (videoGenerationParams.videoModel) {
        setVideoModel(videoGenerationParams.videoModel);
      }
      if (videoGenerationParams.resolution) {
        setResolution(videoGenerationParams.resolution as '480p' | '720p' | '1080p');
      }
      if (videoGenerationParams.duration) {
        setDuration(videoGenerationParams.duration as '5' | '10');
      }
      if (videoGenerationParams.seed !== undefined) {
        setSeed(videoGenerationParams.seed.toString());
      }
      if (videoGenerationParams.cameraFixed !== undefined) {
        setCameraFixed(videoGenerationParams.cameraFixed);
      }
      if (videoGenerationParams.modelMovement) {
        setModelMovement(videoGenerationParams.modelMovement);
      }
      if (videoGenerationParams.fabricMotion) {
        setFabricMotion(videoGenerationParams.fabricMotion);
      }
      if (videoGenerationParams.cameraAction) {
        setCameraAction(videoGenerationParams.cameraAction);
      }
      if (videoGenerationParams.aestheticVibe) {
        setAestheticVibe(videoGenerationParams.aestheticVibe);
      }
      
      // Mark this history item as loaded to prevent reloading
      setLoadedHistoryItemId(historyItemToLoad.id);
      
      toast({
        title: "History Restored",
        description: "Source image and all video parameters have been successfully restored.",
      });
    }
  }, [historyItemToLoad, isLoadingHistory, loadedHistoryItemId, handlePromptChange, toast]);

  const handleRandomSeed = () => setSeed("-1");

  const handleGenerateVideo = async () => {
    if (!preparedImageUrl) {
      toast({ title: "Image Not Prepared", description: "Please prepare an image in the previous step.", variant: "destructive" });
      return;
    }
    if (!currentPrompt.trim()) {
      toast({ title: "Missing Prompt", description: "Prompt is empty. Please select options or modify it.", variant: "destructive" });
      return;
    }
    if (!user?.username) {
        toast({ title: "Authentication Error", description: "Could not determine current user. Please log in again.", variant: "destructive" });
        return;
    }

    setIsGenerating(true);
    setGenerationError(null);
    setGeneratedVideoUrl(null);
    setGeneratedSeedValue(null);
    setGenerationTaskId(null);
    setHistoryItemId(null);

    try {
      let imageUrlForVideo = preparedImageUrl;

      // If we have a data URI, convert it to a Fal storage URL
      if (isDataUri) {
        setIsUploadingToFal(true);
        // Use a single toast and update it after upload
        const { update, dismiss, id: toastId } = toast({ 
          title: "Uploading Image...", 
          description: "Preparing your image for video generation." 
        });
        try {
          // Convert data URI to Blob
          const imageBlob = dataUriToBlob(preparedImageUrl);
          const imageFile = new File([imageBlob], "prepared-image.jpg", { type: "image/jpeg" });
          // Upload to Fal storage
          imageUrlForVideo = await uploadToFalStorage(imageFile, user.username);
          update({ id: toastId, title: "Image Uploaded!", description: "Starting video generation..." });
        } catch (uploadError) {
          console.error("Error uploading to Fal storage:", uploadError);
          update({ id: toastId, title: "Upload Failed", description: "Failed to upload image to Fal.ai storage.", variant: "destructive" });
          setIsGenerating(false);
          setIsUploadingToFal(false);
          return;
        } finally {
          setIsUploadingToFal(false);
        }
      }

      const videoInput = {
        prompt: currentPrompt,
        image_url: imageUrlForVideo,
        videoModel,
        resolution,
        duration,
        seed: seed === "-1" ? -1 : parseInt(seed),
        camera_fixed: cameraFixed,
        selectedPredefinedPrompt,
        modelMovement,
        fabricMotion,
        cameraAction,
        aestheticVibe,
      };

      const response = await fetch('/api/video/start', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(videoInput),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: `Failed to start generation: ${response.statusText}` }));
        throw new Error(errorData.error || `Failed to start generation: ${response.statusText}`);
      }

      const { taskId, historyItemId: hId } = await response.json();
      setGenerationTaskId(taskId);
      setHistoryItemId(hId);

      toast({
        title: "Video Generation Started",
        description: "Processing in background. Result will appear here and in history.",
        duration: 5000
      });

    } catch (error) {
      console.error('Error initiating video generation:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error.';
      setGenerationError(errorMessage);
      toast({ title: "Generation Error", description: errorMessage, variant: "destructive" });
      setIsGenerating(false); // Set to false only on error
    }
  };

  const handleCancelGeneration = useCallback(() => {
    setIsGenerating(false);
    setGenerationTaskId(null);
    setHistoryItemId(null);
    // TODO: If there's a way to cancel on the backend via taskId, implement here
    toast({ title: "Generation Cancelled", description: "Video generation stopped by user." });
  }, [toast]);


  // Efficient video status polling using dedicated endpoint
  useEffect(() => {
    if (!historyItemId || !isGenerating) return;

    let isCancelled = false;
    const poll = async () => {
      if (isCancelled) return;

      try {
        // Call the new, specific endpoint
        const response = await fetch(`/api/history/${historyItemId}/status`, { cache: 'no-store' });

        if (!response.ok) {
          // Stop polling on server errors like 404 or 500
          console.error(`Status check failed: ${response.status}`);
          setGenerationError(`Status check failed: ${response.statusText}`);
          setIsGenerating(false);
          return;
        }

        const data: import('@/services/database.service').VideoStatusPayload = await response.json();

        if (data.status === 'completed') {
          setGeneratedVideoUrl(data.videoUrl || null);
          setGeneratedSeedValue(data.seed || null);
          setIsGenerating(false);
          toast({ title: "Video Generated!", description: "Video is ready." });
        } else if (data.status === 'failed') {
          setGenerationError(data.error || 'Video generation failed');
          setIsGenerating(false);
          toast({ title: "Generation Failed", description: data.error || 'An unknown error occurred.', variant: "destructive" });
        } else {
          // Still processing, schedule the next poll
          setTimeout(poll, 5000); 
        }

      } catch (error) {
        console.error("Error checking video status:", error);
        // Don't stop polling on network errors, just try again
        setTimeout(poll, 5000);
      }
    };

    // Start the first poll
    poll();

    // Safety timeout
    const timeout = setTimeout(() => {
      if (isGenerating) {
          isCancelled = true;
          setIsGenerating(false);
          toast({ title: "Generation Timed Out", description: "Taking too long. Check history later." });
      }
    }, 10 * 60 * 1000); // 10 min timeout

    return () => {
      isCancelled = true;
      clearTimeout(timeout);
    };
  }, [historyItemId, isGenerating, toast]);

  // Effect to simulate progress during generation
  useEffect(() => {
    let progressInterval: NodeJS.Timeout | undefined;
    if (isGenerating && !generatedVideoUrl) {
      setProgressValue(10); // Start with a small amount
      progressInterval = setInterval(() => {
        setProgressValue(prev => {
          if (prev >= 95) { // Cap progress before completion
            clearInterval(progressInterval);
            return 95;
          }
          return prev + Math.floor(Math.random() * 3) + 1; // Increment slowly and randomly
        });
      }, 800);
    } else {
      setProgressValue(0);
    }
    return () => clearInterval(progressInterval);
  }, [isGenerating, generatedVideoUrl]);


  return (
    <div className="space-y-6">
      <Card variant="glass">
        <CardHeader className="flex flex-row items-start justify-between">
          <div>
            <CardTitle className="text-xl flex items-center gap-2">
              <PaletteIcon className="h-6 w-6 text-primary" />
              Animation & Style
            </CardTitle>
            <CardDescription className="hidden lg:block">Define the video&apos;s motion and aesthetic.</CardDescription>
          </div>
        </CardHeader>
        <CardContent className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {!preparedImageUrl && (
            <Alert className="md:col-span-2">
              <Info className="h-4 w-4" />
              <AlertTitle>Image Required</AlertTitle>
              <AlertDescription>
                Please prepare an image in the previous step to enable video generation.
              </AlertDescription>
            </Alert>
          )}

          <div className="md:col-span-2">
            <RenderSelectComponent
              id="predefined-animation"
              label="Predefined Animation"
              value={selectedPredefinedPrompt} onChange={setSelectedPredefinedPrompt}
              options={PREDEFINED_PROMPTS}
              disabled={commonFormDisabled}
            />
          </div>
          <RenderSelectComponent id="model-movement" label="Model Movement" value={modelMovement} onChange={setModelMovement} options={MODEL_MOVEMENT_OPTIONS} disabled={commonFormDisabled || selectedPredefinedPrompt !== 'custom'} />
          <RenderSelectComponent id="fabric-motion" label="Fabric Motion" value={fabricMotion} onChange={setFabricMotion} options={FABRIC_MOTION_OPTIONS_VIDEO} disabled={commonFormDisabled || selectedPredefinedPrompt !== 'custom'} />
          <RenderSelectComponent id="camera-action" label="Camera Action" value={cameraAction} onChange={setCameraAction} options={CAMERA_ACTION_OPTIONS} disabled={commonFormDisabled || selectedPredefinedPrompt !== 'custom'} />
          <RenderSelectComponent id="aesthetic-vibe" label="Aesthetic Vibe" value={aestheticVibe} onChange={setAestheticVibe} options={AESTHETIC_STYLE_OPTIONS} disabled={commonFormDisabled || selectedPredefinedPrompt !== 'custom'} />

          {/* Camera Position Control - moved here from Technical Parameters */}
          <div className="md:col-span-2 pt-2 border-t">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                <Switch 
                  id="cameraFixed" 
                  checked={cameraFixed} 
                  onCheckedChange={setCameraFixed} 
                  disabled={commonFormDisabled} 
                />
                <Label htmlFor="cameraFixed" className="text-sm cursor-pointer">
                  Fix Camera Position
                </Label>
              </div>
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="ghost" size="sm" className="h-auto p-1 text-muted-foreground">
                      <Info className="h-4 w-4" />
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent>
                    <p className="max-w-xs">
                      When enabled, prevents camera movement and keeps the shot static, 
                      focusing only on model and fabric motion.
                    </p>
                  </TooltipContent>
                </Tooltip>
              </TooltipProvider>
            </div>
          </div>

          <div className="md:col-span-2 pt-2 space-y-2">
            <div className="flex justify-between items-center">
              <Label htmlFor="fullVideoPrompt" className="text-sm">Full Prompt</Label>
              {isManualPromptOutOfSync() && (
                <Button variant="link" size="sm" onClick={resetPromptToAuto} className="text-xs text-amber-600 hover:text-amber-700 p-0 h-auto">
                  <AlertTriangle className="h-3 w-3 mr-1" /> Settings changed. Reset prompt?
                </Button>
              )}
            </div>
            <Textarea
              id="fullVideoPrompt"
              value={currentPrompt}
              onChange={(e) => handlePromptChange(e.target.value)}
              rows={3}
              className="text-xs font-mono"
              placeholder="Prompt will be generated here based on your selections, or you can type your own."
              disabled={commonFormDisabled}
            />
          </div>
        </CardContent>
      </Card>
      <Card variant="glass">
        <CardHeader>
          <CardTitle className="text-xl flex items-center gap-2">
            <Settings2 className="h-6 w-6 text-primary" />
            Technical Parameters
          </CardTitle>
          <CardDescription className="hidden lg:block">Configure resolution, duration, and other technical settings.</CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <RenderSelectComponent
              id="video-model"
              label="Video Model"
              value={videoModel}
              onChange={(v) => setVideoModel(v as VideoModel)}
              options={[
                { value: 'lite', displayLabel: 'Seedance Lite (Default)', promptSegment: '' },
                { value: 'pro', displayLabel: 'Seedance Pro (Higher Quality)', promptSegment: '' },
              ]}
              disabled={commonFormDisabled}
            />
            <RenderSelectComponent
              id="resolution"
              label="Resolution"
              value={resolution}
              onChange={(v) => setResolution(v as VideoResolution)}
              options={resolutionOptions}
              disabled={commonFormDisabled}
              priceData={{ model: videoModel, resolution, duration }}
            />
            <RenderSelectComponent
              id="duration"
              label="Duration"
              value={duration}
              onChange={(v) => setDuration(v as VideoDuration)}
              options={[
                { value: '5', displayLabel: '5 seconds', promptSegment: '' },
                { value: '10', displayLabel: '10 seconds', promptSegment: '' }
              ]}
              disabled={commonFormDisabled}
              priceData={{ model: videoModel, resolution, duration }}
            />
            <div>
              <Label htmlFor="seed" className="text-sm">Seed</Label>
              <div className="flex items-center gap-2 mt-1">
                <Input id="seed" type="text" value={seed} onChange={(e) => setSeed(e.target.value)} placeholder="-1 for random" disabled={commonFormDisabled} className="text-sm"/>
                <Button variant="outline" size="icon" onClick={handleRandomSeed} disabled={commonFormDisabled} title="Use Random Seed"><Shuffle className="h-4 w-4" /></Button>
              </div>
            </div>
          </div>
          {/* Removed camera position switch from here */}
        </CardContent>
        <CardFooter>
          <Button
            variant="gradient"
            onClick={handleGenerateVideo}
            disabled={commonFormDisabled || isGenerating || !currentPrompt.trim()}
            className="w-full text-lg hover:animate-shimmer"
            size="lg"
          >
            {isGenerating ? (
              <>
                <Loader2 className="mr-2 h-5 w-5 animate-spin" />
                Generating...
              </>
            ) : (
              <div className="flex items-center justify-center w-full">
                <Video className="mr-2 h-5 w-5" />
                <span>Generate Video</span>
                {estimatedCost !== null && !isGenerating && (
                  <Badge variant="secondary" className="ml-auto text-base">
                    {formatPrice(estimatedCost)}
                  </Badge>
                )}
              </div>
            )}
          </Button>
        </CardFooter>
      </Card>
      {!isVideoServiceAvailable && (
        <Card variant="glass" className="border-amber-500 bg-amber-50 text-amber-700">
          <CardHeader><CardTitle className="flex items-center gap-2"><AlertTriangle /> Service Not Available</CardTitle></CardHeader>
          <CardContent><p>Video generation service is not configured.</p></CardContent>
        </Card>
      )}
      {generationError && (
        <Card variant="glass" className="border-destructive bg-destructive/10 text-destructive">
          <CardHeader><CardTitle className="flex items-center gap-2"><AlertTriangle /> Generation Failed</CardTitle></CardHeader>
          <CardContent><p>{generationError}</p></CardContent>
        </Card>
      )}
      {isGenerating && !generatedVideoUrl && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Loader2 className="h-6 w-6 text-primary animate-spin" />
              {isUploadingToFal ? "Uploading Image..." : "Generating Video..."}
            </CardTitle>
            <CardDescription>
              Your video is being processed. This may take a minute. Please wait.
            </CardDescription>
          </CardHeader>
          <CardContent className="flex justify-center items-center py-10">
            <div className="w-full max-w-md space-y-4">
              <div className="aspect-video bg-muted/50 rounded-md flex items-center justify-center relative overflow-hidden">
                <Video className="h-16 w-16 text-muted-foreground/50" />
              </div>
              <Progress 
                value={progressValue}
                isEstimating={true}
                className="h-2"
              />
            </div>
          </CardContent>
          <CardFooter>
            <Button
              variant="ghost"
              size="sm"
              onClick={handleCancelGeneration}
              className="w-full text-muted-foreground hover:text-destructive"
            >
              Cancel Generation
            </Button>
          </CardFooter>
        </Card>
      )}
      {generatedVideoUrl && !isGenerating && ( // Ensure isGenerating is false to show result
        (<Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2 text-green-600"><CheckCircle /> Video Ready!</CardTitle>
            {generatedSeedValue !== null && (<CardDescription>Seed used: {generatedSeedValue}</CardDescription>)}
          </CardHeader>
          <CardContent className="space-y-3">
            <div className="bg-muted rounded-md overflow-hidden w-full aspect-video">
              <video src={getDisplayableImageUrl(generatedVideoUrl) || undefined} controls autoPlay loop playsInline className="w-full h-full object-contain" />
            </div>
            <Button asChild variant="outline" className="w-full">
              <a href={getDisplayableImageUrl(generatedVideoUrl) || undefined} download={`RefashionAI_video_${generatedSeedValue || Date.now()}.mp4`}><Download className="h-4 w-4 mr-2" />Download Video</a>
            </Button>
          </CardContent>
        </Card>)
      )}
    </div>
  );
}
</file>

<file path="src/components/VideoHistoryCard.tsx">
"use client";

import React, { useState, useRef, useEffect } from 'react';
import Image from 'next/image';
import type { HistoryItem } from '@/lib/types';
import { Card, CardContent, CardFooter } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Eye, PlayCircle, Clock, AlertCircle, CheckCircle } from 'lucide-react';
import { getDisplayableImageUrl } from '@/lib/utils';
import { VideoPlaybackModal } from '@/components/VideoPlaybackModal';
import { motion, AnimatePresence } from 'motion/react';

interface VideoHistoryCardProps {
  item: HistoryItem;
}

export function VideoHistoryCard({ item }: VideoHistoryCardProps) {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const cardRef = useRef<HTMLDivElement>(null);
  const thumbnailUrl = getDisplayableImageUrl(
    item.videoGenerationParams?.sourceImageUrl || item.originalClothingUrl || ''
  );
  const videoUrl = getDisplayableImageUrl(item.generatedVideoUrls?.[0] || '');
  const status = (item.videoGenerationParams as any)?.status;
  const error = (item.videoGenerationParams as any)?.error;

  // IntersectionObserver for autoplay-in-view
  useEffect(() => {
    const currentCard = cardRef.current;
    if (!currentCard || !videoUrl) return;

    const observer = new IntersectionObserver(
      (entries) => {
        const entry = entries[0];
        setIsInView(entry.isIntersecting);
      },
      {
        root: null, // viewport
        rootMargin: '0px',
        threshold: 0.5, // Play when 50% of the card is visible
      }
    );

    observer.observe(currentCard);

    return () => {
      observer.unobserve(currentCard);
    };
  }, [videoUrl]);

  // Handle video play/pause based on visibility
  useEffect(() => {
    const video = videoRef.current;
    if (!video || !videoUrl) return;

    if (isInView) {
      video.play().catch(error => { if (error.name !== 'AbortError') console.error("Video play failed:", error); });
    } else {
      video.pause();
    }
  }, [isInView, videoUrl]);

  const getStatusIcon = () => {
    switch (status) {
      case 'processing':
        return <Clock className="h-4 w-4 text-blue-500 animate-pulse" />;
      case 'failed':
        return <AlertCircle className="h-4 w-4 text-red-500" />;
      case 'completed':
        return videoUrl ? <CheckCircle className="h-4 w-4 text-green-500" /> : null;
      default:
        return null;
    }
  };

  const getStatusText = () => {
    switch (status) {
      case 'processing':
        return 'Processing...';
      case 'failed':
        return error || 'Generation failed';
      case 'completed':
        return videoUrl ? 'Ready' : 'Completed';
      default:
        return '';
    }
  };

  const canPlayVideo = status === 'completed' && videoUrl;

  return (
    <motion.div layout>
      <Card
        ref={cardRef}
        className="overflow-hidden group transition-all hover:shadow-lg hover:border-primary/50 cursor-pointer"
        onClick={() => canPlayVideo && setIsModalOpen(true)}
      >
        <CardContent className="p-0">
          <motion.div
            layoutId={`video-card-${item.id}`}
            className="relative aspect-[9/16] w-full bg-muted"
          >
            {thumbnailUrl && (
              <Image
                src={thumbnailUrl}
                alt="Video thumbnail"
                fill
                className={`object-cover transition-opacity duration-300 ${isInView ? 'opacity-0' : 'opacity-100'}`}
              />
            )}
            {videoUrl && (
              <video
                ref={videoRef}
                src={videoUrl}
                loop
                muted
                playsInline
                preload="metadata"
                className={`w-full h-full object-cover absolute inset-0 transition-opacity duration-300 ${isInView ? 'opacity-100' : 'opacity-0'}`}
              />
            )}
            {/* Status overlay */}
            {status && (
              <div className="absolute top-2 right-2 bg-black/70 rounded-full p-1.5">
                {getStatusIcon()}
              </div>
            )}
            {/* Play button overlay - only show for completed videos */}
            {!isInView && canPlayVideo && (
              <div className="absolute inset-0 bg-black/20 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                <PlayCircle className="h-16 w-16 text-white/80" />
              </div>
            )}
            {/* Processing overlay for incomplete videos */}
            {status === 'processing' && (
              <div className="absolute inset-0 bg-black/40 flex items-center justify-center">
                <div className="text-white text-center">
                  <Clock className="h-8 w-8 mx-auto mb-2 animate-pulse" />
                  <p className="text-sm">Processing...</p>
                </div>
              </div>
            )}
            {/* Error overlay */}
            {status === 'failed' && (
              <div className="absolute inset-0 bg-black/40 flex items-center justify-center">
                <div className="text-white text-center p-4">
                  <AlertCircle className="h-8 w-8 mx-auto mb-2 text-red-400" />
                  <p className="text-sm">Generation Failed</p>
                  {error && <p className="text-xs mt-1 opacity-80">{error}</p>}
                </div>
              </div>
            )}
          </motion.div>
        </CardContent>
        <CardFooter className="p-3 bg-card-foreground/5 flex-col items-start">
          <div className="flex items-center gap-2 w-full">
            <p className="text-sm font-medium truncate flex-1" title={item.constructedPrompt}>
              {item.constructedPrompt}
            </p>
            {status && (
              <div className="flex items-center gap-1 text-xs">
                {getStatusIcon()}
                <span className={`
                  ${status === 'processing' ? 'text-blue-600' : ''}
                  ${status === 'failed' ? 'text-red-600' : ''}
                  ${status === 'completed' ? 'text-green-600' : ''}
                `}>
                  {getStatusText()}
                </span>
              </div>
            )}
          </div>
          <p className="text-xs text-muted-foreground">
            {new Date(item.timestamp).toLocaleDateString()}
          </p>
        </CardFooter>
      </Card>
      <AnimatePresence>
        {isModalOpen && (
          <VideoPlaybackModal item={item} onClose={() => setIsModalOpen(false)} />
        )}
      </AnimatePresence>
    </motion.div>
  );
}
</file>

<file path="src/components/VideoPlaybackModal.tsx">
"use client";

import React from 'react';
import type { HistoryItem } from '@/lib/types';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Download, Copy, X } from 'lucide-react';
import { getDisplayableImageUrl } from '@/lib/utils';
import { useToast } from '@/hooks/use-toast';
import { motion } from 'motion/react';

interface VideoPlaybackModalProps {
  item: HistoryItem;
  onClose: () => void;
}

export function VideoPlaybackModal({ item, onClose }: VideoPlaybackModalProps) {
  const { toast } = useToast();
  const videoUrl = getDisplayableImageUrl(item.generatedVideoUrls?.[0] || '');

  const handleCopy = (text: string) => {
    navigator.clipboard.writeText(text);
    toast({ title: 'Copied!', description: 'Prompt has been copied to clipboard.' });
  };

  return (
    <Dialog open={true} onOpenChange={onClose}>
      <DialogContent className="h-screen w-screen max-w-full sm:h-auto sm:max-w-6xl sm:max-h-[90vh] flex flex-col rounded-none sm:rounded-lg glass-card p-0">
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.95 }}
          transition={{ duration: 0.3, ease: "easeInOut" }}
          className="flex flex-col h-full"
        >
          <DialogHeader className="p-6 pb-2">
            <DialogTitle>Video Details</DialogTitle>
            <DialogDescription>
              Playback and details for your generated video from {new Date(item.timestamp).toLocaleString()}.
            </DialogDescription>
          </DialogHeader>

          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 flex-1 min-h-0 px-6 py-4">
            <motion.div
              initial={{ opacity: 0, scale: 0.97 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.97 }}
              transition={{ duration: 0.3, ease: 'easeInOut' }}
              className="lg:col-span-2 bg-black rounded-lg overflow-hidden flex items-center justify-center min-h-[400px] max-h-[70vh]"
              layoutId={`video-card-${item.id}`}
            >
              {videoUrl ? (
                <video 
                  src={videoUrl} 
                  controls 
                  autoPlay 
                  loop 
                  className="w-full h-full object-contain"
                >
                  Your browser does not support the video tag.
                </video>
              ) : (
                <p className="text-white">Video not available.</p>
              )}
            </motion.div>
            <ScrollArea className="h-full">
              <div className="space-y-4 pr-4">
                <div>
                  <h4 className="font-semibold mb-1">Full Prompt</h4>
                  <div className="relative">
                    <p className="text-xs text-muted-foreground bg-muted/50 p-3 rounded-md pr-10">
                      {item.videoGenerationParams?.prompt || item.constructedPrompt}
                    </p>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="absolute top-1 right-1 h-7 w-7"
                      onClick={() => handleCopy(item.videoGenerationParams?.prompt || item.constructedPrompt)}
                    >
                      <Copy className="h-3.5 w-3.5" />
                    </Button>
                  </div>
                </div>

                <div>
                  <h4 className="font-semibold mb-2">Parameters</h4>
                  <div className="text-xs space-y-1 text-muted-foreground">
                    <p><strong>Seed:</strong> {item.videoGenerationParams?.seed}</p>
                    <p><strong>Resolution:</strong> {item.videoGenerationParams?.resolution}</p>
                    <p><strong>Duration:</strong> {item.videoGenerationParams?.duration}s</p>
                    <p><strong>Fixed Camera:</strong> {item.videoGenerationParams?.cameraFixed ? 'Yes' : 'No'}</p>
                    {item.videoGenerationParams?.modelMovement && (
                      <p><strong>Model Movement:</strong> {item.videoGenerationParams.modelMovement}</p>
                    )}
                    {item.videoGenerationParams?.fabricMotion && (
                      <p><strong>Fabric Motion:</strong> {item.videoGenerationParams.fabricMotion}</p>
                    )}
                    {item.videoGenerationParams?.cameraAction && (
                      <p><strong>Camera Action:</strong> {item.videoGenerationParams.cameraAction}</p>
                    )}
                    {item.videoGenerationParams?.aestheticVibe && (
                      <p><strong>Aesthetic Vibe:</strong> {item.videoGenerationParams.aestheticVibe}</p>
                    )}
                  </div>
                </div>
              </div>
            </ScrollArea>
          </div>

          <DialogFooter className="mt-auto p-6 border-t border-border/20">
            <Button variant="outline" onClick={onClose}>
              <X className="mr-2 h-4 w-4" /> Close
            </Button>
            <a href={videoUrl || '#'} download={`RefashionAI_video_${item.id}.mp4`}>
              <Button disabled={!videoUrl}>
                <Download className="h-4 w-4 sm:mr-2" /> 
                <span className="hidden sm:inline">Download</span>
              </Button>
            </a>
          </DialogFooter>
        </motion.div>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/contexts/AuthContext.tsx">
// src/contexts/AuthContext.tsx
"use client";

import type ReactType from 'react';
import { createContext, useContext, useEffect, useState, useCallback, type ReactNode } from 'react';
import { Button } from '@/components/ui/button';
import { getCurrentUser, logoutUser } from '@/actions/authActions';
import type { SessionUser } from '@/lib/types';

interface AuthContextType {
  user: SessionUser | null;
  loading: boolean; // Represents loading for explicit refreshes, not initial load if initialUser is provided
  refreshUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

// Define props for AuthProvider
interface AuthProviderProps {
  children: ReactNode;
  initialUser: SessionUser | null; // Prop to pass initial user state
}

export const AuthProvider = ({ children, initialUser }: AuthProviderProps) => {
  // Initialize user state with the server-provided initialUser
  const [user, setUser] = useState<SessionUser | null>(initialUser);

  // 2. The only "loading" state is for manual refreshes, not initial load.
  const [loading, setLoading] = useState(false);

  // 3. This effect is now only for syncing with layout re-renders, not for fetching.
  useEffect(() => {
    setUser(initialUser);
  }, [initialUser]);

  // The refreshUser function remains to allow explicit session re-fetching.
  const refreshUser = useCallback(async () => {
    setLoading(true);
    try {
      const currentUserData = await getCurrentUser();
      setUser(currentUserData);
    } catch (error) {
      console.error("Failed to refresh user session", error);
      setUser(null);
    } finally {
      setLoading(false);
    }
  }, []);

  const value = { user, loading, refreshUser };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

// UserAuthStatus component remains largely the same but benefits from faster initial user state
export const UserAuthStatus = () => {
  const { user, loading: authContextLoading } = useAuth(); // Renamed loading to avoid conflict
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);
  // Show loading if AuthContext is loading (e.g. during a refresh) OR if not yet client-side rendered
  if (authContextLoading || !isClient) {
    return (
      <div className="flex items-center space-x-2">
        <div className="h-4 w-4 animate-spin rounded-full border-2 border-primary border-t-transparent" />
        <span className="text-sm text-muted-foreground">Loading...</span>
      </div>
    );
  }

  if (user?.isLoggedIn) {
    return (
      <div className="flex items-center space-x-3">
        <div className="flex items-center space-x-2">
          <div className="h-8 w-8 rounded-full bg-gradient-to-r from-blue-500 to-purple-600 flex items-center justify-center text-white text-sm font-semibold">
            {user.username.charAt(0).toUpperCase()}
          </div>
          <div className="hidden sm:block">
            <p className="text-sm font-medium">{user.username}</p>
            <p className="text-xs text-muted-foreground capitalize">{user.role}</p>
          </div>
        </div>
        <form action={logoutUser}>
          <Button type="submit" variant="ghost" size="sm" className="text-muted-foreground hover:text-foreground">
            Logout
          </Button>
        </form>
      </div>
    );
  }
  
  // If not logged in, show login button
  return (
    <Button asChild variant="default" size="sm">
      <a href="/login">Login</a>
    </Button>
  );
};
</file>

<file path="src/contexts/ThemeContext.tsx">
"use client";

import type React from 'react';
import { createContext, useContext, useState, useEffect } from 'react';

// 1. Define Types
type Theme = 'light' | 'dark' | 'system';

interface ThemeProviderProps {
  children: React.ReactNode;
  defaultTheme?: Theme;
  storageKey?: string;
}

interface ThemeContextType {
  theme: Theme;
  setTheme: (theme: Theme) => void;
  isHydrated: boolean;
}

// 2. Create Context
const initialState: ThemeContextType = {
  theme: 'dark',
  setTheme: () => null,
  isHydrated: false,
};

const ThemeContext = createContext<ThemeContextType>(initialState);

// 3. ThemeProvider Component
export function ThemeProvider({
  children,
  defaultTheme = 'dark',
  storageKey = 'theme',
}: ThemeProviderProps) {
  const [theme, setThemeState] = useState<Theme>(defaultTheme);
  const [isHydrated, setIsHydrated] = useState(false);
  // Effect to mark hydration complete and read from localStorage
  useEffect(() => {
    setIsHydrated(true);
    
    if (typeof window === 'undefined') return;
    
    try {
      const storedTheme = window.localStorage.getItem(storageKey) as Theme | null;
      if (storedTheme && storedTheme !== theme) {
        setThemeState(storedTheme);
      }
    } catch (e) {
      console.warn(`Failed to read theme from localStorage (key: "${storageKey}"):`, e);
    }
  }, [storageKey, theme]);
  // Effect for applying theme and listening to system changes
  useEffect(() => {
    if (typeof window === 'undefined' || !isHydrated) return;

    const root = window.document.documentElement;
    const themeColorMeta = document.querySelector('meta[name="theme-color"]');
    const darkColor = '#020410'; // from globals.css dark theme --background
    const lightColor = '#f9fafb'; // from globals.css light theme --background

    const applyThemePreference = () => {
      // Remove all theme classes first
      root.classList.remove('light', 'dark');
      if (theme === 'system') {
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        if (systemPrefersDark) {
          root.classList.add('dark');
          if (themeColorMeta) themeColorMeta.setAttribute('content', darkColor);
        } else {
          root.classList.add('light');
          if (themeColorMeta) themeColorMeta.setAttribute('content', lightColor);
        }
      } else {
        root.classList.add(theme);
        if (themeColorMeta) {
          themeColorMeta.setAttribute('content', theme === 'dark' ? darkColor : lightColor);
        }
      }
    };

    // Apply theme immediately
    applyThemePreference();

    // Listener for system preference changes if theme is 'system'
    if (theme === 'system') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      mediaQuery.addEventListener('change', applyThemePreference);
      return () => mediaQuery.removeEventListener('change', applyThemePreference);
    }
  }, [theme, isHydrated]); // Re-run when theme changes or hydration completes

  const setTheme = (newTheme: Theme) => {
    if (typeof window !== 'undefined') {
      try {
        // Store the user's explicit choice ('light', 'dark', or 'system')
        window.localStorage.setItem(storageKey, newTheme);
      } catch (e) {
        console.warn(`Failed to save theme to localStorage (key: "${storageKey}"):`, e);
      }
    }
    setThemeState(newTheme);
  };

  return (
    <ThemeContext.Provider value={{ theme, setTheme, isHydrated }}>
      {children}
    </ThemeContext.Provider>
  );
}

// 4. useTheme Hook
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};
</file>

<file path="src/hooks/use-mobile.tsx">
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}
</file>

<file path="src/hooks/use-toast.ts">
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="src/hooks/usePromptManager.ts">
// src/hooks/usePromptManager.ts
import { useState, useEffect, useCallback } from 'react';
import { buildAIPrompt, BaseGenerationParams, ImageDetails } from '@/lib/prompt-builder';

interface UsePromptManagerProps {
  initialPrompt?: string;
  generationType: 'image' | 'video';
  generationParams: BaseGenerationParams;
  imageDetails?: ImageDetails; // Optional, mainly for image type
}

export function usePromptManager({
  initialPrompt = '',
  generationType,
  generationParams,
  imageDetails,
}: UsePromptManagerProps) {
  const [currentPrompt, setCurrentPrompt] = useState<string>(initialPrompt);
  const [isPromptManuallyEdited, setIsPromptManuallyEdited] = useState<boolean>(false);

  const generatePromptFromParams = useCallback(() => {
    return buildAIPrompt({
      type: generationType,
      params: generationParams,
      imageDetails: imageDetails,
    });
  }, [generationType, generationParams, imageDetails]);

  useEffect(() => {
    if (!isPromptManuallyEdited) {
      setCurrentPrompt(generatePromptFromParams());
    }
  }, [isPromptManuallyEdited, generatePromptFromParams]);

  const handlePromptChange = useCallback((newPrompt: string) => {
    setCurrentPrompt(newPrompt);
    setIsPromptManuallyEdited(true);
  }, []);

  const resetPromptToAuto = () => {
    setIsPromptManuallyEdited(false);
    // The useEffect above will trigger a regeneration of the prompt
    // and update currentPrompt if isPromptManuallyEdited was true.
    // If it was already false, explicitly set it to ensure re-render if params changed meanwhile.
    setCurrentPrompt(generatePromptFromParams());
  };

  // This function checks if the current manual prompt is out of sync with what would be auto-generated.
  const isManualPromptOutOfSync = () : boolean => {
    if (!isPromptManuallyEdited) return false;
    return currentPrompt !== generatePromptFromParams();
  }

  return {
    currentPrompt,
    isPromptManuallyEdited,
    handlePromptChange,
    resetPromptToAuto,
    isManualPromptOutOfSync, // Expose this for UI warnings
    // rawAutoGeneratedPrompt: generatePromptFromParams() // Could be exposed for comparison if needed
  };
}
</file>

<file path="src/lib/api-auth.ts">
// src/lib/api-auth.ts
import { NextRequest } from 'next/server';
import { findUserByApiKey } from '@/services/database.service';
import type { SessionUser } from '@/lib/types';

export async function authenticateApiRequest(request: NextRequest): Promise<SessionUser | null> {
  const authHeader = request.headers.get('Authorization');
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return null;
  }
  const apiKey = authHeader.substring(7);
  if (!apiKey) {
    return null;
  }

  const user = findUserByApiKey(apiKey);
  
  if (user) {
    return {
      username: user.username,
      role: user.role as 'admin' | 'user',
      isLoggedIn: true,
    };
  }
  
  return null;
}
</file>

<file path="src/lib/motion-constants.ts">
// Motion constants with optimized easing functions
// Generated using professional motion tools for better UX

export const MOTION_CONFIG = {
  // Spring animations for interactive elements
  springs: {
    // Quick, snappy spring for buttons and small interactions
    quick: '450ms linear(0, 0.2348, 0.6075, 0.8763, 1.0076, 1.0451, 1.0389, 1.0217, 1.0079, 1.0006, 0.9981, 0.9981, 0.9988, 0.9995, 1)',
    
    // Standard spring for cards and medium interactions
    standard: '900ms linear(0, 0.0697, 0.2323, 0.4311, 0.6265, 0.7946, 0.9243, 1.0138, 1.0669, 1.0909, 1.094, 1.0837, 1.0666, 1.0476, 1.0297, 1.0149, 1.0039, 0.9967, 0.9926, 0.9911, 0.9913, 0.9926, 0.9943, 0.9961, 0.9977, 0.999, 0.9999, 1.0005, 1, 1)',
  },
  
  // Bounce animation for special effects
  bounce: {
    // Subtle bounce for upload drop zones and success states
    subtle: '0.6s linear(0, 0.0022, 0.0087, 0.0196, 0.0348, 0.0543, 0.0782, 0.1065, 0.139, 0.176, 0.2173, 0.2629, 0.3128, 0.3672, 0.4258, 0.4888, 0.5562, 0.6279, 0.7039, 0.7843, 0.869, 0.9581, 0.9752, 0.9332, 0.8954, 0.8621, 0.833, 0.8083, 0.788, 0.772, 0.7603, 0.753, 0.7501, 0.7515, 0.7572, 0.7673, 0.7817, 0.8004, 0.8235, 0.851, 0.8828, 0.9189, 0.9594, 0.9979, 0.9772, 0.9608, 0.9487, 0.941, 0.9377, 0.9386, 0.944, 0.9537, 0.9677, 0.986, 0.996, 0.9881, 0.9846, 0.9854, 0.9905, 1)',
  },
  
  // Standard durations for consistency
  durations: {
    fast: '100ms',
    quick: '200ms',
    standard: '300ms',
    slow: '500ms',
  },
  
  // Timing function utilities
  timing: {
    // For opacity and color transitions
    easeOut: 'cubic-bezier(0.16, 1, 0.3, 1)',
    
    // For scale and transform transitions
    easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
    
    // For bounce-like effects without full bounce
    anticipate: 'cubic-bezier(0.68, -0.6, 0.32, 1.6)',
  }
} as const;

// CSS custom properties for easier usage
export const MOTION_CSS_VARS = `
  :root {
    --motion-spring-quick: ${MOTION_CONFIG.springs.quick};
    --motion-spring-standard: ${MOTION_CONFIG.springs.standard};
    --motion-bounce-subtle: ${MOTION_CONFIG.bounce.subtle};
    --motion-duration-fast: ${MOTION_CONFIG.durations.fast};
    --motion-duration-quick: ${MOTION_CONFIG.durations.quick};
    --motion-duration-standard: ${MOTION_CONFIG.durations.standard};
    --motion-duration-slow: ${MOTION_CONFIG.durations.slow};
    --motion-ease-out: ${MOTION_CONFIG.timing.easeOut};
    --motion-ease-in-out: ${MOTION_CONFIG.timing.easeInOut};
    --motion-ease-anticipate: ${MOTION_CONFIG.timing.anticipate};
  }
`;

// React Motion variants for Framer Motion
export const MOTION_VARIANTS = {
  // Page transitions
  page: {
    initial: { opacity: 0, y: 8 },
    animate: { opacity: 1, y: 0 },
    exit: { opacity: 0, y: -8 },
  },
  
  // Card animations
  card: {
    initial: { opacity: 0, scale: 0.95 },
    animate: { opacity: 1, scale: 1 },
    exit: { opacity: 0, scale: 0.95 },
    hover: { scale: 1.02 },
    tap: { scale: 0.98 },
  },
  
  // Image animations
  image: {
    initial: { opacity: 0, scale: 1.1 },
    animate: { opacity: 1, scale: 1 },
    exit: { opacity: 0, scale: 0.9 },
  },
  
  // List item animations
  listItem: {
    initial: { opacity: 0, x: -20 },
    animate: { opacity: 1, x: 0 },
    exit: { opacity: 0, x: 20 },
  },
  
  // Upload zone animations
  uploadZone: {
    initial: { opacity: 0, scale: 0.9 },
    animate: { opacity: 1, scale: 1 },
    dragOver: { scale: 1.05, borderColor: 'hsl(var(--primary))' },
    dragLeave: { scale: 1, borderColor: 'hsl(var(--border))' },
  },
} as const;

// Motion transitions
export const MOTION_TRANSITIONS = {
  // Spring-based transitions
  spring: {
    quick: {
      type: 'spring',
      stiffness: 300,
      damping: 25,
      mass: 0.5,
    },
    standard: {
      type: 'spring',
      stiffness: 200,
      damping: 20,
      mass: 0.8,
    },
    gentle: {
      type: 'spring',
      stiffness: 100,
      damping: 15,
      mass: 1,
    },
  },
  
  // Tween-based transitions
  tween: {
    fast: {
      duration: 0.1,
      ease: [0.16, 1, 0.3, 1],
    },
    quick: {
      duration: 0.2,
      ease: [0.16, 1, 0.3, 1],
    },
    standard: {
      duration: 0.3,
      ease: [0.4, 0, 0.2, 1],
    },
    slow: {
      duration: 0.5,
      ease: [0.4, 0, 0.2, 1],
    },
  },
  
  // Stagger for lists
  stagger: {
    children: 0.1,
    delayChildren: 0.1,
  },
} as const;
</file>

<file path="src/lib/pricing.ts">
// src/lib/pricing.ts

export type VideoModel = 'lite' | 'pro';
export type VideoResolution = '480p' | '720p' | '1080p';
export type VideoDuration = '5' | '10';

// Base prices for a 5-second video
const PRICING_DATA: Record<VideoModel, Partial<Record<VideoResolution, number>>> = {
  lite: {
    '480p': 0.08,
    '720p': 0.18,
  },
  pro: {
    '480p': 0.15,
    '1080p': 0.74,
  },
};

/**
 * Calculates the estimated cost for a video generation.
 * @returns The cost as a number, or null if the combination is invalid.
 */
export function calculateVideoCost(
  model: VideoModel,
  resolution: VideoResolution,
  duration: VideoDuration
): number | null {
  const basePrice = PRICING_DATA[model]?.[resolution];

  if (basePrice === undefined) {
    return null; // Invalid combination (e.g., Lite model with 1080p)
  }

  const durationMultiplier = duration === '10' ? 2 : 1;
  return basePrice * durationMultiplier;
}

/**
 * Formats a price number into a display-friendly string (e.g., "~$0.18").
 * @returns A formatted string or an empty string if the price is null.
 */
export function formatPrice(price: number | null): string {
  if (price === null || price === undefined) {
    return "";
  }
  return `~${price.toLocaleString('en-US', { style: 'currency', currency: 'USD' })}`;
}
</file>

<file path="src/lib/prompt-builder.ts">
// src/lib/prompt-builder.ts

// --- Types ---
export interface OptionWithPromptSegment {
  value: string;
  displayLabel: string;
  promptSegment: string;
  basePrompt?: string; // Only for top-level style options in image generation
}

// Base parameters common to both or specific enough to be optional
export interface BaseGenerationParams {
  // Image specific (can be optional for video)
  gender?: string;
  bodyType?: string;
  bodySize?: string;
  ageRange?: string;
  ethnicity?: string;
  poseStyle?: string;
  background?: string;
  fashionStyle?: string;
  hairStyle?: string;
  modelExpression?: string;
  lightingType?: string;
  lightQuality?: string;
  cameraAngle?: string;
  lensEffect?: string;
  depthOfField?: string;
  timeOfDay?: string; // Also used by image if relevant to background
  overallMood?: string; // Image specific mood
  fabricRendering?: string;

  // Video specific (can be optional for image)
  selectedPredefinedPrompt?: string;
  modelMovement?: string;
  fabricMotion?: string; // Video specific fabric motion
  cameraAction?: string; // Video specific camera action
  aestheticVibe?: string; // Video specific aesthetic

  // Common or generic
  settingsMode?: 'basic' | 'advanced'; // For image prompt construction style
}

export interface ImageDetails {
    width: number;
    height: number;
    // Potentially other details like dominant colors, item type if known
}

interface BuildAIPromptArgs {
  type: 'image' | 'video';
  params: BaseGenerationParams;
  imageDetails?: ImageDetails; // Optional: details about the input image if relevant for prompt
}

// --- Helper Function ---
const getSelectedOption = (options: OptionWithPromptSegment[], value?: string): OptionWithPromptSegment | undefined => {
  if (!value) return undefined;
  return options.find(opt => opt.value === value);
};


// --- OPTION CONSTANTS ---
// Moved from image-parameters.tsx and video-parameters.tsx

// For Image Generation
export const FASHION_STYLE_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default_style", displayLabel: "Default (General Fashion)", basePrompt: "Fashion photograph: A {gender} model, {modelDetails}, {poseStyleDetails} stylishly wearing this clothing item.", promptSegment: "A general, high-quality fashion photograph focusing on accurately depicting the model and clothing." },
  { value: "high_fashion_editorial", displayLabel: "High-Fashion Editorial", basePrompt: "High-fashion editorial photograph: A {gender} model, {modelDetails}, {poseStyleDetails} stylishly wearing this clothing item.", promptSegment: "This image should have strong artistic expression, a conceptual narrative, and dramatic flair typical of high-fashion editorials." },
  { value: "lifestyle_street", displayLabel: "Lifestyle / Street Style", basePrompt: "Street style photograph: A {gender} model, {modelDetails}, captured in a candid moment {poseStyleDetails} stylishly wearing this clothing item.", promptSegment: "Aim for authenticity and a natural, candid feel, showcasing fashion in a real-world urban or everyday environment." },
  { value: "ecommerce_product", displayLabel: "E-commerce / Product Focus", basePrompt: "E-commerce product photograph: The clothing item is clearly showcased on a {gender} model, {modelDetails}, {poseStyleDetails}.", promptSegment: "Focus on clear, appealing depiction of the garment, ensuring accurate representation of color, texture, and fit, usually against a clean background." },
  { value: "creative_conceptual", displayLabel: "Creative / Conceptual", basePrompt: "Conceptual fashion portrait: A {gender} model, {modelDetails}, {poseStyleDetails} stylishly wearing this clothing item, embodying an abstract concept.", promptSegment: "Push creative boundaries with unique visual metaphors, experimental styling, and symbolic imagery." },
];
export const GENDER_OPTIONS: OptionWithPromptSegment[] = [
  { value: "female", displayLabel: "Female", promptSegment: "female" },
  { value: "male", displayLabel: "Male", promptSegment: "male" },
  { value: "non_binary", displayLabel: "Non-binary", promptSegment: "non-binary" },
];
export const AGE_RANGE_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default", promptSegment: "" },
  { value: "early_20s", displayLabel: "Early 20s", promptSegment: "in their early 20s" },
  { value: "late_20s", displayLabel: "Late 20s", promptSegment: "in their late 20s" },
  { value: "mid_30s", displayLabel: "Mid 30s", promptSegment: "in their mid-30s" },
  { value: "mid_40s", displayLabel: "Mid 40s", promptSegment: "in their mid-40s" },
  { value: "50_plus", displayLabel: "50+", promptSegment: "aged 50 or older" },
];
export const ETHNICITY_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default", promptSegment: "" },
  { value: "caucasian", displayLabel: "Caucasian", promptSegment: "of Caucasian ethnicity" },
  { value: "black", displayLabel: "Black", promptSegment: "of Black ethnicity" },
  { value: "east_asian", displayLabel: "East Asian", promptSegment: "of East Asian ethnicity" },
  { value: "south_asian", displayLabel: "South Asian", promptSegment: "of South Asian ethnicity" },
  { value: "hispanic_latino", displayLabel: "Hispanic / Latino/a/x", promptSegment: "of Hispanic or Latino/a/x ethnicity" },
  { value: "middle_eastern", displayLabel: "Middle Eastern", promptSegment: "of Middle Eastern ethnicity" },
  { value: "indigenous", displayLabel: "Indigenous", promptSegment: "of Indigenous ethnicity" },
  { value: "multiracial", displayLabel: "Multiracial", promptSegment: "of multiracial ethnicity" },
];
export const BODY_TYPE_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default", promptSegment: "" },
  { value: "hourglass", displayLabel: "Hourglass", promptSegment: "with an hourglass body type" },
  { value: "athletic", displayLabel: "Athletic", promptSegment: "with an athletic body type" },
  { value: "pear", displayLabel: "Pear-shaped", promptSegment: "with a pear-shaped body type" },
  { value: "apple", displayLabel: "Apple-shaped", promptSegment: "with an apple-shaped body type" },
  { value: "rectangular", displayLabel: "Rectangular", promptSegment: "with a rectangular body type" },
  { value: "slim_build", displayLabel: "Slim Build", promptSegment: "with a slim build" },
  { value: "curvy_figure", displayLabel: "Curvy Figure", promptSegment: "with a curvy figure" },
  { value: "plus_size_body", displayLabel: "Plus-size Body", promptSegment: "with a plus-size body type" },
];
export const BODY_SIZE_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default", promptSegment: "" },
  { value: "petite_frame", displayLabel: "Petite Frame", promptSegment: "with a petite frame" },
  { value: "average_build", displayLabel: "Average Build", promptSegment: "with an average build" },
  { value: "tall_stature", displayLabel: "Tall Stature", promptSegment: "with a tall stature" },
];
export const HAIR_STYLE_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default", promptSegment: "" },
  { value: "long_wavy_cascading", displayLabel: "Long, Wavy, Cascading", promptSegment: "with long, wavy hair cascading over the shoulders" },
  { value: "sleek_bob_haircut", displayLabel: "Sleek Bob Haircut", promptSegment: "with a sleek bob haircut" },
  { value: "intricate_braided_updo", displayLabel: "Intricate Braided Updo", promptSegment: "with an intricate braided updo" },
  { value: "short_textured_pixie", displayLabel: "Short Textured Pixie Cut", promptSegment: "with a short, textured pixie cut with choppy layers" },
  { value: "shoulder_length_flowing", displayLabel: "Shoulder-Length, Flowing", promptSegment: "with shoulder-length, flowing hair" },
  { value: "chic_blonde_bob", displayLabel: "Chic Blonde Bob", promptSegment: "with a short, chic blonde bob" },
];
export const MODEL_EXPRESSION_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default", promptSegment: "" },
  { value: "serene_gentle_smile", displayLabel: "Serene, Gentle Smile", promptSegment: "with a serene and gentle smile" },
  { value: "intense_captivating_gaze", displayLabel: "Intense, Captivating Gaze", promptSegment: "with an intense, captivating gaze, looking directly into the camera" },
  { value: "joyful_exuberant_laugh", displayLabel: "Joyful, Exuberant Laugh", promptSegment: "with a joyful and exuberant laugh" },
  { value: "thoughtful_contemplative", displayLabel: "Thoughtful, Contemplative", promptSegment: "with a thoughtful and contemplative expression" },
  { value: "fierce_determined_look", displayLabel: "Fierce, Determined Look", promptSegment: "with a fierce and determined look" },
  { value: "neutral_professional_expression", displayLabel: "Neutral, Professional", promptSegment: "with a neutral, professional expression" },
];
export const POSE_STYLE_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default", promptSegment: "" },
  { value: "natural_relaxed_pose", displayLabel: "Natural, Relaxed", promptSegment: "a natural, relaxed pose" },
  { value: "professional_poised_stance", displayLabel: "Professional, Poised", promptSegment: "a professional and poised stance" },
  { value: "editorial_dramatic_artistic", displayLabel: "Editorial, Dramatic, Artistic", promptSegment: "a dramatic, artistic editorial pose" },
  { value: "active_dynamic_movement", displayLabel: "Active, Dynamic Movement", promptSegment: "an active, dynamic pose showcasing movement" },
  { value: "confident_assertive_stance", displayLabel: "Confident, Assertive Stance", promptSegment: "a powerful, assertive stance with shoulders back, looking directly into the camera" },
  { value: "elegant_contrapposto", displayLabel: "Elegant Contrapposto", promptSegment: "an elegant contrapposto pose" },
  { value: "candid_moment_laughing", displayLabel: "Candid Moment, Laughing", promptSegment: "captured in a candid moment, laughing naturally" },
  { value: "looking_off_distance_thoughtful", displayLabel: "Looking Off-Distance, Thoughtful", promptSegment: "looking off into the distance thoughtfully" },
];
export const BACKGROUND_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default Background", promptSegment: "" },
  { value: "outdoor_nature_elements", displayLabel: "Outdoor & Nature", promptSegment: "an outdoor nature setting with appropriate natural elements" },
  { value: "beach_ocean_waves", displayLabel: "Beach & Ocean", promptSegment: "a beautiful beach setting with ocean waves and soft sand" },
  { value: "studio_white_seamless_minimalist", displayLabel: "Studio - White", promptSegment: "a modern minimalist photo studio with a seamless white background" },
  { value: "studio_grey_clean", displayLabel: "Studio - Clean Grey", promptSegment: "a minimalist studio setting with a light grey, clean background" },
  { value: "studio_gradient_subtle", displayLabel: "Studio - Subtle Gradient", promptSegment: "a studio setting with a subtle gradient background" },
  { value: "industrial_loft_exposed_brick", displayLabel: "Industrial Loft", promptSegment: "an industrial loft with exposed brick walls and large windows" },
  { value: "urban_streetscape_night_city_lights", displayLabel: "Urban Night Scene", promptSegment: "a bustling urban streetscape at night, with blurred city lights creating bokeh" },
  { value: "sun_dappled_forest_path", displayLabel: "Forest Path", promptSegment: "a sun-dappled forest path with light filtering through leaves" },
  { value: "stark_dramatic_desert", displayLabel: "Desert Landscape", promptSegment: "a stark, dramatic desert landscape with expansive views" },
  { value: "in_store_retail_environment", displayLabel: "Retail Store Environment", promptSegment: "a realistic in-store retail environment" },
  { value: "lifestyle_cozy_home_interior", displayLabel: "Cozy Home Interior", promptSegment: "a comfortable and stylish lifestyle home interior setting" },
  { value: "abstract_colored_background_moody", displayLabel: "Abstract Moody Background", promptSegment: "an abstract colored background focusing on mood and texture, rather than a specific location" },
];
export const TIME_OF_DAY_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default", promptSegment: "" },
  { value: "golden_hour_warm_glow", displayLabel: "Golden Hour (Warm Glow)", promptSegment: "during the golden hour, with warm, low, and directional sunlight casting long, soft shadows" },
  { value: "blue_hour_cool_ambiance", displayLabel: "Blue Hour (Cool Ambiance)", promptSegment: "during the blue hour, with cool, soft ambient light just before sunrise or after sunset" },
  { value: "moody_twilight_dusk_mysterious", displayLabel: "Moody Twilight/Dusk (Mysterious)", promptSegment: "at moody twilight or dusk, creating a mysterious and atmospheric feel" },
  { value: "bright_midday_sun_clear_sky", displayLabel: "Bright Midday Sun (Clear Sky)", promptSegment: "under bright midday sun on a clear day, creating strong highlights and defined shadows" },
  { value: "overcast_day_soft_diffused_light", displayLabel: "Overcast Day (Soft, Diffused Light)", promptSegment: "on an overcast day, providing soft, diffused, and even light" },
  { value: "night_time_artificial_city_glow", displayLabel: "Night Time (Artificial/City Glow)", promptSegment: "at night, illuminated by artificial lights, neon signs, or the ambient glow of a city" },
];
export const OVERALL_MOOD_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default", promptSegment: "" },
  { value: "cinematic_elegance_sophistication", displayLabel: "Cinematic Elegance, Sophistication", promptSegment: "The overall mood should be one of cinematic elegance and sophistication." },
  { value: "playful_vibrant_energetic_joyful", displayLabel: "Playful, Vibrant, Energetic, Joyful", promptSegment: "The overall mood should be playful, vibrant, and exude joyful energy." },
  { value: "serene_calm_understated_luxury", displayLabel: "Serene, Calm, Unders. Luxury", promptSegment: "The overall mood should be serene, calm, with an aura of understated luxury." },
  { value: "bold_rebellious_edgy_attitude", displayLabel: "Bold, Rebellious, Edgy Attitude", promptSegment: "The overall mood should be bold and rebellious, conveying an edgy attitude." },
  { value: "dreamy_romantic_ethereal_soft", displayLabel: "Dreamy, Romantic, Ethereal, Soft", promptSegment: "The overall mood should be dreamy, romantic, and ethereal, with a soft quality." },
  { value: "powerful_confident_assertive_strong", displayLabel: "Powerful, Confident, Assertive", promptSegment: "The overall mood should be powerful, confident, and assertive." },
  { value: "mysterious_enigmatic_intriguing", displayLabel: "Mysterious, Enigmatic, Intriguing", promptSegment: "The overall mood should be mysterious and enigmatic, creating a sense of intrigue." },
];
export const LIGHTING_TYPE_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default (Style Driven)", promptSegment: "" },
  { value: "natural_available_light", displayLabel: "Natural Available Light", promptSegment: "Utilizing natural, available light characteristic of the chosen time and setting." },
  { value: "studio_softbox_even", displayLabel: "Studio Softbox (Even & Flattering)", promptSegment: "Professional studio lighting with large softboxes for even, flattering illumination and minimal harsh shadows." },
  { value: "studio_ring_light_defined_catchlight", displayLabel: "Studio Ring Light (Defined Catchlight)", promptSegment: "Using a ring light to create a defined, circular catchlight in the eyes and a focused illumination." },
  { value: "studio_three_point_sculpting", displayLabel: "Studio Three-Point (Sculpting)", promptSegment: "A classic three-point lighting setup (key, fill, back/rim light) to sculpt the subject and add dimension." },
  { value: "high_key_lighting_bright_airy", displayLabel: "High-Key Lighting (Bright & Airy)", promptSegment: "High-key lighting with a predominantly white or very light background, creating a bright and airy feel." },
  { value: "low_key_lighting_dark_dramatic", displayLabel: "Low-Key Lighting (Dark & Dramatic)", promptSegment: "Low-key lighting with deep shadows and a dark background, creating a dramatic and moody atmosphere." },
  { value: "rim_lighting_subject_separation", displayLabel: "Rim Lighting (Subject Separation)", promptSegment: "Using rim lighting to create a bright outline around the subject, separating them from the background." },
  { value: "cinematic_volumetric_light_rays", displayLabel: "Cinematic Volumetric Light Rays", promptSegment: "Cinematic lighting featuring volumetric effects like visible light rays or atmospheric haze." },
  { value: "chiaroscuro_strong_contrast_lighting", displayLabel: "Chiaroscuro (Strong Contrast)", promptSegment: "Chiaroscuro lighting with strong contrasts between light and shadow, creating a dramatic, painterly effect." },
  { value: "beauty_dish_focused_soft", displayLabel: "Beauty Dish (Focused Soft)", promptSegment: "Using a beauty dish for a focused yet soft light, often used for beauty and portrait shots." },
];
export const LIGHT_QUALITY_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default", promptSegment: "" },
  { value: "warm_golden_inviting", displayLabel: "Warm, Golden, Inviting", promptSegment: "The light quality is warm, golden, and inviting." },
  { value: "cool_blue_crisp", displayLabel: "Cool, Blue, Crisp", promptSegment: "The light quality is cool, blue, and crisp." },
  { value: "soft_diffused_ethereal", displayLabel: "Soft, Diffused, Ethereal", promptSegment: "The light quality is soft, diffused, and ethereal, wrapping gently around the subject." },
  { value: "hard_direct_graphic_shadows", displayLabel: "Hard, Direct, Graphic Shadows", promptSegment: "The light is hard and direct, creating crisp, well-defined, graphic shadows." },
  { value: "glowing_radiant_luminous", displayLabel: "Glowing, Radiant, Luminous", promptSegment: "The light appears glowing, radiant, or luminous, perhaps with a slight bloom effect." },
];
export const CAMERA_ANGLE_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default (Eye-Level)", promptSegment: "an eye-level shot" },
  { value: "low_angle_emphasize_height", displayLabel: "Low-Angle (Emphasize Height)", promptSegment: "a low-angle shot, making the subject appear powerful and tall" },
  { value: "high_angle_overview_diminish", displayLabel: "High-Angle (Overview/Diminish)", promptSegment: "a high-angle shot, offering an overview or making the subject seem smaller or more vulnerable" },
  { value: "dutch_angle_dynamic_unease", displayLabel: "Dutch Angle (Dynamic/Unease)", promptSegment: "a Dutch angle (canted frame), creating a sense of dynamism, tension, or unease" },
  { value: "profile_view_side", displayLabel: "Profile View (Side)", promptSegment: "a profile view, showing the subject from the side" },
  { value: "three_quarter_view_classic_portrait", displayLabel: "Three-Quarter View (Classic Portrait)", promptSegment: "a three-quarter view, a classic angle for portraits showing some depth" },
  { value: "full_body_shot_entire_outfit", displayLabel: "Full Body Shot (Entire Outfit)", promptSegment: "a full body shot, showcasing the entire outfit from head to toe" },
  { value: "medium_shot_waist_up_focus", displayLabel: "Medium Shot (Waist Up)", promptSegment: "a medium shot, typically from the waist up, balancing subject and some context" },
  { value: "close_up_facial_expression_details", displayLabel: "Close-Up (Facial Expression/Details)", promptSegment: "a close-up, focusing on facial expression or specific garment details" },
  { value: "extreme_close_up_texture_jewelry", displayLabel: "Extreme Close-Up (Texture/Jewelry)", promptSegment: "an extreme close-up, highlighting fabric texture, intricate details, or small accessories like jewelry" },
];
export const LENS_EFFECT_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default (Standard Perspective)", promptSegment: "Photographed with a standard lens perspective, offering a natural field of view." },
  { value: "portrait_lens_85mm_f1_8_bokeh", displayLabel: "Portrait Lens (85mm f/1.8 Style)", promptSegment: "Shot as if with an 85mm f/1.8 lens, creating a classic portrait compression and beautiful subject separation with creamy bokeh." },
  { value: "environmental_lens_35mm_context", displayLabel: "Environmental Lens (35mm Style)", promptSegment: "Shot as if with a 35mm lens, capturing more of the surroundings and providing context, good for street style or lifestyle." },
  { value: "wide_angle_lens_24mm_expansive_minimal_distortion", displayLabel: "Wide-Angle (24mm Expansive)", promptSegment: "Captured with a wide-angle lens perspective (around 24mm), showcasing an expansive scene or dramatic perspective, with minimal optical distortion." },
  { value: "macro_lens_intricate_detail", displayLabel: "Macro Lens (Intricate Detail)", promptSegment: "Using a macro lens effect for extreme close-up detail on textures, embroidery, stitching, or small accessories." },
  { value: "telephoto_lens_compression_subject_isolation", displayLabel: "Telephoto Lens (Compression & Isolation)", promptSegment: "Utilizing a telephoto lens (e.g., 200mm) compression effect, which flattens perspective and strongly isolates the subject from a distant, blurred background." },
];
export const DEPTH_OF_FIELD_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default (Balanced Focus)", promptSegment: "" },
  { value: "shallow_dof_creamy_bokeh_f1_8_style", displayLabel: "Shallow DoF (Creamy Bokeh, f/1.8 Style)", promptSegment: "Achieving a shallow depth of field (simulating an f/1.8 aperture) with a creamy, beautifully blurred bokeh background, making the subject pop." },
  { value: "deep_dof_all_sharp_f16_style", displayLabel: "Deep DoF (All Sharp, f/16 Style)", promptSegment: "Employing a deep depth of field (simulating an f/16 aperture) where both the subject and the background are in sharp focus, ideal for detailed environmental shots." },
  { value: "moderate_dof_subject_context_f5_6_style", displayLabel: "Moderate DoF (Subject & Context, f/5.6 Style)", promptSegment: "Using a moderate depth of field (simulating an f/5.6 aperture) to keep the subject sharp while retaining some recognizable detail in the background context." },
];
export const FABRIC_RENDERING_OPTIONS: OptionWithPromptSegment[] = [
  { value: "default", displayLabel: "Default Rendering", promptSegment: "The fabric of the clothing item should be rendered with realistic texture, drape, and interaction with light." },
  { value: "lustrous_sheen_silk_satin_highlight", displayLabel: "Lustrous Sheen (Silks/Satins)", promptSegment: "Render the fabric with a lustrous sheen, characteristic of silk or satin, effectively catching and reflecting light to show its smooth, luxurious surface." },
  { value: "matte_textured_wool_tweed_weave", displayLabel: "Matte & Textured (Wools/Tweeds)", promptSegment: "Emphasize a matte finish and intricate fabric textures, clearly showing the weave or knit pattern of materials like wool, tweed, or heavy cotton." },
  { value: "flowing_ethereal_chiffon_organza_movement", displayLabel: "Flowing & Ethereal (Chiffon/Organza)", promptSegment: "Capture the flowing, ethereal quality of lightweight or sheer fabrics like chiffon or organza, showing graceful movement, folds, and translucency where appropriate." },
  { value: "crisp_structured_cotton_poplin_neoprene_form", displayLabel: "Crisp & Structured (Poplin/Neoprene)", promptSegment: "Highlight the crisp lines, sharp folds, and structured form of fabrics like cotton poplin, stiff linen, or neoprene." },
  { value: "soft_cozy_knitwear_cashmere_texture", displayLabel: "Soft & Cozy (Knitwear/Cashmere)", promptSegment: "Convey the soft, cozy, and tactile texture of knitwear, such as cashmere or chunky wool, with visible knit patterns and a comfortable drape." },
  { value: "rugged_denim_leather_aged_detail", displayLabel: "Rugged & Worn (Denim/Leather)", promptSegment: "Showcase a rugged, perhaps slightly worn or aged texture, suitable for denim (showing twill lines, fades) or leather (showing grain, subtle creases, polished or matte finish)." },
];

// For Video Generation
export const PREDEFINED_PROMPTS: OptionWithPromptSegment[] = [ // Adjusted to OptionWithPromptSegment for consistency
  { value: 'custom', displayLabel: 'Custom (Build your own)', promptSegment: '' }, // promptSegment is effectively the promptText here
  { value: '360_turn', displayLabel: '360° Turn', promptSegment: 'The model executes a single, slow 360-degree turn on the spot, while the camera remains completely static.' },
  { value: 'walks_toward_camera_pullback', displayLabel: 'Walks Toward You (Camera Pulls Back)', promptSegment: 'The model takes two slow, deliberate steps directly toward the camera, as the camera performs a smooth, subtle pull-back.' },
  { value: 'slow_zoom_in_detail', displayLabel: 'Slow Zoom In for Detail', promptSegment: 'The model slowly shifts her weight from one foot to the other in a subtle, continuous motion, as the camera performs a slow, graceful push-in.'},
  { value: 'turn_to_profile', displayLabel: 'Turn to Profile', promptSegment: 'The model gracefully turns her body 90 degrees to the side, holding the final pose. The camera remains static throughout the movement.'},
  { value: 'step_sideways_camera_follows', displayLabel: 'Step Sideways (Camera Follows)', promptSegment: 'The model takes one single, deliberate step to the side, and the camera performs a smooth, slight pan to follow her, keeping her centered in the frame.'},
  { value: 'walks_away_from_camera', displayLabel: 'Walks Away from Camera', promptSegment: 'The model begins walking in a slow, continuous motion on a diagonal path away from the camera. The camera remains completely static, letting her recede into the scene.'},
  { value: 'slow_zoom_out_reveal', displayLabel: 'Slow Zoom Out to Reveal Scene', promptSegment: 'The model stands perfectly still, holding her pose, as the camera executes a slow, continuous pull-back, revealing more of the surrounding environment.'},
  { value: '180_turn_camera_follows', displayLabel: '180° Turn (Camera Follows)', promptSegment: 'The model performs a slow, fluid half-turn (180 degrees), as the camera pans smoothly to follow her movement, keeping her upper body centered in the frame.'},
  { value: 'walks_toward_camera_still', displayLabel: 'Walks Toward You (Camera is Still)', promptSegment: 'The model walks powerfully and directly forward for three steps. The camera remains static, emphasizing her determined approach.'},
];
export const MODEL_MOVEMENT_OPTIONS: OptionWithPromptSegment[] = [
  { value: 'effortless_poise', displayLabel: 'Effortless Poise', promptSegment: 'settles into a composed, graceful pose with minimal movement' },
  { value: 'living_stillness', displayLabel: 'Living Stillness', promptSegment: 'maintains a poised presence with nearly imperceptible, natural micro-movements, appearing alive and present' },
  { value: 'subtle_posture_shift', displayLabel: 'Subtle Posture Shift', promptSegment: 'makes a slight, elegant shift in posture or weight distribution'},
  { value: 'engaging_gaze_shift', displayLabel: 'Engaging Gaze Shift', promptSegment: 's gaze softly meets the camera or drifts thoughtfully to the side'},
  { value: 'gentle_hair_sway', displayLabel: 'Gentle Hair Sway', promptSegment: 's hair subtly catches the light or sways gently as if from a light breeze'},
  { value: 'pose_for_feature_highlight', displayLabel: 'Pose for Feature Highlight', promptSegment: 'adjusts their pose subtly, drawing attention to a specific garment feature'},
  { value: 'elegant_turn_profile', displayLabel: 'Elegant Turn/Profile', promptSegment: 'executes a smooth, elegant turn or pivots slightly to showcase their profile'},
  { value: 'gentle_stride_initiation', displayLabel: 'Gentle Stride Initiation', promptSegment: 'initiates a slow, graceful step forward or to the side, as if about to walk'},
  { value: 'tactile_garment_adjustment', displayLabel: 'Tactile Garment Adjustment', promptSegment: 'lightly touches, smooths, or subtly adjusts a part of their attire'},
  { value: 'expressive_hand_gesture', displayLabel: 'Expressive Hand/Arm Gesture', promptSegment: 's hands make a soft, expressive gesture or arms shift into a new elegant position'},
];
export const FABRIC_MOTION_OPTIONS_VIDEO: OptionWithPromptSegment[] = [ // Renamed to avoid conflict if image has fabric options
  { value: 'fabric_settles_naturally', displayLabel: 'Fabric Settles Naturally', promptSegment: 'fabric settles or drapes naturally according to gravity and the model\'s form' },
  { value: 'soft_flow_with_movement', displayLabel: 'Soft Flow with Movement', promptSegment: 'fabric flows softly in response to the model\'s movement' },
  { value: 'light_play_on_surface', displayLabel: 'Light Play on Surface', promptSegment: 'fabric catches and plays with the light, creating subtle shimmers or highlights on its surface'},
  { value: 'gentle_ripple_or_crease', displayLabel: 'Gentle Ripple or Crease', promptSegment: 'fabric ripples or creases delicately, showing texture or lightness'},
  { value: 'airy_billow_subtle', displayLabel: 'Subtle Airy Billow', promptSegment: 'fabric billows lightly and subtly, as if touched by a soft, almost imperceptible breeze'},
  { value: 'structured_form_hold', displayLabel: 'Structured Form Hold', promptSegment: 'fabric holds its intended structure and silhouette with minimal flex'},
  { value: 'texture_emphasis_shift', displayLabel: 'Texture Emphasis (Subtle Shift)', promptSegment: 'fabric makes a very subtle shift or crease, highlighting its inherent texture and material quality'},
];
export const CAMERA_ACTION_OPTIONS: OptionWithPromptSegment[] = [
  { value: 'composed_static_shot', displayLabel: 'Composed Static Shot', promptSegment: 'camera maintains a steady, well-composed shot, focusing attention on the model and garment details' },
  { value: 'gentle_camera_breathe', displayLabel: 'Gentle Camera Breathe', promptSegment: 'camera has a very subtle, almost imperceptible "breathing" motion, adding a touch of life to a seemingly static frame' },
  { value: 'smooth_upward_pan_along_figure', displayLabel: 'Smooth Upward Pan (Along Figure)', promptSegment: 'camera smoothly pans upwards along the model, accentuating the full length of the outfit and their stance'},
  { value: 'slow_zoom_to_garment_detail', displayLabel: 'Slow Zoom to Garment Detail', promptSegment: 'camera performs a slow, deliberate zoom towards a key garment detail or texture'},
  { value: 'gentle_orbit_around_model', displayLabel: 'Gentle Orbit Around Model', promptSegment: 'camera executes a gentle, smooth orbiting motion around the model, showcasing the look from multiple angles'},
  { value: 'focus_shift_to_model', displayLabel: 'Focus Shift to Model', promptSegment: 'camera shifts focus from a softly blurred background to bring the model and outfit into sharp clarity'},
  { value: 'subtle_drift_and_reframe', displayLabel: 'Subtle Drift & Reframe', promptSegment: 'camera makes a slow, subtle drift or arc, slightly reframing the model within the shot'},
  { value: 'close_up_follow_detail_motion', displayLabel: 'Close-up Follow Detail in Motion', promptSegment: 'camera moves into a close-up and gently follows a specific detail, like a hand gesture or an accessory, as it moves'},
  { value: 'dolly_in_for_engagement', displayLabel: 'Dolly In for Engagement', promptSegment: 'camera slowly dollies in towards the model, creating a more intimate and engaging perspective'},
  { value: 'pull_back_for_wider_context', displayLabel: 'Pull Back for Wider Context', promptSegment: 'camera slowly pulls back from the initial full-body shot, widening the view to include more of the surrounding context or environment'},
];
export const AESTHETIC_VIBE_OPTIONS: OptionWithPromptSegment[] = [
  { value: 'natural_effortless_style', displayLabel: 'Natural & Effortless Style', promptSegment: 'Exudes a natural and effortless style.' },
  { value: 'timeless_chic_sophistication', displayLabel: 'Timeless Chic & Sophistication', promptSegment: 'Timelessly chic and sophisticated.' },
  { value: 'modern_sleek_edge', displayLabel: 'Modern Sleek Edge', promptSegment: 'Modern, sleek, with a sharp, contemporary edge.'},
  { value: 'dreamy_aspirational_escape', displayLabel: 'Dreamy Aspirational Escape', promptSegment: 'Ethereal and soft, like a dreamy, aspirational escape.'},
  { value: 'vibrant_confident_statement', displayLabel: 'Vibrant Confident Statement', promptSegment: 'Bold, vibrant, and confident, making a memorable statement.'},
  { value: 'warm_golden_hour_glow', displayLabel: 'Warm Golden Hour Glow', promptSegment: 'Bathed in the warm, magical glow of golden hour light.'},
  { value: 'artistic_indie_film_cool', displayLabel: 'Artistic Indie Film Cool', promptSegment: 'Effortlessly cool, with an artistic indie film aesthetic.'},
  { value: 'clean_studio_polish', displayLabel: 'Clean Studio Polish', promptSegment: 'Polished and sharp, with a clean, professional studio aesthetic.'},
  { value: 'bright_outdoor_freshness', displayLabel: 'Bright Outdoor Freshness', promptSegment: 'Bright, airy, and fresh, capturing a vibrant outdoor ambiance.'},
];
// --- END OPTION CONSTANTS ---


// --- Main Prompt Building Function ---
export function buildAIPrompt({ type, params }: BuildAIPromptArgs): string {
  if (type === 'image') {
    // Logic from image-parameters.tsx constructPrompt
    const {
        gender, bodyType, bodySize, ageRange, ethnicity, poseStyle, background,
        fashionStyle, hairStyle, modelExpression, lightingType, lightQuality,
        cameraAngle, lensEffect, depthOfField, timeOfDay, overallMood, fabricRendering,
        settingsMode
    } = params;

    if (settingsMode === 'basic') {
      const genderOption = getSelectedOption(GENDER_OPTIONS, gender)!;
      let modelDescriptionPart = `Create a PHOTOREALISTIC image of a ${genderOption.promptSegment} fashion model`;

      const attributePhrases: string[] = [];
      const bodyTypeOption = getSelectedOption(BODY_TYPE_OPTIONS, bodyType);
      if (bodyTypeOption && bodyTypeOption.value !== "default" && bodyTypeOption.promptSegment) attributePhrases.push(bodyTypeOption.promptSegment);

      const bodySizeOption = getSelectedOption(BODY_SIZE_OPTIONS, bodySize);
      if (bodySizeOption && bodySizeOption.value !== "default" && bodySizeOption.promptSegment) attributePhrases.push(bodySizeOption.promptSegment);

      const ageRangeOption = getSelectedOption(AGE_RANGE_OPTIONS, ageRange);
      if (ageRangeOption && ageRangeOption.value !== "default" && ageRangeOption.promptSegment) attributePhrases.push(ageRangeOption.promptSegment);

      const ethnicityOption = getSelectedOption(ETHNICITY_OPTIONS, ethnicity);
      if (ethnicityOption && ethnicityOption.value !== "default" && ethnicityOption.promptSegment && ethnicityOption.value !== "diverse_multiracial") { // Assuming diverse_multiracial was an old value
        attributePhrases.push(ethnicityOption.promptSegment);
      }

      if (attributePhrases.length > 0) modelDescriptionPart += `, ${attributePhrases.join(', ')}`;

      const poseStyleOption = getSelectedOption(POSE_STYLE_OPTIONS, poseStyle);
      if (poseStyleOption && poseStyleOption.value !== "default" && poseStyleOption.promptSegment) {
        modelDescriptionPart += ` standing in ${poseStyleOption.promptSegment}`;
      }

      modelDescriptionPart += " wearing this clothing item in the image.";

      let settingPart = "";
      const backgroundOption = getSelectedOption(BACKGROUND_OPTIONS, background);
      if (backgroundOption && backgroundOption.value !== "default" && backgroundOption.promptSegment) {
        settingPart = `\n\nSetting: ${backgroundOption.promptSegment}.`;
      }

      const stylePartOld = "\n\nStyle: The model should look authentic and relatable, with a natural expression and subtle smile. The clothing must fit perfectly and be the visual focus of the image.";
      const techPartOld = "\n\nTechnical details: Professional fashion photography with perfect exposure and color accuracy.";

      return `${modelDescriptionPart}${settingPart}${stylePartOld}${techPartOld}`;
    } else { // Advanced mode
        const styleOpt = getSelectedOption(FASHION_STYLE_OPTIONS, fashionStyle);
        let prompt = styleOpt?.basePrompt || FASHION_STYLE_OPTIONS.find(s => s.value === "default_style")!.basePrompt!;

        const genderOpt = getSelectedOption(GENDER_OPTIONS, gender)!;
        prompt = prompt.replace("{gender}", genderOpt.promptSegment);

        let modelDetailSegments: string[] = [];
        const addSegment = (optionArray: OptionWithPromptSegment[], value?: string) => {
          const opt = getSelectedOption(optionArray, value);
          if (opt && opt.value !== "default" && opt.promptSegment) modelDetailSegments.push(opt.promptSegment);
        };

        addSegment(AGE_RANGE_OPTIONS, ageRange);
        addSegment(ETHNICITY_OPTIONS, ethnicity);
        addSegment(BODY_TYPE_OPTIONS, bodyType);
        addSegment(BODY_SIZE_OPTIONS, bodySize);
        addSegment(HAIR_STYLE_OPTIONS, hairStyle);
        addSegment(MODEL_EXPRESSION_OPTIONS, modelExpression);

        prompt = prompt.replace("{modelDetails}", modelDetailSegments.length > 0 ? modelDetailSegments.join(", ") : "with typical features");

        const poseOpt = getSelectedOption(POSE_STYLE_OPTIONS, poseStyle);
        let poseDetail = "";
        if (poseOpt && poseOpt.value !== "default" && poseOpt.promptSegment) {
          poseDetail = `in ${poseOpt.promptSegment}`;
        }
        prompt = prompt.replace("{poseStyleDetails}", poseDetail);

        if (styleOpt && styleOpt.value !== "default_style" && styleOpt.promptSegment) {
          prompt += `\n\nOverall Style Notes: ${styleOpt.promptSegment}`;
        }

        let settingDescription = "";
        const backgroundOpt = getSelectedOption(BACKGROUND_OPTIONS, background);
        const timeOfDayOpt = getSelectedOption(TIME_OF_DAY_OPTIONS, timeOfDay);

        if (backgroundOpt && backgroundOpt.value !== "default" && backgroundOpt.promptSegment) {
          settingDescription += backgroundOpt.promptSegment;
        } else if (params.fashionStyle === "ecommerce_product") {
          settingDescription += getSelectedOption(BACKGROUND_OPTIONS, "studio_white_seamless_minimalist")!.promptSegment;
        }

        if (timeOfDayOpt && timeOfDayOpt.value !== "default" && timeOfDayOpt.promptSegment) {
          if (settingDescription) settingDescription += `, ${timeOfDayOpt.promptSegment}`;
          else settingDescription = `The scene is set ${timeOfDayOpt.promptSegment}`;
        }
        if (settingDescription) {
          prompt += `\n\nSetting: ${settingDescription}.`;
        }

        let lightingDescription = "";
        const lightingTypeOpt = getSelectedOption(LIGHTING_TYPE_OPTIONS, lightingType);
        const lightQualityOpt = getSelectedOption(LIGHT_QUALITY_OPTIONS, lightQuality);

        if (lightingTypeOpt && lightingTypeOpt.value !== "default" && lightingTypeOpt.promptSegment) {
          lightingDescription += lightingTypeOpt.promptSegment;
        } else {
          if (params.fashionStyle === "ecommerce_product") {
            lightingDescription += getSelectedOption(LIGHTING_TYPE_OPTIONS, "studio_softbox_even")!.promptSegment;
          } else if (params.fashionStyle === "lifestyle_street" && timeOfDayOpt?.value !== "default") {
              lightingDescription += getSelectedOption(LIGHTING_TYPE_OPTIONS, "natural_available_light")!.promptSegment;
          } else if (params.fashionStyle === "high_fashion_editorial" || params.fashionStyle === "creative_conceptual") {
            lightingDescription += "Lighting should be artistic and complement the concept, potentially dramatic or unconventional.";
          } else {
             lightingDescription += "Professional fashion photography lighting.";
          }
        }

        if (lightQualityOpt && lightQualityOpt.value !== "default" && lightQualityOpt.promptSegment) {
          if (lightingDescription.length > 0 && !lightingDescription.endsWith(".")) lightingDescription += ".";
          lightingDescription += ` ${lightQualityOpt.promptSegment}`;
        }
        if (lightingDescription) {
          prompt += `\n\nLighting: ${lightingDescription.trim()}`;
        }

        let shotDetailSegments: string[] = [];
        const addShotDetail = (optionArray: OptionWithPromptSegment[], value?: string) => {
          const opt = getSelectedOption(optionArray, value);
          if (opt && opt.value !== "default" && opt.promptSegment) shotDetailSegments.push(opt.promptSegment);
        };

        addShotDetail(CAMERA_ANGLE_OPTIONS, cameraAngle);
        addShotDetail(LENS_EFFECT_OPTIONS, lensEffect);
        addShotDetail(DEPTH_OF_FIELD_OPTIONS, depthOfField);

        if (shotDetailSegments.length > 0) {
          prompt += `\n\nShot Details: ${shotDetailSegments.join('. ')}.`;
        } else {
          if (params.fashionStyle === "ecommerce_product") {
            prompt += `\n\nShot Details: ${getSelectedOption(CAMERA_ANGLE_OPTIONS, "full_body_shot_entire_outfit")!.promptSegment}. ${getSelectedOption(LENS_EFFECT_OPTIONS, "default")!.promptSegment}.`;
          }
        }

        if (params.fashionStyle !== "creative_conceptual") {
          prompt += " The composition should be visually striking, well-balanced, and effectively showcase the subject and garment.";
        }

        const moodOpt = getSelectedOption(OVERALL_MOOD_OPTIONS, overallMood);
        if (moodOpt && moodOpt.value !== "default" && moodOpt.promptSegment) {
          prompt += `\n\nOverall Mood & Atmosphere: ${moodOpt.promptSegment}.`;
        }

        const fabricOpt = getSelectedOption(FABRIC_RENDERING_OPTIONS, fabricRendering);
        if (fabricOpt && fabricOpt.value !== "default" && fabricOpt.promptSegment) {
          prompt += `\n\nFabric Rendering Specifics: ${fabricOpt.promptSegment}.`;
        } else if (params.fashionStyle === "ecommerce_product") {
          prompt += `\n\nFabric Rendering Specifics: ${getSelectedOption(FABRIC_RENDERING_OPTIONS, "default")!.promptSegment} Emphasize true-to-life texture and how the fabric drapes on the model.`;
        } else {
          prompt += `\n\nFabric Rendering Specifics: ${getSelectedOption(FABRIC_RENDERING_OPTIONS, "default")!.promptSegment}`;
        }

        let finalQualityStatement = "The final image must be photorealistic, highly detailed, with impeccable exposure and color accuracy. Ensure the clothing fits the model perfectly and is the clear visual focus of the image. Avoid common AI artifacts, especially in hands and facial features, aiming for natural human anatomy.";
        if (params.fashionStyle === "ecommerce_product") {
          finalQualityStatement = "For this e-commerce shot, the final image must be exceptionally high-resolution, with tack-sharp focus on the garment. True-to-life color representation and clear visibility of fabric texture, weave, and garment details (stitching, buttons) are paramount. Ensure a clean, professional presentation and that the clothing fits the model accurately and flatteringly. No distracting elements.";
        } else if (params.fashionStyle === "high_fashion_editorial" || params.fashionStyle === "creative_conceptual") {
          finalQualityStatement = "The final image should be of exceptional artistic quality, highly detailed, and powerfully convey the intended concept or narrative. Exposure and color should be masterfully controlled, whether for accuracy or deliberate artistic effect. Subtleties in model expression and pose are critical. Avoid AI artifacts.";      }
        prompt += `\n\nTechnical & Quality Requirements: ${finalQualityStatement}`;

        return prompt.replace(/,\s*$/, ".").replace(/\.\s*\./g, ".").replace(/\s{2,}/g, ' ').trim();
    }

  } else if (type === 'video') {
    // Logic from video-parameters.tsx constructVideoPrompt
    const { selectedPredefinedPrompt, modelMovement, fabricMotion, cameraAction, aestheticVibe } = params;

    const predefined = getSelectedOption(PREDEFINED_PROMPTS, selectedPredefinedPrompt);
    if (predefined && predefined.value !== 'custom' && predefined.promptSegment) {
      return predefined.promptSegment; // This is the full prompt for predefined options
    }

    // Custom construction
    const getSeg = (options: OptionWithPromptSegment[], value?: string) => getSelectedOption(options, value)?.promptSegment || '';
    const modelMovementSeg = getSeg(MODEL_MOVEMENT_OPTIONS, modelMovement);
    const fabricMotionSeg = getSeg(FABRIC_MOTION_OPTIONS_VIDEO, fabricMotion); // Use renamed constant
    const cameraActionSeg = getSeg(CAMERA_ACTION_OPTIONS, cameraAction);
    const aestheticVibeSeg = getSeg(AESTHETIC_VIBE_OPTIONS, aestheticVibe);

    const clauses: string[] = [];
    if (modelMovementSeg) {
      const modelPrefix = modelMovementSeg.startsWith('s ') ? "The model'" : "The model ";
      let modelClause = `${modelPrefix}${modelMovementSeg}`;
      if (fabricMotionSeg) modelClause += `, and the garment's fabric ${fabricMotionSeg}`;
      clauses.push(modelClause + '.');
    } else if (fabricMotionSeg) {
      clauses.push(`The garment's fabric ${fabricMotionSeg}.`);
    }
    if (cameraActionSeg) clauses.push(`The camera ${cameraActionSeg}.`);
    if (aestheticVibeSeg) clauses.push(aestheticVibeSeg);

    return clauses.length > 0 ? clauses.join(' ') : 'A photorealistic fashion model posing elegantly in a stylish outfit.';
  }
  return "Invalid generation type specified.";
}
</file>

<file path="src/lib/session.ts">
import type { SessionOptions } from 'iron-session';
import type { SessionData } from '@/lib/types';

export const sessionOptions: SessionOptions = {
  password: process.env.SESSION_SECRET as string,
  cookieName: 'refashion-local-session',
  cookieOptions: {
    secure: process.env.NODE_ENV === 'production' && (process.env.FORCE_HTTPS === 'true' || process.env.NEXT_PUBLIC_APP_URL?.startsWith('https:')), // Use secure cookies only if HTTPS is enabled
    httpOnly: true,
    sameSite: 'lax',
  },
  ttl: 60 * 60 * 24 * 7 // 7 days
};

// Augment the IronSession type definition if you're using TypeScript
// to include the structure of your session data.
declare module 'iron-session' {
  interface IronSessionData {
    user?: SessionData['user'];
  }
}
</file>

<file path="src/lib/types.ts">
export interface SessionUser {
  username: string;
  role: 'admin' | 'user';
  isLoggedIn: boolean;
}

export interface SessionData {
  user?: SessionUser;
}

export interface HistoryItem {
  id: string;
  timestamp: number;
  attributes: ModelAttributes;
  constructedPrompt: string;
  originalClothingUrl: string;
  editedImageUrls: (string | null)[];
  originalImageUrls?: (string | null)[]; // Store pre-face-detailed versions for comparison
  username: string;
  settingsMode?: 'basic' | 'advanced';
  generatedVideoUrls?: (string | null)[];
  videoGenerationParams?: {
    prompt: string;
    resolution: string;
    videoModel?: 'lite' | 'pro';
    duration: string;
    seed: number;
    sourceImageUrl: string;
    // NEW structured fields
    modelMovement: string;
    fabricMotion: string;
    cameraAction: string;
    aestheticVibe: string;
    cameraFixed: boolean;
    // Webhook-related fields
    localVideoUrl?: string | null;
  };
  status?: 'processing' | 'completed' | 'failed';
  error?: string;
}

export interface ModelAttributes {
  gender: string;
  bodyType: string;
  bodySize: string;
  ageRange: string;
  ethnicity: string;
  poseStyle: string;
  background: string;
  fashionStyle: string;
  hairStyle: string;
  modelExpression: string;
  lightingType: string;
  lightQuality: string;
  cameraAngle: string;
  lensEffect: string;
  depthOfField: string;
  timeOfDay: string;
  overallMood: string;
  fabricRendering: string;
}
</file>

<file path="src/lib/utils.test.ts">
import { cn } from './utils';

describe('cn', () => {
  it('should merge class names correctly', () => {
    expect(cn('foo', 'bar')).toBe('foo bar');
  });

  it('should handle conditional class names', () => {
    expect(cn('foo', { bar: true, baz: false })).toBe('foo bar');
  });

  it('should merge tailwind classes correctly', () => {
    expect(cn('px-2 py-1 bg-red hover:bg-dark-red', 'p-4 bg-blue')).toBe('hover:bg-dark-red p-4 bg-blue');
  });
});
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

/**
 * Converts upload URLs to use the image-proxy API route
 * This ensures images are served directly from filesystem, bypassing Next.js static file caching issues
 * @param originalPath - The original path like '/uploads/generated_images/image.png'
 * @returns The proxy path like '/api/image-proxy/generated_images/image.png'
 */
export function getDisplayableImageUrl(originalPath: string | null): string | null {
  if (!originalPath) return null;

  // Handle data URIs (base64 images) - return as-is
  if (originalPath.startsWith("data:")) {
    return originalPath;
  }

  // Convert /uploads/... paths to /api/image-proxy/... paths
  if (originalPath.startsWith("/uploads/")) {
    // Remove '/uploads/' prefix and add '/api/image-proxy/' prefix
    const subPath = originalPath.substring("/uploads/".length);
    return `/api/image-proxy/${subPath}`;
  }

  // For any other paths, return as-is
  return originalPath;
}
</file>

<file path="src/middleware.ts">
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getIronSession } from 'iron-session';
import { cookies } from 'next/headers';
import { sessionOptions } from '@/lib/session';
import type { SessionData } from '@/lib/types';

const ALLOWED_ORIGINS = [
  'https://marcodirenzo.ch',
  'https://demo.marcodirenzo.ch',
];

export async function middleware(request: NextRequest) {
  const origin = request.headers.get('origin');
  const isApiV1Route = request.nextUrl.pathname.startsWith('/api/v1/');

  // Handle CORS preflight requests for the API
  if (isApiV1Route && request.method === 'OPTIONS') {
    if (origin && ALLOWED_ORIGINS.includes(origin)) {
      return new NextResponse(null, {
        status: 204,
        headers: {
          'Access-Control-Allow-Origin': origin,
          'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        },
      });
    }
  }

  const session = await getIronSession<SessionData>(await cookies(), sessionOptions);
  const { user } = session;

  const { pathname } = request.nextUrl;

  // Allow access to login page and public assets/API routes
  if (pathname.startsWith('/login') || 
      pathname.startsWith('/_next/') || 
      pathname.startsWith('/api/') || 
      pathname.startsWith('/uploads/') || // Allow access to uploaded files
      pathname.includes('.')) { // Allows requests for static files like .png, .css
    
    const response = NextResponse.next();
    
    // Add CORS headers for API v1 routes on actual requests
    if (isApiV1Route && origin && ALLOWED_ORIGINS.includes(origin)) {
      response.headers.set('Access-Control-Allow-Origin', origin);
    }
    
    return response;
  }

  if (!user?.isLoggedIn) {
    // Redirect to login page, preserving the intended destination
    const loginUrl = new URL('/login', request.url);
    // loginUrl.searchParams.set('redirect_to', pathname); // Optional: redirect back after login
    return NextResponse.redirect(loginUrl);
  }
  // Check admin-only routes
  if (pathname.startsWith('/admin/')) {
    if (user.role !== 'admin') {
      // Redirect non-admin users to home page or show 403
      return NextResponse.redirect(new URL('/', request.url));
    }
    // Allow admin users to access admin routes only if they explicitly navigate to them
    // This prevents automatic redirects to admin areas
  }

  const response = NextResponse.next();
  
  // Add CORS headers for API v1 routes on actual requests
  if (isApiV1Route && origin && ALLOWED_ORIGINS.includes(origin)) {
    response.headers.set('Access-Control-Allow-Origin', origin);
  }
  
  return response;
}

// Define which paths the middleware should run on
export const config = {
  matcher: [
    // Match all paths except for static files and image optimization
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};
</file>

<file path="src/services/apiKey.service.ts">
// src/services/apiKey.service.ts
'use server';

import * as dbService from './database.service';
import * as settingsService from './settings.service';
import { decrypt } from './encryption.service';

type ApiService = 'gemini' | 'fal';

/**
 * Retrieves the correct API key for a given user and service.
 * It checks for a user-specific key first, then falls back to the global key.
 * @param username - The user for whom to retrieve the key.
 * @param service - The service ('gemini' or 'fal') for which the key is needed.
 * @param index - The index (1, 2, or 3) for the Gemini key. Required for Gemini, ignored for Fal.
 * @returns The decrypted API key as a string.
 * @throws An error if no key is configured for the service.
 */
export async function getApiKeyForUser(username: string, service: ApiService, index?: 1 | 2 | 3): Promise<string> {
  const user = dbService.findUserByUsername(username);
  if (!user) {
    throw new Error(`User '${username}' not found.`);
  }

  if (service === 'gemini' && !index) {
    throw new Error('Index (1, 2, or 3) is required for Gemini API key retrieval.');
  }

  const keyModeField = service === 'gemini' ? `gemini_api_key_${index}_mode` : 'fal_api_key_mode';
  const userApiKeyField = service === 'gemini' ? `gemini_api_key_${index}` : 'fal_api_key';

  // 1. Check for user-specific key
  if ((user as any)[keyModeField] === 'user_specific') {
    const userApiKey = (user as any)[userApiKeyField];
    if (userApiKey) {
      const decryptedKey = decrypt(userApiKey);
      if (decryptedKey) {
        console.log(`Using user-specific ${service} key (index: ${index || 'N/A'}) for user '${username}'.`);
        return decryptedKey;
      }
    }
  }

  // 2. Fallback to global key
  const globalKeySetting = service === 'gemini' 
    ? `global_gemini_api_key_${index}` 
    : 'global_fal_api_key';
  
  const encryptedGlobalKey = settingsService.getSetting(globalKeySetting as settingsService.SettingKey);
  if (encryptedGlobalKey) {
    const decryptedKey = decrypt(encryptedGlobalKey);
    if (decryptedKey) {
      console.log(`Using global ${service} key (index: ${index || 'N/A'}) for user '${username}'.`);
      return decryptedKey;
    }
  }

  // 3. If no key is found, throw an error.
  throw new Error(`API key for service '${service}' (index: ${index || 'N/A'}) is not configured for user '${username}' or globally.`);
}
</file>

<file path="src/services/database.service.ts">
import Database from 'better-sqlite3';
import path from 'path';
import fs from 'fs';
import type { HistoryItem, ModelAttributes, SessionUser } from '@/lib/types';

// Video status payload type for efficient polling
export interface VideoStatusPayload {
  status: 'processing' | 'completed' | 'failed' | 'unknown';
  videoUrl?: string | null;
  error?: string;
  seed?: number;
}

const DB_DIR = path.join(process.cwd(), 'user_data', 'history');
const DB_PATH = path.join(DB_DIR, 'history.db');

let db: Database.Database;

// Singleton pattern to ensure only one DB connection
export function getDb(): Database.Database {
  if (db) {
    return db;
  }

  // Ensure directory exists
  fs.mkdirSync(DB_DIR, { recursive: true });

  db = new Database(DB_PATH, { verbose: process.env.NODE_ENV === 'development' ? console.log : undefined });
  console.log('SQLite database connected at', DB_PATH);
  
  // Enable Write-Ahead Logging for better concurrency
  db.pragma('journal_mode = WAL');
  db.pragma('synchronous = NORMAL');
  db.pragma('foreign_keys = ON');

  // Initialize schema on first connect
  initSchema(db);

  return db;
}

function initSchema(db: Database.Database) {
  db.exec(`
    CREATE TABLE IF NOT EXISTS history (
      id TEXT PRIMARY KEY,
      username TEXT NOT NULL,
      timestamp INTEGER NOT NULL,
      constructedPrompt TEXT,
      originalClothingUrl TEXT,
      settingsMode TEXT,
      attributes TEXT,
      videoGenerationParams TEXT
    );

    CREATE TABLE IF NOT EXISTS users (
      username TEXT PRIMARY KEY,
      password_hash TEXT NOT NULL,
      role TEXT NOT NULL CHECK (role IN ('admin', 'user')),
      gemini_api_key_1 TEXT,
      gemini_api_key_1_mode TEXT NOT NULL DEFAULT 'global' CHECK (gemini_api_key_1_mode IN ('global', 'user_specific')),
      gemini_api_key_2 TEXT,
      gemini_api_key_2_mode TEXT NOT NULL DEFAULT 'global' CHECK (gemini_api_key_2_mode IN ('global', 'user_specific')),
      gemini_api_key_3 TEXT,
      gemini_api_key_3_mode TEXT NOT NULL DEFAULT 'global' CHECK (gemini_api_key_3_mode IN ('global', 'user_specific')),
      fal_api_key TEXT,
      fal_api_key_mode TEXT NOT NULL DEFAULT 'global' CHECK (fal_api_key_mode IN ('global', 'user_specific'))
    );
    
    CREATE TABLE IF NOT EXISTS history_images (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      history_id TEXT NOT NULL,
      url TEXT NOT NULL,
      type TEXT NOT NULL CHECK (type IN ('edited', 'original_for_comparison', 'generated_video')),
      slot_index INTEGER NOT NULL,
      FOREIGN KEY (history_id) REFERENCES history (id) ON DELETE CASCADE
    );
    
    CREATE TABLE IF NOT EXISTS settings (
      key TEXT PRIMARY KEY,
      value TEXT NOT NULL
    );

    CREATE INDEX IF NOT EXISTS idx_history_username_timestamp ON history (username, timestamp DESC);
    CREATE INDEX IF NOT EXISTS idx_history_images_history_id ON history_images (history_id);
    CREATE UNIQUE INDEX IF NOT EXISTS idx_users_username ON users (username);
  `);

  // Insert default values for feature flags if they don't exist
  db.exec(`
    INSERT OR IGNORE INTO settings (key, value) VALUES 
      ('feature_video_generation', 'true'),
      ('feature_background_removal', 'true'),
      ('feature_image_upscaling', 'true'),
      ('feature_face_detailer', 'true'),
      ('global_gemini_api_key_1', ''),
      ('global_gemini_api_key_2', ''),
      ('global_gemini_api_key_3', ''),
      ('global_fal_api_key', '')
  `);
  console.log('Database schema initialized.');
}

// Database operations
export interface PaginationOptions {
  username: string;
  page: number;
  limit: number;
  filter?: 'video' | 'image';
}

export interface PaginationResult {
  items: HistoryItem[];
  totalCount: number;
  hasMore: boolean;
  currentPage: number;
}

// Prepared statements
let preparedStatements: {
  insertHistory?: Database.Statement;
  insertImage?: Database.Statement;
  findHistoryById?: Database.Statement;
  updateHistory?: Database.Statement;
  deleteImagesByHistoryId?: Database.Statement;
  findHistoryByUsername?: Database.Statement;
  countHistoryByUsername?: Database.Statement;
  findHistoryPaginated?: Database.Statement;
  findHistoryPaginatedWithVideoFilter?: Database.Statement;
  findHistoryPaginatedWithImageFilter?: Database.Statement;
} = {};

function getPreparedStatements() {
  if (!preparedStatements.insertHistory) {
    const db = getDb();
    
    preparedStatements.insertHistory = db.prepare(`
      INSERT OR REPLACE INTO history 
      (id, username, timestamp, constructedPrompt, originalClothingUrl, settingsMode, attributes, videoGenerationParams, status, error)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
    
    preparedStatements.insertImage = db.prepare(`
      INSERT INTO history_images (history_id, url, type, slot_index)
      VALUES (?, ?, ?, ?)
    `);
    
    preparedStatements.findHistoryById = db.prepare(`
      SELECT h.*, 
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'edited' ORDER BY slot_index)) as edited_images,
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'original_for_comparison' ORDER BY slot_index)) as original_images,
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'generated_video' ORDER BY slot_index)) as video_urls
      FROM history h
      WHERE h.id = ?
    `);
    
    preparedStatements.updateHistory = db.prepare(`
      UPDATE history 
      SET constructedPrompt = COALESCE(?, constructedPrompt),
          videoGenerationParams = COALESCE(?, videoGenerationParams)
      WHERE id = ?
    `);
    
    preparedStatements.deleteImagesByHistoryId = db.prepare(`
      DELETE FROM history_images WHERE history_id = ?
    `);
    
    preparedStatements.findHistoryByUsername = db.prepare(`
      SELECT h.*, 
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'edited' ORDER BY slot_index)) as edited_images,
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'original_for_comparison' ORDER BY slot_index)) as original_images,
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'generated_video' ORDER BY slot_index)) as video_urls
      FROM history h
      WHERE h.username = ?
      ORDER BY h.timestamp DESC
    `);
    
    preparedStatements.countHistoryByUsername = db.prepare(`
      SELECT COUNT(*) as count FROM history WHERE username = ?
    `);
    
    preparedStatements.findHistoryPaginated = db.prepare(`
      SELECT h.*, 
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'edited' ORDER BY slot_index)) as edited_images,
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'original_for_comparison' ORDER BY slot_index)) as original_images,
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'generated_video' ORDER BY slot_index)) as video_urls
      FROM history h
      WHERE h.username = ?
      ORDER BY h.timestamp DESC
      LIMIT ? OFFSET ?
    `);
    
    preparedStatements.findHistoryPaginatedWithVideoFilter = db.prepare(`
      SELECT h.*, 
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'edited' ORDER BY slot_index)) as edited_images,
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'original_for_comparison' ORDER BY slot_index)) as original_images,
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'generated_video' ORDER BY slot_index)) as video_urls
      FROM history h
      WHERE h.username = ? AND h.videoGenerationParams IS NOT NULL
      ORDER BY h.timestamp DESC
      LIMIT ? OFFSET ?
    `);
    
    preparedStatements.findHistoryPaginatedWithImageFilter = db.prepare(`
      SELECT h.*, 
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'edited' ORDER BY slot_index)) as edited_images,
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'original_for_comparison' ORDER BY slot_index)) as original_images,
             (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'generated_video' ORDER BY slot_index)) as video_urls
      FROM history h
      WHERE h.username = ? AND h.videoGenerationParams IS NULL
      ORDER BY h.timestamp DESC
      LIMIT ? OFFSET ?
    `);
  }
  
  return preparedStatements;
}

export function rowToHistoryItem(row: any): HistoryItem { // Export for use in actions
  // Do NOT filter(Boolean) -- preserve nulls for correct slot mapping
  let editedImageUrls: any[] = [];
  let originalImageUrls: any[] | undefined = undefined;
  let generatedVideoUrls: any[] | undefined = undefined;
  let attributes: ModelAttributes = {} as ModelAttributes;
  let videoGenerationParams: any = undefined;

  try {
    editedImageUrls = row.edited_images ? JSON.parse(row.edited_images) : [];
  } catch (e) { editedImageUrls = []; }
  try {
    originalImageUrls = row.original_images ? JSON.parse(row.original_images) : undefined;
  } catch (e) { originalImageUrls = undefined; }
  try {
    generatedVideoUrls = row.video_urls ? JSON.parse(row.video_urls) : undefined;
  } catch (e) { generatedVideoUrls = undefined; }
  try {
    attributes = row.attributes ? JSON.parse(row.attributes) : {} as ModelAttributes;
  } catch (e) { attributes = {} as ModelAttributes; }
  try {
    videoGenerationParams = row.videoGenerationParams ? JSON.parse(row.videoGenerationParams) : undefined;
  } catch (e) { videoGenerationParams = undefined; }

  return {
    id: row.id,
    username: row.username,
    timestamp: row.timestamp,
    constructedPrompt: row.constructedPrompt,
    originalClothingUrl: row.originalClothingUrl,
    settingsMode: row.settingsMode as 'basic' | 'advanced',
    attributes,
    editedImageUrls: editedImageUrls || [], // Return arrays as-is
    originalImageUrls,
    generatedVideoUrls,
    videoGenerationParams,
    status: row.status as 'processing' | 'completed' | 'failed',
    error: row.error || undefined,
  };
}

export function insertHistoryItem(item: HistoryItem): void {
  const db = getDb();
  const statements = getPreparedStatements();
  
  const insertTransaction = db.transaction(() => {
    // Insert main history record
    statements.insertHistory!.run(
      item.id,
      item.username,
      item.timestamp,
      item.constructedPrompt,
      item.originalClothingUrl,
      item.settingsMode,
      JSON.stringify(item.attributes),
      item.videoGenerationParams ? JSON.stringify(item.videoGenerationParams) : null,
      item.status || 'completed',
      item.error || null
    );
    
    // Insert edited images
    item.editedImageUrls.forEach((url, index) => {
      if (url) {
        statements.insertImage!.run(item.id, url, 'edited', index);
      }
    });
    
    // Insert original images if they exist
    if (item.originalImageUrls) {
      item.originalImageUrls.forEach((url, index) => {
        if (url) {
          statements.insertImage!.run(item.id, url, 'original_for_comparison', index);
        }
      });
    }
    
    // Insert video URLs if they exist
    if (item.generatedVideoUrls) {
      item.generatedVideoUrls.forEach((url, index) => {
        if (url) {
          statements.insertImage!.run(item.id, url, 'generated_video', index);
        }
      });
    }
  });
  
  insertTransaction();
}

export function findHistoryItemById(id: string): HistoryItem | null {
  const statements = getPreparedStatements();
  const row = statements.findHistoryById!.get(id);
  return row ? rowToHistoryItem(row) : null;
}

/**
 * Atomically updates a history item and its related images/videos.
 * This function is safe from race conditions.
 * @param id The ID of the history item to update.
 * @param updates A partial HistoryItem object. For arrays, you can provide the full array to replace it.
 */
export function updateHistoryItem(id: string, updates: Partial<HistoryItem>): void {
  const db = getDb();

  const updateTransaction = db.transaction(() => {
    // Update simple text fields if provided
    if (updates.constructedPrompt !== undefined || updates.settingsMode !== undefined || updates.status !== undefined || updates.error !== undefined) {
      const updateMainStmt = db.prepare(`
        UPDATE history
        SET constructedPrompt = COALESCE(?, constructedPrompt),
            settingsMode = COALESCE(?, settingsMode),
            status = COALESCE(?, status),
            error = COALESCE(?, error)
        WHERE id = ?
      `);
      updateMainStmt.run(
        updates.constructedPrompt,
        updates.settingsMode,
        updates.status,
        updates.error,
        id
      );
    }

    // Atomically patch JSON fields
    if (updates.attributes) {
      db.prepare(`UPDATE history SET attributes = json_patch(attributes, ?) WHERE id = ?`)
        .run(JSON.stringify(updates.attributes), id);
    }
    if (updates.videoGenerationParams) {
      db.prepare(`UPDATE history SET videoGenerationParams = json_patch(COALESCE(videoGenerationParams, '{}'), ?) WHERE id = ?`)
        .run(JSON.stringify(updates.videoGenerationParams), id);
    }

    // Helper to replace an image/video array
    const replaceUrls = (urls: (string | null)[] | undefined, type: 'edited' | 'original_for_comparison' | 'generated_video') => {
      if (!urls) return;
      const deleteStmt = db.prepare(`DELETE FROM history_images WHERE history_id = ? AND type = ?`);
      const insertStmt = db.prepare(`INSERT INTO history_images (history_id, url, type, slot_index) VALUES (?, ?, ?, ?)`);

      deleteStmt.run(id, type);
      urls.forEach((url, index) => {
        if (url) {
          insertStmt.run(id, url, type, index);
        }
      });
    };

    // Replace image/video arrays if they are provided in the updates
    replaceUrls(updates.editedImageUrls, 'edited');
    replaceUrls(updates.originalImageUrls, 'original_for_comparison');
    replaceUrls(updates.generatedVideoUrls, 'generated_video');
  });

  updateTransaction();
}

/**
 * @deprecated Use the new atomic `updateHistoryItem` function instead. This function is not safe from race conditions for complex updates.
 */
export function _dangerouslyUpdateHistoryItem(
  id: string,
  updates: Partial<Pick<HistoryItem, 'editedImageUrls' | 'originalImageUrls' | 'constructedPrompt' | 'generatedVideoUrls' | 'videoGenerationParams'>>
): void {
  // NOTE: updateHistoryItem is subject to race conditions if called concurrently for the same id.
  // For robust webhook handling, consider using an atomic SQL UPDATE with JSON patch/merge logic.
  const db = getDb();
  const statements = getPreparedStatements();
  
  const updateTransaction = db.transaction(() => {
    // Update main record
    statements.updateHistory!.run(
      updates.constructedPrompt || null,
      updates.videoGenerationParams ? JSON.stringify(updates.videoGenerationParams) : null,
      id
    );
    
    // If updating images/videos, delete existing and re-insert
    if (updates.editedImageUrls || updates.originalImageUrls || updates.generatedVideoUrls) {
      statements.deleteImagesByHistoryId!.run(id);
      
      if (updates.editedImageUrls) {
        updates.editedImageUrls.forEach((url, index) => {
          if (url) {
            statements.insertImage!.run(id, url, 'edited', index);
          }
        });
      }
      
      if (updates.originalImageUrls) {
        updates.originalImageUrls.forEach((url, index) => {
          if (url) {
            statements.insertImage!.run(id, url, 'original_for_comparison', index);
          }
        });
      }
      
      if (updates.generatedVideoUrls) {
        updates.generatedVideoUrls.forEach((url, index) => {
          if (url) {
            statements.insertImage!.run(id, url, 'generated_video', index);
          }
        });
      }
    }
  });
  
  updateTransaction();
}

export function findHistoryByUsername(username: string): HistoryItem[] {
  const statements = getPreparedStatements();
  const rows = statements.findHistoryByUsername!.all(username);
  return rows.map(rowToHistoryItem);
}

export function getPaginatedHistoryForUser(options: PaginationOptions): PaginationResult {
  const statements = getPreparedStatements();
  const { username, page, limit, filter } = options;
  
  const offset = (page - 1) * limit;
  
  let countQuery: Database.Statement;
  let dataQuery: Database.Statement;
  
  if (filter === 'video') {
    countQuery = getDb().prepare('SELECT COUNT(*) as count FROM history WHERE username = ? AND videoGenerationParams IS NOT NULL');
    dataQuery = statements.findHistoryPaginatedWithVideoFilter!;
  } else if (filter === 'image') {
    countQuery = getDb().prepare('SELECT COUNT(*) as count FROM history WHERE username = ? AND videoGenerationParams IS NULL');
    dataQuery = statements.findHistoryPaginatedWithImageFilter!;
  } else {
    countQuery = statements.countHistoryByUsername!;
    dataQuery = statements.findHistoryPaginated!;
  }
  
  const countResult = countQuery.get(username) as { count: number };
  const totalCount = countResult.count;
  
  const rows = dataQuery.all(username, limit, offset);
  const items = rows.map(rowToHistoryItem);
  
  const hasMore = offset + limit < totalCount;
  
  return {
    items,
    totalCount,
    hasMore,
    currentPage: page
  };
}

export function getAllUsersHistoryPaginated(page: number = 1, limit: number = 10): PaginationResult {
  const db = getDb();
  
  const totalCount = db.prepare('SELECT COUNT(*) as count FROM history').get() as { count: number };
  const offset = (page - 1) * limit;
  
  const rows = db.prepare(`
    SELECT h.*, 
           (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'edited' ORDER BY slot_index)) as edited_images,
           (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'original_for_comparison' ORDER BY slot_index)) as original_images,
           (SELECT JSON_GROUP_ARRAY(url) FROM (SELECT url FROM history_images WHERE history_id = h.id AND type = 'generated_video' ORDER BY slot_index)) as video_urls
    FROM history h
    GROUP BY h.id
    ORDER BY h.timestamp DESC
    LIMIT ? OFFSET ?
  `).all(limit, offset);
  
  const items = rows.map(rowToHistoryItem);
  const hasMore = offset + limit < totalCount.count;
  
  return {
    items,
    totalCount: totalCount.count,
    hasMore,
    currentPage: page
  };
}

export function getHistoryItemStatus(id: string, username: string): VideoStatusPayload | null {
  const db = getDb();
  const stmt = db.prepare(`
    SELECT videoGenerationParams, 
           (SELECT url FROM history_images WHERE history_id = h.id AND type = 'generated_video' LIMIT 1) as video_url
    FROM history h
    WHERE h.id = ? AND h.username = ?
  `);

  const row: any = stmt.get(id, username);

  if (!row) {
    return null; // Item not found or does not belong to the user
  }
  
  if (!row.videoGenerationParams) {
    // This is an image-only item or something is wrong
    return { status: 'unknown' };
  }

  let params: any = {};
  try {
    params = JSON.parse(row.videoGenerationParams);
  } catch (e) {
    console.error('Failed to parse videoGenerationParams JSON for history item', id, e);
    return { status: 'unknown' };
  }

  return {
    status: params.status || 'processing', // Default to processing if status not set
    videoUrl: row.video_url || params.localVideoUrl || null,
    error: params.error,
    seed: params.seed,
  };
}

type FullUser = SessionUser & {
  passwordHash: string;
  gemini_api_key_1?: string; gemini_api_key_1_mode: 'global' | 'user_specific';
  gemini_api_key_2?: string; gemini_api_key_2_mode: 'global' | 'user_specific';
  gemini_api_key_3?: string; gemini_api_key_3_mode: 'global' | 'user_specific';
  fal_api_key?: string; fal_api_key_mode: 'global' | 'user_specific';
};

export function findUserByUsername(username: string): FullUser | null {
  const db = getDb();
  const stmt = db.prepare('SELECT * FROM users WHERE username = ?');
  const row: any = stmt.get(username);

  if (!row) {
    return null;
  }
  return {
    username: row.username,
    passwordHash: row.password_hash,
    role: row.role as 'admin' | 'user',
    isLoggedIn: true, // This is for session compatibility, not stored in DB
    gemini_api_key_1: row.gemini_api_key_1,
    gemini_api_key_1_mode: row.gemini_api_key_1_mode,
    gemini_api_key_2: row.gemini_api_key_2,
    gemini_api_key_2_mode: row.gemini_api_key_2_mode,
    gemini_api_key_3: row.gemini_api_key_3,
    gemini_api_key_3_mode: row.gemini_api_key_3_mode,
    fal_api_key: row.fal_api_key,
    fal_api_key_mode: row.fal_api_key_mode
  };
}

export function findUserByApiKey(apiKey: string): FullUser | null {
  const db = getDb();
  const stmt = db.prepare('SELECT * FROM users WHERE app_api_key = ?');
  const row: any = stmt.get(apiKey);

  if (!row) {
    return null;
  }
  return {
    username: row.username,
    passwordHash: row.password_hash,
    role: row.role as 'admin' | 'user',
    isLoggedIn: true, // For session compatibility
    gemini_api_key_1: row.gemini_api_key_1,
    gemini_api_key_1_mode: row.gemini_api_key_1_mode,
    gemini_api_key_2: row.gemini_api_key_2,
    gemini_api_key_2_mode: row.gemini_api_key_2_mode,
    gemini_api_key_3: row.gemini_api_key_3,
    gemini_api_key_3_mode: row.gemini_api_key_3_mode,
    fal_api_key: row.fal_api_key,
    fal_api_key_mode: row.fal_api_key_mode
  };
}

// Cleanup function for graceful shutdown
export function closeDb(): void {
  if (db) {
    db.close();
  }
}

// Handle process termination
process.on('exit', closeDb);
process.on('SIGINT', closeDb);
process.on('SIGTERM', closeDb);

// TODO: For standalone video history items, ensure the source image is not placed in editedImageUrls.
// Instead, store it in a dedicated field or originalImageUrls. See addStandaloneVideoHistoryItem in actions.
</file>

<file path="src/services/encryption.service.ts">
// src/services/encryption.service.ts
import crypto from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;
const AUTH_TAG_LENGTH = 16;

const secretKey = process.env.ENCRYPTION_SECRET;

if (!secretKey || secretKey.length !== 32) {
  throw new Error('ENCRYPTION_SECRET is not defined or is not 32 characters long in .env file.');
}

const key = Buffer.from(secretKey, 'utf-8');

/**
 * Encrypts a plaintext string.
 * @param text The string to encrypt.
 * @returns A base64 encoded string containing the iv, authTag, and encrypted data.
 */
export function encrypt(text: string): string {
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
  const encrypted = Buffer.concat([cipher.update(text, 'utf8'), cipher.final()]);
  const authTag = cipher.getAuthTag();
  // Concatenate iv, authTag, and encrypted data, then encode as base64
  return Buffer.concat([iv, authTag, encrypted]).toString('base64');
}

/**
 * Decrypts an encrypted, base64 encoded string.
 * @param encryptedText The base64 encoded string to decrypt.
 * @returns The original plaintext string.
 */
export function decrypt(encryptedText: string | null | undefined): string {
  if (!encryptedText) {
    return '';
  }
  try {
    const data = Buffer.from(encryptedText, 'base64');
    const iv = data.slice(0, IV_LENGTH);
    const authTag = data.slice(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);
    const encrypted = data.slice(IV_LENGTH + AUTH_TAG_LENGTH);
    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
    decipher.setAuthTag(authTag);
    const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()]);
    return decrypted.toString('utf8');
  } catch (error) {
    console.error('Decryption failed:', error);
    return '';
  }
}
</file>

<file path="src/services/fal-api/image.service.ts">
'use server';

/**
 * @fileOverview Fal.ai API service for image processing operations
 * 
 * This service handles low-level communication with Fal.ai APIs for image-related tasks:
 * - Background removal using rembg
 * - Image upscaling and face enhancement using sd-ultimateface
 * - Detailed face enhancement using face-detailer
 * 
 * These functions expect data URIs as input and return raw URLs from Fal.ai.
 * They do not handle local storage.
 */

import { fal, createFalClient } from '@fal-ai/client';
import { uploadToFalStorage } from '@/ai/actions/generate-video.action';
import { getApiKeyForUser } from '../apiKey.service';

// Constants for upscaling and face enhancement
const UPSCALE_PROMPT = "high quality fashion photography, high-quality clothing, natural, 8k";
const NEGATIVE_UPSCALE_PROMPT = "low quality, ugly, make-up, fake, deformed";
const UPSCALE_FACE_PROMPT = "photorealistic, detailed natural skin, high quality, natural fashion model";
const NEGATIVE_UPSCALE_FACE_PROMPT = "weird, ugly, make-up, cartoon, anime";

// NEW: Constants for the dedicated Face Detailer endpoint
const FACE_DETAILER_PROMPT = "photorealistic, detailed natural skin, high quality, natural fashion model, defined facial features";
const NEGATIVE_FACE_DETAILER_PROMPT = "weird, ugly, make-up, cartoon, anime";

/**
 * Helper to convert data URI to Blob
 */
function dataUriToBlob(dataURI: string): Blob {
  // Split the data URI
  const [header, data] = dataURI.split(',');
  const mimeMatch = header.match(/:(.*?);/);
  const mime = mimeMatch ? mimeMatch[1] : 'image/jpeg';
  const byteString = atob(data);
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  return new Blob([ab], { type: mime });
}

/**
 * Helper to ensure we have a URL (uploads data URI to Fal Storage if needed)
 */
async function ensureUrl(imageUrlOrDataUri: string, tempFileName: string, username: string): Promise<string> {
  if (imageUrlOrDataUri.startsWith('data:')) {
    console.log(`Data URI detected for ${tempFileName}, uploading to Fal Storage first...`);
    const blob = dataUriToBlob(imageUrlOrDataUri);
    const file = new File([blob], tempFileName, { type: blob.type || 'image/jpeg' });
    const publicUrl = await uploadToFalStorage(file, username);
    console.log(`Image uploaded to ${publicUrl}. Now processing.`);
    return publicUrl;
  }
  return imageUrlOrDataUri;
}

/**
 * Generic helper to run a Fal.ai image workflow, handling subscription and response parsing.
 * @param modelId The ID of the Fal.ai model to run.
 * @param input The input object for the model.
 * @param taskName A descriptive name for the task for logging purposes.
 * @returns Promise<string> The URL of the processed image from Fal.ai.
 */
async function runFalImageWorkflow(modelId: string, input: any, taskName: string, username: string): Promise<string> {
  try {
    console.log(`Calling Fal.ai ${modelId} for ${taskName}...`);

    const falKey = await getApiKeyForUser(username, 'fal');
    const scopedFal = createFalClient({ credentials: falKey });

    // Ensure the input image is a public URL
    if (input.image_url || input.loadimage_1) {
      const key = input.image_url ? 'image_url' : 'loadimage_1';
      input[key] = await ensureUrl(input[key], `${taskName.replace(/\s+/g, '-')}-input.jpg`, username);
    }
    const result: any = await scopedFal.subscribe(modelId, {
      input,
      logs: process.env.NODE_ENV === 'development',
      onQueueUpdate: (update: any) => {
        if (update.status === "IN_PROGRESS" && update.logs && process.env.NODE_ENV === 'development') {
          (update.logs as any[]).forEach((log: any) => console.log(`[Fal.ai Progress - ${taskName}]: ${log.message}`));
        }
      },
    });

    // Robustly parse the output to find the image URL
    let outputImageUrl: string | undefined;
    if (result?.data?.outputs) {
      for (const output of Object.values(result.data.outputs) as any) {
        if (output?.images?.[0]?.url) {
          outputImageUrl = output.images[0].url;
          break;
        }
      }
    } else if (result?.data?.images?.[0]?.url) {
      outputImageUrl = result.data.images[0].url;
    } else if (result?.data?.image?.url) {
      outputImageUrl = result.data.image.url;
    }

    if (!outputImageUrl) {
      console.error(`Fal.ai ${taskName} raw result:`, JSON.stringify(result, null, 2));
      throw new Error(`Fal.ai (${taskName}) did not return a valid image URL.`);
    }

    console.log(`${taskName} completed successfully.`);
    return outputImageUrl;
  } catch (error) {
    console.error(`Error in Fal.ai ${taskName}:`, error);
    throw new Error(`${taskName} failed: ${(error as Error).message}`);
  }
}

/**
 * Removes background from an image using Fal.ai's rembg service
 * @param imageUrlOrDataUri The image data URI or public URL to process
 * @returns Promise<string> The URL of the processed image from Fal.ai
 */
export async function removeBackground(imageUrlOrDataUri: string, username: string): Promise<string> {
  return runFalImageWorkflow("fal-ai/rembg", { image_url: imageUrlOrDataUri }, 'Background Removal', username);
}

/**
 * Upscales and enhances an image using Fal.ai's sd-ultimateface service
 * @param imageUrlOrDataUri The image URL or data URI to process
 * @returns Promise<string> The URL of the processed image from Fal.ai
 */
export async function upscaleAndEnhance(imageUrlOrDataUri: string, username: string): Promise<string> {
  const input = {
    loadimage_1: imageUrlOrDataUri,
    prompt_upscale: UPSCALE_PROMPT,
    negative_upscale: NEGATIVE_UPSCALE_PROMPT,
    prompt_face: UPSCALE_FACE_PROMPT,
    negative_face: NEGATIVE_UPSCALE_FACE_PROMPT,
  };
  return runFalImageWorkflow("comfy/opj161/sd-ultimateface", input, 'Upscaling and Enhancement', username);
}

/**
 * Enhances faces in an image using Fal.ai's face-detailer service
 * @param imageUrlOrDataUri The image URL or data URI to process
 * @returns Promise<string> The URL of the processed image from Fal.ai
 */
export async function detailFaces(imageUrlOrDataUri: string, username: string): Promise<string> {
  const input = {
    loadimage_1: imageUrlOrDataUri,
    prompt_face: FACE_DETAILER_PROMPT,
    negative_face: NEGATIVE_FACE_DETAILER_PROMPT,
  };
  return runFalImageWorkflow("comfy/opj161/face-detailer", input, 'Face Detailing', username);
}

/**
 * Checks if the Fal.ai services are configured and available.
 * @returns {Promise<boolean>} True if the service is available, otherwise false.
 */
export async function isServiceAvailable(): Promise<boolean> {
  // Now, we can only check if the service is potentially available.
  // A true availability check would require a username to check for keys.
  // A simple check is to see if any global key is set.
  const globalKey = (await import('../settings.service')).getSetting('global_fal_api_key');
  const { decrypt } = await import('../encryption.service');
  return !!decrypt(globalKey);
}
</file>

<file path="src/services/fal-api/video.service.ts">
'use server';

/**
 * @fileOverview Fal.ai API service for video processing operations
 * 
 * This service handles low-level communication with Fal.ai APIs for video-related tasks:
 * - Video generation using Seedance image-to-video model
 * 
 * These functions interact directly with Fal.ai and return task IDs or raw results.
 * They do not handle local storage or history management.
 */

import { fal } from '@fal-ai/client';
import { getApiKeyForUser } from '../apiKey.service';
import { getSetting, getBooleanSetting } from '../settings.service';

export interface VideoGenerationInput {
  prompt: string;
  image_url: string;
  videoModel?: 'lite' | 'pro';
  resolution?: '480p' | '720p' | '1080p';
  duration?: '5' | '10';
  camera_fixed?: boolean;
  seed?: number;
}

export interface VideoGenerationResult {
  video?: {
    url: string;
  };
  seed?: number;
}

/**
 * Starts a video generation task using Fal.ai's Seedance service
 * @param input The video generation parameters
 * @returns Promise<string> The task ID for tracking the video generation
 */
export async function startVideoGeneration(input: VideoGenerationInput): Promise<string> {
  try {
    console.log('Starting video generation with Fal.ai Seedance...');
    
    // Prepare the input for Fal.ai, only including defined values
    const falInput: any = {
      prompt: input.prompt,
      image_url: input.image_url,
    };
    
    // Add optional parameters only if they have values
    if (input.resolution) {
      falInput.resolution = input.resolution;
    }
    if (input.duration) {
      falInput.duration = input.duration;
    }
    if (typeof input.camera_fixed === 'boolean') {
      falInput.camera_fixed = input.camera_fixed;
    }
    if (typeof input.seed === 'number' && input.seed !== undefined) {
      falInput.seed = input.seed;
    }
    
    console.log('Fal.ai input parameters:', JSON.stringify(falInput, null, 2));
    
    // Submit the task to Fal.ai queue
    const { request_id } = await fal.queue.submit('fal-ai/bytedance/seedance/v1/lite/image-to-video', {
      input: falInput,
    });
    
    console.log(`Video generation task started. Task ID: ${request_id}`);
    return request_id;
    
  } catch (error) {
    console.error('Error starting video generation:', error);
    throw new Error(`Failed to start video generation: ${(error as Error).message}`);
  }
}

/**
 * Gets the status and result of a video generation task
 * @param taskId The task ID returned from startVideoGeneration
 * @returns Promise<VideoGenerationResult | null> The result if completed, null if still processing
 */
export async function getVideoGenerationResult(taskId: string): Promise<VideoGenerationResult | null> {
  try {
    console.log(`Checking status of video generation task: ${taskId}`);
    
    const result = await fal.queue.status('fal-ai/bytedance/seedance/v1/lite/image-to-video', {
      requestId: taskId,
      logs: process.env.NODE_ENV === 'development'
    });
    
    if (result.status === 'COMPLETED') {
      console.log('Video generation completed successfully');
      return (result as any).responseBody as VideoGenerationResult;
    } else {
      console.log(`Video generation still in progress. Status: ${result.status}`);
      return null; // Still processing
    }
    
  } catch (error) {
    console.error('Error checking video generation status:', error);
    throw new Error(`Failed to check video generation status: ${(error as Error).message}`);
  }
}

/**
 * Starts a video generation task using a webhook for completion notification
 * @param input The video generation parameters
 * @param webhookUrl The URL that fal.ai will call upon completion
 * @param username The username for fetching the API key
 * @returns Promise<string> The request ID for the submitted job
 */
export async function startVideoGenerationWithWebhook(input: VideoGenerationInput, webhookUrl: string, username: string): Promise<string> {
  try {
    console.log('Submitting video job to Fal.ai with webhook:', webhookUrl);
    const modelId = input.videoModel === 'pro'
      ? 'fal-ai/bytedance/seedance/v1/pro/image-to-video'
      : 'fal-ai/bytedance/seedance/v1/lite/image-to-video';
    const falInput: any = {
      prompt: input.prompt,
      image_url: input.image_url,
    };
    if (input.resolution) falInput.resolution = input.resolution;
    if (input.duration) falInput.duration = input.duration;
    if (typeof input.camera_fixed === 'boolean') falInput.camera_fixed = input.camera_fixed;
    if (typeof input.seed === 'number' && input.seed !== undefined) falInput.seed = input.seed;
    console.log('Fal.ai input parameters:', JSON.stringify(falInput, null, 2));
    const falKey = await getApiKeyForUser(username, 'fal');
    const response = await fetch(`https://queue.fal.run/${modelId}?fal_webhook=${encodeURIComponent(webhookUrl)}`, {
      method: 'POST',
      headers: {
        'Authorization': `Key ${falKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(falInput),
    });
    if (!response.ok) {
      throw new Error(`Fal.ai API error: ${response.statusText}`);
    }
    const data = await response.json();
    return data.request_id;
  } catch (error) {
    console.error('Error submitting video job to Fal.ai:', error);
    throw error;
  }
}

/**
 * Checks if the video generation service is available by verifying the API key
 * @returns Promise<boolean> True if the service is configured and available
 */
export async function isVideoServiceAvailable(): Promise<boolean> {
  // Check if the feature flag is enabled AND a global key exists.
  // This is the best we can do without a user context.
  const featureEnabled = getBooleanSetting('feature_video_generation');
  const globalKey = getSetting('global_fal_api_key');
  return featureEnabled && !!globalKey;
}
</file>

<file path="src/services/settings.service.ts">
// src/services/settings.service.ts
import * as dbService from '@/services/database.service';

const DEFAULTS = {
  'feature_video_generation': 'true',
  'feature_background_removal': 'true',
  'feature_image_upscaling': 'true',
  'feature_face_detailer': 'true',
  // New global API key settings
  'global_gemini_api_key_1': '',
  'global_gemini_api_key_2': '',
  'global_gemini_api_key_3': '',
  'global_fal_api_key': '',
};

// Type for keys to ensure type safety
export type SettingKey = keyof typeof DEFAULTS;

/**
 * Gets the value of a specific setting key from the database.
 * If the key doesn't exist, it returns the default value.
 * @param key The key of the setting to retrieve.
 * @returns The value of the setting as a string.
 */
export function getSetting(key: SettingKey): string {
  const db = dbService.getDb();
  const stmt = db.prepare('SELECT value FROM settings WHERE key = ?');
  const result = stmt.get(key) as { value: string } | undefined;
  return result?.value ?? DEFAULTS[key];
}

/**
 * Gets a boolean representation of a setting.
 * @param key The key of the setting to retrieve.
 * @returns True if the setting value is 'true', otherwise false.
 */
export function getBooleanSetting(key: SettingKey): boolean {
  return getSetting(key) === 'true';
}

/**
 * Sets the value for a specific setting key in the database.
 * @param key The key of the setting to update.
 * @param value The new value for the setting.
 */
export function setSetting(key: SettingKey, value: string): void {
  const db = dbService.getDb();
  const stmt = db.prepare('INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)');
  stmt.run(key, value);
}

/**
 * Gets all settings from the database.
 * @returns A record of all settings.
 */
export function getAllSettings(): Record<SettingKey, string> {
    const db = dbService.getDb();
    const stmt = db.prepare('SELECT key, value FROM settings');
    const rows = stmt.all() as { key: SettingKey, value: string }[];
    
    // Start with all defaults
    const allSettings: Record<string, string> = { ...DEFAULTS };
    
    // Override with values from DB
    for (const row of rows) {
        if (Object.keys(DEFAULTS).includes(row.key)) {
            allSettings[row.key] = row.value;
        }
    }
    
    return allSettings as Record<SettingKey, string>;
}
</file>

<file path="src/services/storage.service.ts">
'use server';

/**
 * @fileOverview Centralized storage service for handling file downloads and local storage
 * 
 * This service provides a unified way to download files from URLs and save them locally
 * with proper permissions and naming conventions. It eliminates code duplication across
 * different actions that need to save files.
 */

import { promises as fs } from 'fs';
import path from 'path';
import { v4 as uuidv4 } from 'uuid';
import crypto from 'crypto';

/**
 * Downloads a file from a URL and saves it locally with proper permissions
 * @param sourceUrl The URL to download the file from
 * @param fileNamePrefix The prefix to use for the generated filename
 * @param subfolder The subfolder within /public/uploads/ to save to
 * @param extension The file extension (defaults to 'png')
 * @returns Promise<string> The relative URL path to the saved file
 */
export async function saveFileFromUrl(
  sourceUrl: string, 
  fileNamePrefix: string, 
  subfolder: string,
  extension: string = 'png'
): Promise<{ relativeUrl: string; hash: string }> {
  console.log(`Downloading from ${sourceUrl} to save in /uploads/${subfolder}`);
  try {
    // Download the file from the URL
    const response = await fetch(sourceUrl);
    if (!response.ok) {
      throw new Error(`Failed to download file: ${response.statusText}`);
    }

    // Convert to buffer
    const fileBuffer = Buffer.from(await response.arrayBuffer());
    
    // Calculate hash of the file content
    const fileHash = crypto.createHash('sha256').update(fileBuffer).digest('hex');
    
    // Generate unique filename
    const uniqueFileName = `${fileNamePrefix}_${uuidv4()}.${extension}`;
    
    // Create upload directory path
    const uploadDir = path.join(process.cwd(), 'public', 'uploads', subfolder);
    
    // Ensure directory exists
    await fs.mkdir(uploadDir, { recursive: true });
    
    // Write file
    const filePath = path.join(uploadDir, uniqueFileName);
    await fs.writeFile(filePath, fileBuffer);

    // Set proper permissions and ownership
    try {
      await fs.chmod(filePath, 0o664); // More secure default than 777
      console.log(`Set file permissions to 664 for: ${filePath}`);
    } catch (chmodError) {
      console.warn(`Warning: Could not set file permissions for ${filePath}:`, chmodError);
    }

    // Set proper ownership using PUID/PGID if available
    const puid = process.env.PUID;
    const pgid = process.env.PGID;
    if (puid && pgid) {
      try {
        await fs.chown(filePath, parseInt(puid), parseInt(pgid));
        console.log(`Set file ownership to ${puid}:${pgid} for: ${filePath}`);
      } catch (chownError) {
        console.warn(`Warning: Could not set file ownership for ${filePath}:`, chownError);
      }
    }
    
    // Return relative URL
    const relativeUrl = `/uploads/${subfolder}/${uniqueFileName}`;
    console.log(`File saved to: ${filePath}, accessible at: ${relativeUrl}`);
    return { relativeUrl, hash: fileHash };
    
  } catch (error) {
    console.error(`Error saving file from ${sourceUrl}:`, error);
    throw new Error(`Failed to save file from URL: ${(error as Error).message}`);
  }
}

/**
 * Saves a data URI (base64 encoded image) locally with proper permissions
 * @param dataUri The data URI to save (e.g., "data:image/png;base64,...")
 * @param fileNamePrefix The prefix to use for the generated filename
 * @param subfolder The subfolder within /public/uploads/ to save to
 * @returns Promise<string> The relative URL path to the saved file
 */
export async function saveDataUriLocally(
  dataUri: string,
  fileNamePrefix: string,
  subfolder: string
): Promise<{ relativeUrl: string; hash: string }> {
  console.log(`Saving data URI to /uploads/${subfolder}`);
  try {
    // Parse data URI
    const match = dataUri.match(/^data:(image\/\w+);base64,(.+)$/);
    if (!match) {
      throw new Error('Invalid data URI format');
    }
    const mimeType = match[1];
    const base64Data = match[2];
    const buffer = Buffer.from(base64Data, 'base64');
    const extension = mimeType.split('/')[1] || 'png';
    // Calculate hash
    const fileHash = crypto.createHash('sha256').update(buffer).digest('hex');
    // Generate unique filename
    const uniqueFileName = `${fileNamePrefix}_${uuidv4()}.${extension}`;
    
    // Create upload directory path
    const uploadDir = path.join(process.cwd(), 'public', 'uploads', subfolder);
    
    // Ensure directory exists
    await fs.mkdir(uploadDir, { recursive: true });
    
    // Write file
    const filePath = path.join(uploadDir, uniqueFileName);
    await fs.writeFile(filePath, buffer);

    // Set proper permissions and ownership
    try {
      await fs.chmod(filePath, 0o664);
      console.log(`Set file permissions to 664 for: ${filePath}`);
    } catch (chmodError) {
      console.warn(`Warning: Could not set file permissions for ${filePath}:`, chmodError);
    }

    const puid = process.env.PUID;
    const pgid = process.env.PGID;
    if (puid && pgid) {
      try {
        await fs.chown(filePath, parseInt(puid), parseInt(pgid));
        console.log(`Set file ownership to ${puid}:${pgid} for: ${filePath}`);
      } catch (chownError) {
        console.warn(`Warning: Could not set file ownership for ${filePath}:`, chownError);
      }
    }
    
    // Return relative URL
    const relativeUrl = `/uploads/${subfolder}/${uniqueFileName}`;
    console.log(`Data URI saved to: ${filePath}, accessible at: ${relativeUrl}`);
    return { relativeUrl, hash: fileHash };
  } catch (error) {
    console.error(`Error saving data URI:`, error);
    throw new Error(`Failed to save data URI: ${(error as Error).message}`);
  }
}
</file>

<file path="src/stores/__tests__/imageStore.test.ts">
// src/stores/__tests__/imageStore.test.ts
import { renderHook, act } from '@testing-library/react';
import { useImageStore, getStoreSnapshot } from '../imageStore';

// Mock the server actions
jest.mock('@/ai/actions/remove-background.action', () => ({
  removeBackgroundAction: jest.fn().mockResolvedValue({ savedPath: '/test/bg-removed.jpg' })
}));

jest.mock('@/ai/actions/upscale-image.action', () => ({
  upscaleImageAction: jest.fn().mockResolvedValue({ savedPath: '/test/upscaled.jpg' }),
  faceDetailerAction: jest.fn().mockResolvedValue({ savedPath: '/test/face-detailed.jpg' })
}));

// Mock File and crypto for browser environment
global.File = class MockFile extends File {
  constructor(chunks: any[], filename: string, options?: any) {
    super(chunks, filename, options);
  }
} as any;

// Mock crypto.subtle
Object.defineProperty(global, 'crypto', {
  value: {
    subtle: {
      digest: jest.fn().mockResolvedValue(new ArrayBuffer(32))
    }
  }
});

// Mock FileReader
global.FileReader = class MockFileReader {
  result = 'data:image/jpeg;base64,test-data-uri';
  onload: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null = null;
  onerror: ((this: FileReader, ev: ProgressEvent<FileReader>) => any) | null = null;
  
  readAsDataURL(file: File) {
    setTimeout(() => {
      if (this.onload) {
        this.onload.call(this as any, {} as ProgressEvent<FileReader>);
      }
    }, 0);
  }
} as any;

describe('ImageStore', () => {
  beforeEach(() => {
    // Reset store state before each test
    useImageStore.getState().reset();
  });

  describe('Initial State', () => {
    it('should have correct initial state', () => {
      const snapshot = getStoreSnapshot();
      expect(snapshot).toEqual({
        hasOriginal: false,
        versionCount: 0,
        activeVersionId: null,
        isProcessing: false,
        processingStep: null,
        hasComparison: false,
      });
    });
  });

  describe('Setting Original Image', () => {
    it('should set original image and create original version', async () => {
      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });
      const testDataUri = 'data:image/jpeg;base64,test';
      const testHash = 'test-hash';

      await act(async () => {
        useImageStore.getState().setOriginalImage(mockFile, testDataUri, testHash);
      });

      const state = useImageStore.getState();
      
      expect(state.original).toEqual({
        file: mockFile,
        dataUri: testDataUri,
        hash: testHash
      });
      
      expect(state.versions['original']).toEqual(
        expect.objectContaining({
          id: 'original',
          dataUri: testDataUri,
          label: 'Original',
          sourceVersionId: '',
        })
      );
      
      expect(state.activeVersionId).toBe('original');
    });
  });

  describe('Version Management', () => {
    beforeEach(async () => {
      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });
      await act(async () => {
        useImageStore.getState().setOriginalImage(mockFile, 'data:test', 'hash');
      });
    });

    it('should add new version and set as active', () => {
      const newVersionData = {
        dataUri: 'data:cropped',
        label: 'Cropped',
        sourceVersionId: 'original',
        hash: 'test-hash-123'
      };

      let newVersionId: string = '';
      act(() => {
        newVersionId = useImageStore.getState().addVersion(newVersionData);
      });

      const state = useImageStore.getState();
      expect(state.versions[newVersionId]).toEqual(
        expect.objectContaining(newVersionData)
      );
      expect(state.activeVersionId).toBe(newVersionId);
    });

    it('should switch active version', () => {
      let versionId: string = '';
      act(() => {
        versionId = useImageStore.getState().addVersion({
          dataUri: 'data:cropped',
          label: 'Cropped', 
          sourceVersionId: 'original',
          hash: 'test-hash-456'
        });
      });

      act(() => {
        useImageStore.getState().setActiveVersion('original');
      });

      expect(useImageStore.getState().activeVersionId).toBe('original');

      act(() => {
        useImageStore.getState().setActiveVersion(versionId);
      });

      expect(useImageStore.getState().activeVersionId).toBe(versionId);
    });
  });

  describe('Processing States', () => {
    it('should manage processing state correctly', () => {
      act(() => {
        useImageStore.getState().setProcessing(true, 'crop');
      });

      let state = useImageStore.getState();
      expect(state.isProcessing).toBe(true);
      expect(state.processingStep).toBe('crop');

      act(() => {
        useImageStore.getState().setProcessing(false, null);
      });

      state = useImageStore.getState();
      expect(state.isProcessing).toBe(false);
      expect(state.processingStep).toBe(null);
    });
  });

  describe('Comparison Management', () => {
    beforeEach(async () => {
      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });
      await act(async () => {
        useImageStore.getState().setOriginalImage(mockFile, 'data:test', 'hash');
      });
    });

    it('should set and clear comparison', () => {
      const comparison = {
        left: 'data:left',
        right: 'data:right'
      };

      act(() => {
        useImageStore.getState().setComparison(comparison);
      });

      expect(useImageStore.getState().comparison).toEqual(comparison);

      act(() => {
        useImageStore.getState().setComparison(null);
      });

      expect(useImageStore.getState().comparison).toBe(null);
    });
  });

  describe('Async Actions', () => {
    beforeEach(async () => {
      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });
      await act(async () => {
        useImageStore.getState().setOriginalImage(mockFile, 'data:original', 'hash');
      });
    });

    it('should handle background removal', async () => {
      await act(async () => {
        await useImageStore.getState().removeBackground('test-user');
      });

      const state = useImageStore.getState();
      
      // Should create new version
      const bgRemovedVersion = Object.values(state.versions).find(v => 
        v.label === 'Background Removed'
      );
      expect(bgRemovedVersion).toBeDefined();
      expect(bgRemovedVersion?.dataUri).toBe('/test/bg-removed.jpg');
      
      // Should set up comparison
      expect(state.comparison).toEqual({
        left: 'data:original',
        right: '/test/bg-removed.jpg'
      });
      
      // Should not be processing
      expect(state.isProcessing).toBe(false);
    });

    it('should handle upscaling', async () => {
      await act(async () => {
        await useImageStore.getState().upscaleImage('test-user');
      });

      const state = useImageStore.getState();
      
      const upscaledVersion = Object.values(state.versions).find(v => 
        v.label === 'Upscaled'
      );
      expect(upscaledVersion).toBeDefined();
      expect(upscaledVersion?.dataUri).toBe('/test/upscaled.jpg');
    });

    it('should handle face detailing', async () => {
      await act(async () => {
        await useImageStore.getState().faceDetailer('test-user');
      });

      const state = useImageStore.getState();
      
      const faceDetailedVersion = Object.values(state.versions).find(v => 
        v.label === 'Face Enhanced'
      );
      expect(faceDetailedVersion).toBeDefined();
      expect(faceDetailedVersion?.dataUri).toBe('/test/face-detailed.jpg');
    });

    it('should handle errors in async actions', async () => {
      // Mock a failing action
      const { removeBackgroundAction } = require('@/ai/actions/remove-background.action');
      removeBackgroundAction.mockRejectedValueOnce(new Error('Test error'));

      await expect(
        act(async () => {
          await useImageStore.getState().removeBackground('test-user');
        })
      ).rejects.toThrow('Test error');

      // Should reset processing state on error
      const state = useImageStore.getState();
      expect(state.isProcessing).toBe(false);
      expect(state.processingStep).toBe(null);
    });
  });

  describe('Reset Functionality', () => {
    it('should reset to initial state', async () => {
      // Set up some state
      const mockFile = new File(['test'], 'test.jpg', { type: 'image/jpeg' });
      await act(async () => {
        useImageStore.getState().setOriginalImage(mockFile, 'data:test', 'hash');
        useImageStore.getState().setProcessing(true, 'crop');
        useImageStore.getState().setComparison({ left: 'a', right: 'b' });
      });

      // Reset
      act(() => {
        useImageStore.getState().reset();
      });

      // Should be back to initial state
      const snapshot = getStoreSnapshot();
      expect(snapshot).toEqual({
        hasOriginal: false,
        versionCount: 0,
        activeVersionId: null,
        isProcessing: false,
        processingStep: null,
        hasComparison: false,
      });
    });
  });
});
</file>

<file path="src/stores/imageStore.ts">
// src/stores/imageStore.ts
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

// Server Actions
import { removeBackgroundAction } from "@/ai/actions/remove-background.action";
import { upscaleImageAction, faceDetailerAction } from "@/ai/actions/upscale-image.action";
import { uploadAndResizeImageAction } from "@/ai/actions/upload-and-resize-image.action";

// --- Types ---
export interface ImageVersion {
  id: string;
  dataUri: string;
  label: string;
  sourceVersionId: string;
  createdAt: number;
  hash: string;
}

export interface ImageState {
  original: {
    file: File;
    dataUri: string;
    hash: string;
  } | null;
  versions: Record<string, ImageVersion>;
  activeVersionId: string | null;
  comparison: {
    left: string;
    right: string;
  } | null;
  isProcessing: boolean;
  processingStep: 'upload' | 'crop' | 'bg' | 'upscale' | 'face' | 'confirm' | null;
}

export interface ImageActions {
  // Synchronous actions
  setOriginalImage: (file: File, dataUri: string, hash: string) => void;
  addVersion: (version: Omit<ImageVersion, 'id' | 'createdAt'>) => string;
  setActiveVersion: (versionId: string) => void;
  setComparison: (comparison: { left: string; right: string } | null) => void;
  setProcessing: (isProcessing: boolean, step: ImageState['processingStep']) => void;
  reset: () => void;
  
  // Async actions
  removeBackground: (username: string) => Promise<void>;
  upscaleImage: (username: string) => Promise<void>;
  faceDetailer: (username: string) => Promise<void>;
  uploadOriginalImage: (file: File) => Promise<{ resized: boolean; originalWidth: number; originalHeight: number; }>;

}

export type ImageStore = ImageState & ImageActions;

// --- Helper Functions ---
const fileToDataUri = (file: File): Promise<string> => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => resolve(reader.result as string);
  reader.onerror = reject;
  reader.readAsDataURL(file);
});

const generateHash = async (file: File): Promise<string> => {
  const buffer = await file.arrayBuffer();
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
};

const dataUriToBlob = (dataUri: string): Blob => {
  const byteString = atob(dataUri.split(',')[1]);
  const mimeString = dataUri.split(',')[0].split(':')[1].split(';')[0];
  const ab = new ArrayBuffer(byteString.length);
  const ia = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia[i] = byteString.charCodeAt(i);
  }
  return new Blob([ab], { type: mimeString });
};

// --- Initial State ---
const initialState: ImageState = {
  original: null,
  versions: {},
  activeVersionId: null,
  comparison: null,
  isProcessing: false,
  processingStep: null,
};

// --- Store Implementation ---
export const useImageStore = create<ImageStore>()(
  devtools(
    (set, get) => ({
      ...initialState,

      // --- Synchronous Actions ---
      setOriginalImage: async (file: File, dataUri: string, hash: string) => {
        const originalVersion: ImageVersion = {
          id: 'original',
          dataUri,
          label: 'Original',
          sourceVersionId: '',
          createdAt: Date.now(),
          hash,
        };

        set({
          original: { file, dataUri, hash },
          versions: { original: originalVersion },
          activeVersionId: 'original',
          comparison: null,
          isProcessing: false,
          processingStep: null,
        }, false, 'setOriginalImage');
      },

      addVersion: (version: Omit<ImageVersion, 'id' | 'createdAt'>) => {
        const id = `${version.label.toLowerCase().replace(/\s+/g, '_')}_${Date.now()}`;
        const newVersion: ImageVersion = {
          ...version,
          id,
          createdAt: Date.now(),
        };

        set((state) => ({
          versions: {
            ...state.versions,
            [id]: newVersion,
          },
          activeVersionId: id,
          isProcessing: false,
          processingStep: null,
        }), false, 'addVersion');

        return id;
      },

      setActiveVersion: (versionId: string) => {
        set({
          activeVersionId: versionId,
          comparison: null, // Clear comparison when switching versions
        }, false, 'setActiveVersion');
      },

      setComparison: (comparison: { left: string; right: string } | null) => {
        set({ comparison }, false, 'setComparison');
      },

      setProcessing: (isProcessing: boolean, step: ImageState['processingStep']) => {
        set({ isProcessing, processingStep: step }, false, 'setProcessing');
      },

      reset: () => {
        set(initialState, false, 'reset');
      },

      // --- Async Actions ---
      removeBackground: async (username: string) => {
        const { activeVersionId, versions } = get();
        if (!activeVersionId || !versions[activeVersionId]) {
          console.warn('No active version for background removal');
          return;
        }
        const currentVersion = versions[activeVersionId];
        set({ isProcessing: true, processingStep: 'bg' }, false, 'removeBackground:start');
        try {
          let imageUrlOrDataUri = currentVersion.dataUri;
          if (imageUrlOrDataUri.startsWith('/uploads/')) {
            imageUrlOrDataUri = new URL(imageUrlOrDataUri, window.location.origin).href;
          }
          const { savedPath, outputHash } = await removeBackgroundAction(
            imageUrlOrDataUri,
            currentVersion.hash
          ); // username is now handled inside removeBackgroundAction
          get().addVersion({
            dataUri: savedPath,
            label: 'Background Removed',
            sourceVersionId: activeVersionId,
            hash: outputHash,
          });
        } catch (error) {
          console.error('Error removing background:', error);
        } finally {
          set({ isProcessing: false, processingStep: null }, false, 'removeBackground:end');
        }
      },
      upscaleImage: async (username: string) => {
        const { activeVersionId, versions, original } = get();
        if (!activeVersionId || !versions[activeVersionId]) {
          console.warn('No active version for upscaling');
          return;
        }
        const currentVersion = versions[activeVersionId];
        set({ isProcessing: true, processingStep: 'upscale' }, false, 'upscaleImage:start');
        try {
          let imageUrlOrDataUri = currentVersion.dataUri;
          if (imageUrlOrDataUri.startsWith('/uploads/')) {
            imageUrlOrDataUri = new URL(imageUrlOrDataUri, window.location.origin).href;
          }
          const { savedPath, outputHash } = await upscaleImageAction(
            imageUrlOrDataUri,
            currentVersion.hash
          ); // username is now handled inside upscaleImageAction
          get().addVersion({
            dataUri: savedPath,
            label: 'Upscaled',
            sourceVersionId: activeVersionId,
            hash: outputHash,
          });
        } catch (error) {
          console.error('Error upscaling image:', error);
        } finally {
          set({ isProcessing: false, processingStep: null }, false, 'upscaleImage:end');
        }
      },
      faceDetailer: async (username: string) => {
        const { activeVersionId, versions, original } = get();
        if (!activeVersionId || !versions[activeVersionId]) {
          console.warn('No active version for face detailer');
          return;
        }
        const currentVersion = versions[activeVersionId];
        set({ isProcessing: true, processingStep: 'face' }, false, 'faceDetailer:start');
        try {
          let imageUrlOrDataUri = currentVersion.dataUri;
          if (imageUrlOrDataUri.startsWith('/uploads/')) {
            imageUrlOrDataUri = new URL(imageUrlOrDataUri, window.location.origin).href;
          }
          const { savedPath, outputHash } = await faceDetailerAction(
            imageUrlOrDataUri,
            currentVersion.hash
          ); // username is now handled inside faceDetailerAction
          get().addVersion({
            dataUri: savedPath,
            label: 'Face Enhanced',
            sourceVersionId: activeVersionId,
            hash: outputHash,
          });
        } catch (error) {
          console.error('Error enhancing face details:', error);
        } finally {
          set({ isProcessing: false, processingStep: null }, false, 'faceDetailer:end');
        }
      },

      uploadOriginalImage: async (file: File) => {
        get().setProcessing(true, 'upload');
        try {
          const formData = new FormData();
          formData.append('file', file);

          const { dataUri, hash, resized, originalWidth, originalHeight } = await uploadAndResizeImageAction(formData);

          const blob = dataUriToBlob(dataUri);
          const resizedFile = new File([blob], file.name, { type: blob.type });

          get().setOriginalImage(resizedFile, dataUri, hash);
          return { resized, originalWidth, originalHeight };
        } catch (error) {
          console.error('Upload and resize failed in store action:', error);
          get().setProcessing(false, null);
          throw error;
        } finally {
          get().setProcessing(false, null);
        }
      },
    }),
    {
      name: 'image-store', // This will show up in Redux DevTools
    }
  )
);

// --- Convenience Selectors ---
export const useActiveImage = () => useImageStore((state) => {
  const { activeVersionId, versions } = state;
  return activeVersionId ? versions[activeVersionId] : null;
});

export const useImageProcessingState = () => useImageStore((state) => ({
  isProcessing: state.isProcessing,
  processingStep: state.processingStep,
}));

// --- Debug Helpers ---
export const getStoreSnapshot = () => {
  const state = useImageStore.getState();
  return {
    hasOriginal: !!state.original,
    versionCount: Object.keys(state.versions).length,
    activeVersionId: state.activeVersionId,
    isProcessing: state.isProcessing,
    processingStep: state.processingStep,
    hasComparison: !!state.comparison,
  };
};

// For development - access in console as window.imageStore
if (typeof window !== 'undefined') {
  (window as any).imageStore = useImageStore;
  (window as any).imageStoreSnapshot = getStoreSnapshot;
}
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

export default {
    darkMode: ["class"],
    content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
            'background-accent': 'hsl(var(--background-accent))', // ADD THIS LINE
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		},
  		keyframes: {
  			'accordion-down': {
  				from: {
  					height: '0'
  				},
  				to: {
  					height: 'var(--radix-accordion-content-height)'
  				}
  			},
  			'accordion-up': {
  				from: {
  					height: 'var(--radix-accordion-content-height)'
  				},
  				to: {
  					height: '0'
  				}
  			},
        'progress-ribbings': {
          '0%': { backgroundPosition: '100% 0' },
          '100%': { backgroundPosition: '0 0' }
        },
        'progress-pulsation': {
          '0%': { boxShadow: '0 0 0 0 rgba(0, 123, 255, 0.4)' },
          '70%': { boxShadow: '0 0 0 10px rgba(0, 123, 255, 0)' },
          '100%': { boxShadow: '0 0 0 0 rgba(0, 123, 255, 0)' }
        },
        'progress-completion': {
          '0%': { backgroundColor: 'hsl(var(--primary))' },
          '50%': { backgroundColor: 'hsl(142, 76%, 36%)', boxShadow: '0 0 20px rgba(34, 197, 94, 0.5)' },
          '100%': { backgroundColor: 'hsl(142, 76%, 36%)', boxShadow: '0 0 10px rgba(34, 197, 94, 0.3)' }
        },
        // Enhanced motion animations
        'spring-quick': {
          '0%': { transform: 'scale(0)' },
          '100%': { transform: 'scale(1)' }
        },
        'spring-standard': {
          '0%': { transform: 'scale(0)' },
          '100%': { transform: 'scale(1)' }
        },
        'bounce-subtle': {
          '0%': { transform: 'translateY(0)' },
          '50%': { transform: 'translateY(-20px)' },
          '100%': { transform: 'translateY(0)' }
        },
        'shimmer': {
          '0%, 100%': { backgroundPosition: '-100% 0' },
          '50%': { backgroundPosition: '100% 0' },
        },
  		},
  		animation: {
  			'accordion-down': 'accordion-down 0.2s ease-out',
  			'accordion-up': 'accordion-up 0.2s ease-out',
        'progress-ribbings': 'progress-ribbings 2s linear infinite',
        'progress-pulsation': 'progress-pulsation 1.5s infinite',
        'progress-completion': 'progress-completion 1s ease-in-out',
        // Enhanced motion animations
        'spring-quick': 'spring-quick var(--motion-spring-quick)',
        'spring-standard': 'spring-standard var(--motion-spring-standard)',
        'bounce-subtle': 'bounce-subtle var(--motion-bounce-subtle)',
        'shimmer': 'shimmer 3s infinite linear',
  		},
      fontFamily: {
        sans: ['Satoshi', 'sans-serif'],
      },
  	}
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;
</file>

<file path="tsconfig.jest.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "jsx": "react-jsx"
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="tsconfig.scripts.json">
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "module": "commonjs",
    "target": "es2020",
    "moduleResolution": "node",
    "outDir": "dist",
    "rootDir": ".",
    "noEmit": false,
    "isolatedModules": false,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true
  },
  "include": ["scripts/**/*.ts", "src/**/*.ts"],
  "exclude": ["node_modules", ".next", "dist"]
}
</file>

</files>
